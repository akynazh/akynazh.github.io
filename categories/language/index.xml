<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Language on Norwegian Wood</title>
    <link>akynazh.site/categories/language/</link>
    <description>Recent content in Language on Norwegian Wood</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Jzh</copyright>
    <lastBuildDate>Wed, 04 Jan 2023 22:55:27 +0800</lastBuildDate><atom:link href="akynazh.site/categories/language/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>pipenv 简单使用记录</title>
      <link>akynazh.site/posts/2023/01/simple-use-record-of-pipenv/</link>
      <pubDate>Wed, 04 Jan 2023 22:55:27 +0800</pubDate>
      
      <guid>akynazh.site/posts/2023/01/simple-use-record-of-pipenv/</guid>
      <description>关于pipenv pipenv集成了pip，virtualenv两者的功能，且完善了两者的一些缺陷。
安装pipenv 1pip install pipenv -U 创建虚拟环境 初次创建环境可以使用以下类似命令：
1pipenv install --python C:/Users/akyna/AppData/Local/Programs/Python/Python37/python.exe --pypi-mirror https://pypi.tuna.tsinghua.edu.cn/simple --python 是可选的，可以指定python版本，参数为python解释器的绝对路径，如果不指定，默认使用当前系统的python。
--pypi-mirror 是可选的，可以指定镜像，加速下载。
创建好后，在当前目录下将会生成 Pipfile 文件，在 ~\.virtualenvs 下生成虚拟环境目录（存放python解释器和依赖）。
如果目录中已经存在 Pipfile 或者 requirements.txt，pipenv会自动检测这两个文件并将对应依赖进行安装。
查看虚拟环境目录位置：
1pipenv --venv 激活虚拟环境 1pipenv shell # 激活虚拟环境 2 3python -V 如果激活了虚拟环境，在当前shell下，使用的python或者pip都是虚拟环境中的python和pip。
配置Pip并安装依赖 配置镜像源为清华源：
1vim Pipfile 2 3[[source]] 4url = &amp;#34;https://pypi.tuna.tsinghua.edu.cn/simple&amp;#34; 以后所有依赖的安装都不需要指定 --pypi-mirror 了。
安装依赖：（建议关闭代理，如果有的话）
1pipenv install {pkg} # 如果激活了虚拟环境，可以使用pip 2# pipenv install -r requirements.txt 安装完依赖后，将会生成 Pipfile.lock 文件，以后初始化虚拟环境都只需要运行 pipenv install 即可完成所有依赖的安装。
当然，也可以通过生成 requirements.</description>
    </item>
    
    <item>
      <title>开发中遇到的命名规范问题</title>
      <link>akynazh.site/posts/2022/12/naming-standard-problems-encountered-in-development/</link>
      <pubDate>Thu, 08 Dec 2022 15:40:09 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/12/naming-standard-problems-encountered-in-development/</guid>
      <description>后端中与数据库交互时 数据库一般采用下划线命名，而对于 java 而言，实体类的命名应当是驼峰式的命名，所以在与数据库交互时需要注意进行转换。
对于采用了 Mybatis-plus 框架的应用，无需考虑此问题，因为它已经帮我们做好转换了，对应的配置如下：
1mybatis-plus: 2 configuration: 3 map-underscore-to-camel-case: true 如果你数据库命名已经采用了驼峰式命名，需要将该配置置为 false。（默认为 true）
对于没采用该框架的应用，需要注意在编写的 sql 语句中进行转换。
关于后端返回的 json 数据 首先注意，json 采用驼峰命名法。
一般对于前后端分离的项目，后端都是返回 json 格式数据，比如使用 @RestController 进行自动的转换。
对于一个采用驼峰命名法命名的变量，比如 userId，转换后返回前端的 json 属性名是 userId，没有问题。
但是当变量名为 uId时，转换后则变为 uid，这就产生了问题。我还测试了其它一些变量，如下：
1# userId 2{&amp;#34;code&amp;#34;:200,&amp;#34;msg&amp;#34;:&amp;#34;ok&amp;#34;,&amp;#34;obj&amp;#34;:{&amp;#34;userId&amp;#34;:&amp;#34;hello&amp;#34;}} 3# uId 4{&amp;#34;code&amp;#34;:200,&amp;#34;msg&amp;#34;:&amp;#34;ok&amp;#34;,&amp;#34;obj&amp;#34;:{&amp;#34;uid&amp;#34;:&amp;#34;hello&amp;#34;}} 5# Id 6{&amp;#34;code&amp;#34;:200,&amp;#34;msg&amp;#34;:&amp;#34;ok&amp;#34;,&amp;#34;obj&amp;#34;:{&amp;#34;id&amp;#34;:&amp;#34;hello&amp;#34;}} 7# uuId 8{&amp;#34;code&amp;#34;:200,&amp;#34;msg&amp;#34;:&amp;#34;ok&amp;#34;,&amp;#34;obj&amp;#34;:{&amp;#34;uuId&amp;#34;:&amp;#34;hello&amp;#34;}} 可见当为 uId 和 Id 时，都会出现问题。
一般可以考虑在后端变量命名时，不让第二个字符大写，或者采用 @JsonProperty(&amp;quot;uId&amp;quot;) 进行解决。
关于前端的命名问题 css 采用串式命名法（kebab-case）。
在串式命名法中，各个单词之间通过下划线“-”连接，比如：
1hello-world 2first-project js 采用驼峰命名法。
关于 url 变量的命名问题 注意域名是不区分大小写的：
hTTps://aKYnazh.site 和 https://akynazh.</description>
    </item>
    
    <item>
      <title>8086 汇编学习记录</title>
      <link>akynazh.site/posts/2022/10/8086-assembly-learning-record/</link>
      <pubDate>Tue, 04 Oct 2022 23:18:24 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/10/8086-assembly-learning-record/</guid>
      <description>8086 PC 机内存地址空间分配 00000~9FFFF: 主存储器地址空间（RAM） A0000~BFFFF: 显存地址空间 C0000~FFFFF: 各类ROM地址空间 段寄存器 8086CPU不支持将数据直接送入段寄存器的操作，ds 是一个段寄存器，所以mov ds，1000H这条指令是非法的。
要将1000H送入ds，只好用一个寄存器来进行中转，即先将1000H送入一个一般的寄存器，如bx，再将bx中的内容送入ds。
为什么8086CPU不支持将数据直接送入段寄存器的操作?
这属于8086CPU硬件设计的问题。
关于 SS，SP 8086CPU中，有两个寄存器，段寄存器 SS 和寄存器 SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。
任意时刻，SS∶SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。
伪指令 在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。
汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。
而伪指令没有对应的机器指令，最终不被 CPU 所执行。那么谁来执行伪指令呢?
伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。
汇编程序 在汇编源程序中，数据不能以字母开头，所以要在前面加0。比如，9138h在汇编源程序中可以直接写为“9138h”，而A000h在汇编源程序中要写为“0A000h”。
对于mov al,[0]，是将常量0送入al中，等同于mov al,0； 对于mov al,ds:[0]，含义是(al)=((ds)*16+0)； 对于mov al,[bx]，含义是(al)=((ds)*16+(bx))； 对于mov al,ds:[bx]，含义等同于上者。 Debug R命令：查看、改变 CPU 寄存器的内容； D命令：查看内存中的内容； E命令：改写内存中的内容； U命令：将内存中的机器指令翻译成汇编指令； T命令：执行一条机器指令； A命令：以汇编指令的格式在内存中写入一条机器指令； P命令：可用于快速结束一段LOOP，遇到loop时使用； G命令：可以让指令直接执行到某个地址处，如-g 0016执行到0016处代码。 实模式和保护模式 实模式是Intel 80286和之后的x86兼容CPU的操作模式。
实模式的特性是一个20位元的区段存储器地址空间（意思为只有1MB的存储器可以被寻址），软件可以直接访问BIOS例程以及周边硬件，没有任何硬件等级的存储器保护观念或多任务。
保护模式是一种80286系列和之后的x86兼容CPU的运行模式。
保护模式有一些新的特性，如存储器保护，标签页系统以及硬件支持的虚拟内存，能够增强多任务处理和系统稳定度。
现今大部分的x86操作系统都在保护模式下运行，包含Linux、FreeBSD、以及微软Windows 2.0和之后版本。
在纯 DOS 方式（实模式）下，可以不理会 DOS，直接用汇编语言去操作真实的硬件。
因为运行在 CPU 实模式下的 DOS，没有能力对硬件系统进行全面、严格的管理。
但在Windows 2000、Unix 这些运行于CPU保护模式下的操作系统中，不理会操作系统，用汇编语言去操作真实的硬件，是根本不可能的。硬件已被这些操作系统利用 CPU 保护模式所提供的功能全面而严格地管理了。</description>
    </item>
    
    <item>
      <title>《1Q84 Book1》文摘</title>
      <link>akynazh.site/posts/2022/09/1q84book1-excerpt/</link>
      <pubDate>Thu, 01 Sep 2022 14:15:44 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/09/1q84book1-excerpt/</guid>
      <description>作者：村上春树
第9章 青豆 风景变了，规则变了 1Q84年——我就这么来称呼这个新世界吧。青豆决定。
Q是question mark的Q。背负着疑问的东两。
她边走边独自点头。
不管喜欢还是不喜欢，目前我已经置身于这“1Q84年”。我熟悉的那个1984年已经无影无踪，今年是1Q84年。空气变了，风景变了。我必须尽快适应这个带着问号的世界。像被放进陌生森林中的动物一样，为了生存下去，得尽快了解并顺应这里的规则。
第16章 天吾 能让你喜欢，我很高兴 《十二平均律钢琴曲集》对学数学的人来说，简直是天国的音乐。均衡地使用全部的十二音阶，以大调和小调分别创作前奏曲和赋格曲。总共二十四支乐曲。第一部和第二部合计四十八支曲子。形成一个完美的圆。
第16章 天吾 能让你喜欢，我很高兴 回到家里，睡觉，做了个梦。许久没有的印象鲜明的梦境。梦中，自己变成了巨大拼图中的一个小块。不是固定在一处的小块，而是一个时时刻刻都在变幻形状的小块，因此任何位置都不能容纳他。这也是当然。另外，在寻找自身位置的同时，他还必须在规定时间内把定音鼓的分谱捡拾起来。这些乐谱被狂风吹散，七零八落，他必须一页页地拾起，确认页码，按照顺序整理成册。做这些事时，他自己还像阿米巴原虫一样不断地变幻形状。事态变得无法收拾。
后来深绘里不知从哪儿赶来，握住他的左手。于是天吾停止了变形，风也骤然停下，乐谱不再飘散。这下好啦。天吾心想。但同时，规定时间也将结束。“到此结束。”深绘里小声宣告。依旧只有一个句子。时间戛然而止，世界在此终结。地球缓缓地停止转动，所有的声音和光芒都消失殆尽。
翌日睁开眼时，世界安然无恙，还在继续。并且事物已经向前运转起来。就像印度神话中把前方所有生物统统碾杀的转轮一般。
第22章 天吾 时间能以扭曲的形态前进 时间能以扭曲的形态前进，这一点天吾知道。时间自身固然是成分均一的东西，然而它一旦被消耗，就会变得形态扭曲。有的时间非常重而长，有的时间则轻而短。前后秩序有时还会颠来倒去，严重时甚至消失得无影无踪。而本来不应存在的东西又会被添加进来。人类大概就是这样随意地对时间进行调整，从而调整自己的存在意义。换个说法，就是通过这样的操作，人类才能保持神经正常。假如对自己经历过的时间，一定得严守顺序、依照原样均等地接受，只怕人类的神经注定忍受不了。那样的人生恐怕等于拷问。天吾浮想联翩。
天吾一如往日，每周三天去补习学校讲课，其余的日子便继续伏案写作长篇小说，星期五和前来幽会的女朋友进行浓郁的午后做爱。但不论他做什么，都无法做到集中注意力。仿佛一个错把厚重云团的碎片吞进肚子里的人，郁塞滞重、心绪不宁地度日，食欲也慢慢减退。在半夜莫名其妙的时刻醒来，便再也无法入睡。在这样的不眠之夜思念着深绘里。她此刻在哪里？在做什么？和谁在一起？遭遇了什么？他在脑海中想象着种种状况，每一种尽管多少有差异，却都是带着悲观色彩的想象。而且在他的想象中，她总是身穿紧身夏季薄毛衣，胸脯呈现出美丽的形状。这个形象让天吾透不过气来，在他心中制造出更为剧烈的躁动。
From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>akynazh.site/posts/2022/08/policy-mode/</link>
      <pubDate>Fri, 26 Aug 2022 16:04:19 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/08/policy-mode/</guid>
      <description>定义 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
比如对于鸭子而言，不同鸭子的叫声方式可能不一样也可能一样，我们可以定义一个叫声行为接口，然后通过创建不同的叫声行为实现这个接口，在实例化鸭子时设定叫声行为即可。
这样相比于直接继承抽象鸭子后重写叫声行为方法，好处是减少了重复代码，而坏处是增加了类的数量。
代码展示 下面就以鸭子为例进行说明。
从接口开始 定义一个叫声接口：（其它接口省略）
1public interface QuackBehavior { 2	public void quack(); 3} 实现叫声接口 1public class MuteQuack implements QuackBehavior { 2	public void quack() { 3	System.out.println(&amp;#34;&amp;lt;&amp;lt; Silence &amp;gt;&amp;gt;&amp;#34;); 4	} 5} 其它接口省略。
创建抽象鸭子 每只鸭子都有Fly和Quack这两种行为。
1public abstract class Duck { 2	FlyBehavior flyBehavior; 3	QuackBehavior quackBehavior; 4 5	public Duck() { 6	} 7 8	public void setFlyBehavior(FlyBehavior fb) { 9	flyBehavior = fb; 10	} 11 12	public void setQuackBehavior(QuackBehavior qb) { 13	quackBehavior = qb; 14	} 15 16	abstract void display(); 17 18	public void performFly() { 19	flyBehavior.</description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>akynazh.site/posts/2022/08/proxy-pattern/</link>
      <pubDate>Fri, 26 Aug 2022 10:41:19 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/08/proxy-pattern/</guid>
      <description>定义 代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。
我们对一个对象的使用或者一个对象中方法的调用，可以通过这个对象的代理人进行访问，这个代理人可以方便地控制这个对象，让对象的功能更为强大或更易于使用。
常见的代理有：远程代理，虚拟代理，动态代理。
远程代理 对于远程代理，其实就是本地调用远程的方法，本地堆（客户端）有一个Stub代理对象，这个对象负责完成RMI操作，也就是远程方法调用，而远程堆（服务端）有一个Skeleton代理对象，它接收客户端的RMI操作，并传递给真正的服务对象进行服务，之后再返回给客户端结果。
使用过程中需要注意调用的对象必须是可序列化的，无需序列化的对象可以添加transient关键字。通过rmiregistry &amp;amp;开启RMI，之后进行服务注册。服务端通过Naming.rebind()绑定服务地址，客户端通过Naming.lookup()调用远程方法。另外，远程传输对象需要继承于UnicastRemoteObject。
在Java5中，RMI和动态代理搭配使用，动态代理动态产生Stub，远程对象的Stub是Proxy实例，它是自动产生的，来处理所有把客户的本地调用变成远程调用的细节。
虚拟代理 对于虚拟代理，也就是说这个代理对象是虚拟的，由代理来扮演对象的替身。
比如对于从网络加载一副图像展现给用户，我们可能需要等待一定时间，这段时间内图像应该展现为用户友好的“等待中”字样，而在网络图像获取成功后进行网络图像的展现。
这个过程可以通过代理的方式方便地完成：虚拟代理对象扮演图像的替身，它通过创建一个线程加载网络图像，加载期间将图像动态地变为用户友好字样，完成加载后改为网络图像。
可以发现我们不是直接使用图像本身，而使用了代理对象作为图像，也就是说，代理扮演了图像这个角色。
下面是一个图像代理对象：
1class ImageProxy implements Icon { 2	volatile ImageIcon imageIcon; 3	final URL imageURL; 4	Thread retrievalThread; 5	boolean retrieving = false; 6 7	public ImageProxy(URL url) { imageURL = url; } 8 9	public int getIconWidth() { 10 ... 11	} 12 13	public int getIconHeight() { 14 ... 15	} 16	17	synchronized void setImageIcon(ImageIcon imageIcon) { 18	this.</description>
    </item>
    
    <item>
      <title>状态模式</title>
      <link>akynazh.site/posts/2022/08/status-mode/</link>
      <pubDate>Thu, 25 Aug 2022 22:54:26 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/08/status-mode/</guid>
      <description>定义 状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
比如某个机器有各种复杂的状态，每个状态都着共同的参数，而这些参数值有区别。用户通过某些操作会改变机器的状态，机器转变状态后，以当前状态的方法给用户反馈。
代码展示 以机器的例子说明。
从接口开始 编写状态接口：
1public interface State { 2 3	public void insertQuarter(); 4	public void ejectQuarter(); 5	public void turnCrank(); 6	public void dispense(); 7	8	public void refill(); 9} 创建机器类 1package headfirst.designpatterns.state.gumballstate; 2 3public class GumballMachine { 4 // 各种机器状态 5	State soldOutState; 6	State noQuarterState; 7	State hasQuarterState; 8	State soldState; 9 // 当前状态 10	State state; 11	int count = 0; 12 13	public GumballMachine(int numberGumballs) { 14	soldOutState = new SoldOutState(this); 15	noQuarterState = new NoQuarterState(this); 16	hasQuarterState = new HasQuarterState(this); 17	soldState = new SoldState(this); 18 19	this.</description>
    </item>
    
    <item>
      <title>组合模式</title>
      <link>akynazh.site/posts/2022/08/combination-mode/</link>
      <pubDate>Thu, 25 Aug 2022 21:58:13 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/08/combination-mode/</guid>
      <description>定义 组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。
对于菜单内容而言，假如只有简单的菜品项，那么通过迭代器可以轻松地遍历，但是如果菜单内容中含有子菜单，那么就需要组合模式了。
代码展示 下面就以菜单为例子展示组合模式。
从抽象开始 创建菜单组件：
1public abstract class MenuComponent { 2 3	public void add(MenuComponent menuComponent) { 4	throw new UnsupportedOperationException(); 5	} 6	public void remove(MenuComponent menuComponent) { 7	throw new UnsupportedOperationException(); 8	} 9	public MenuComponent getChild(int i) { 10	throw new UnsupportedOperationException(); 11	} 12 13	public String getName() { 14	throw new UnsupportedOperationException(); 15	} 16	public String getDescription() { 17	throw new UnsupportedOperationException(); 18	} 19	public double getPrice() { 20	throw new UnsupportedOperationException(); 21	} 22	public boolean isVegetarian() { 23	throw new UnsupportedOperationException(); 24	} 25 26	public void print() { 27	throw new UnsupportedOperationException(); 28	} 29} 创建菜单 菜单本身是一个菜单组件，菜单继承于菜单组件，实现父类方法。</description>
    </item>
    
    <item>
      <title>迭代器模式</title>
      <link>akynazh.site/posts/2022/08/iterators-mode/</link>
      <pubDate>Thu, 25 Aug 2022 11:26:17 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/08/iterators-mode/</guid>
      <description>定义 迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。
通过一个Iterator，可以方便地遍历各种类型，如HashMap，ArrayList等。
代码展示 下面通过菜单的例子进行说明。
分别用简单数组String[]和ArrayList&amp;lt;String&amp;gt;类创建菜单内容。
从接口开始 创建菜单接口：
1public interface Menu { 2	public Iterator&amp;lt;String&amp;gt; createIterator(); 3} 每个菜单都可以返回一个迭代器。
创建Diner菜单 该菜单用String[]创建内容，需要编写自己的迭代器。
1public class DinerMenu implements Menu { 2	static final int MAX_ITEMS = 6; 3	int numberOfItems = 0; 4	String[] menuItems; 5 6	public DinerMenu() { 7	menuItems = new String[MAX_ITEMS]; 8 9	addItem(&amp;#34;Vegetarian BLT&amp;#34;); 10	addItem(&amp;#34;BLT&amp;#34;); 11	addItem(&amp;#34;Soup of the day&amp;#34;); 12	addItem(&amp;#34;Hotdog&amp;#34;); 13	addItem(&amp;#34;Steamed Veggies and Brown Rice&amp;#34;); 14	addItem(&amp;#34;Pasta&amp;#34;); 15	} 16 17	public void addItem(String name) 18	{ 19	if (numberOfItems &amp;gt;= MAX_ITEMS) { 20	System.</description>
    </item>
    
    <item>
      <title>模板方法模式</title>
      <link>akynazh.site/posts/2022/08/template-method-mode/</link>
      <pubDate>Wed, 24 Aug 2022 17:14:16 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/08/template-method-mode/</guid>
      <description>定义 模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
“好莱坞”原则 别调用我们，我们会调用你。
其实就是防止“依赖腐败”，也就是要避免高层组件和低层组件相互依赖。一般由高层组件依赖低层组件。
代码展示 泡茶和泡咖啡有着几乎相同的步骤，但在某些子步骤中有差别。通过模板方法可以很好地解决问题。
定义模板方法 子步骤brew()和addCondiments()为抽象方法，由子类具体实现。
1public abstract class CaffeineBeverage { 2 3	final void prepareRecipe() { 4	boilWater(); 5	brew(); 6	pourInCup(); 7	addCondiments(); 8	} 9 10	abstract void brew(); 11 12	abstract void addCondiments(); 13 14	void boilWater() { 15	System.out.println(&amp;#34;Boiling water&amp;#34;); 16	} 17 18	void pourInCup() { 19	System.out.println(&amp;#34;Pouring into cup&amp;#34;); 20	} 21} 定义具体方法 继承CaffeineBeverage并实现抽象方法。
1public class Coffee extends CaffeineBeverage { 2	public void brew() { 3	System.</description>
    </item>
    
    <item>
      <title>外观模式</title>
      <link>akynazh.site/posts/2022/08/appearance-mode/</link>
      <pubDate>Tue, 23 Aug 2022 16:20:06 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/08/appearance-mode/</guid>
      <description>外观模式 定义 外观模式提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。
“最少知识”原则 减少对象之间的交互，只和“密友”谈话，也就是减少一个类所交互的类的数量。
代码展示 执行一些复杂操作需要一步步执行许多小操作，那么可以将复杂操作封装为一个高层类中的方法，将所有复杂操作需要用到的类作为高层类的成员，在复杂操作的方法中可以方便的调用各个类执行各自的功能。
下面是一个家庭影院的例子：
1public class HomeTheaterFacade { 2	Amplifier amp; 3	Tuner tuner; 4	StreamingPlayer player; 5	CdPlayer cd; 6	Projector projector; 7	TheaterLights lights; 8	Screen screen; 9	PopcornPopper popper; 10 11	public HomeTheaterFacade(Amplifier amp, 12	Tuner tuner, 13	StreamingPlayer player, 14	Projector projector, 15	Screen screen, 16	TheaterLights lights, 17	PopcornPopper popper) { 18 19	this.amp = amp; 20	this.tuner = tuner; 21	this.</description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>akynazh.site/posts/2022/08/adapter-mode/</link>
      <pubDate>Tue, 23 Aug 2022 16:00:04 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/08/adapter-mode/</guid>
      <description>适配器模式 定义 适配器模式将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。
代码展示 鸭子和火鸡叫声不一样，通过编写适配器让火鸡适配鸭的方法。
从接口开始 1public interface Duck { 2	public void quack(); 3	public void fly(); 4} 1public interface Turkey { 2	public void gobble(); 3	public void fly(); 4} 编写适配器 1public class TurkeyAdapter implements Duck { 2	Turkey turkey; 3 4	public TurkeyAdapter(Turkey turkey) { 5	this.turkey = turkey; 6	} 7 8	public void quack() { 9	turkey.gobble(); 10	} 11 12	public void fly() { 13	for(int i=0; i &amp;lt; 5; i++) { 14	turkey.</description>
    </item>
    
    <item>
      <title>命令模式</title>
      <link>akynazh.site/posts/2022/08/command-mode/</link>
      <pubDate>Mon, 22 Aug 2022 11:41:33 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/08/command-mode/</guid>
      <description>定义 命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。
比如对于遥控器而已，我们会将操作封装为一个按钮（命令）对象，通过按下按钮执行操作。
代码展示 下面以遥控器作为例子：
从接口开始 命令接口：
1public interface Command { 2	public void execute(); 3} 定义操控对象 一个风扇对象：（其它对象省略了）
1public class Light { 2	String location = &amp;#34;&amp;#34;; 3 4	public Light(String location) { 5	this.location = location; 6	} 7 8	public void on() { 9	System.out.println(location + &amp;#34; light is on&amp;#34;); 10	} 11 12	public void off() { 13	System.out.println(location + &amp;#34; light is off&amp;#34;); 14	} 15} 定义操控对象的命令 操作风扇的命令：</description>
    </item>
    
    <item>
      <title>单件模式</title>
      <link>akynazh.site/posts/2022/08/singleton-pattern/</link>
      <pubDate>Mon, 22 Aug 2022 11:14:23 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/08/singleton-pattern/</guid>
      <description>我的思考 单件模式，容易知道需要某个对象是独一无二的，那么它首先应该是静态的，不能在程序动态运行期间被再次创建。
当在多个线程中用到它时，在创建时需要考虑线程安全问题，可通过加锁等方式解决。
代码实现 传统的单件 定义一个私有实例化的对象，把单件对象作为一个私有的静态成员变量，通过静态方法Singleton.getInstance()获取，若获取为null则创建对象。
1public class Singleton { 2	private static Singleton uniqueInstance; 3 4	private Singleton() {} 5 6	public static Singleton getInstance() { 7	if (uniqueInstance == null) { 8	uniqueInstance = new Singleton(); 9	} 10	return uniqueInstance; 11	} 12} 线程安全的单件 传统的单件线程不安全，解决如下：
1public class Singleton { 2	private static Singleton uniqueInstance; 3 4	private Singleton() {} 5 6	public static synchronized Singleton getInstance() { 7	if (uniqueInstance == null) { 8	uniqueInstance = new Singleton(); 9	} 10	return uniqueInstance; 11	} 12} 改善多线程性能 如上线程安全的代码，getInstance()在多次调用的情况下性能太低，改善方法如下：</description>
    </item>
    
    <item>
      <title>工厂模式</title>
      <link>akynazh.site/posts/2022/08/factory-mode/</link>
      <pubDate>Sun, 21 Aug 2022 23:31:45 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/08/factory-mode/</guid>
      <description>我的思考 工厂模式，包括工厂方法模式和抽象工厂模式。
对于工厂方法模式，工厂是一个抽象类，提供了一些默认实现方法和一些抽象方法，具体工厂继承于它，实现对应抽象方法。
假设有多家比萨店，他们提供不同口味的比萨，而都有相同的订购比萨的方法，那么可以定义一个抽象类，提供订购比萨的具体方法和创建比萨的抽象方法。
对于抽象工厂模式，工厂是一个接口，提供了一些具体工厂会用到的方法，同时还需要定义这些方法可能用到的接口。具体工厂需要首先实现抽象工厂定义的方法可能用到的接口，然后实现抽象工厂的所有方法。
假设有多家生产比萨配料的工厂，他们都有自己的独特的配料（实现所有配料接口），那么可以定义一个抽象工厂（一个接口），提供所有配料创建方法，具体工厂各自实现所有创建方法即可。
总之，他们的具体区别如下：
工厂方法模式使用继承，把对象的创建委托给子类，子类实现工厂方法来创建对象。 抽象工厂模式使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中。 工厂方法模式代码 从抽象开始 比萨店抽象类：
1public abstract class PizzaStore { 2 3	abstract Pizza createPizza(String item); 4 5	public Pizza orderPizza(String type) { 6	Pizza pizza = createPizza(type); 7	System.out.println(&amp;#34;--- Making a &amp;#34; + pizza.getName() + &amp;#34; ---&amp;#34;); 8	pizza.prepare(); 9	pizza.bake(); 10	pizza.cut(); 11	pizza.box(); 12	return pizza; 13	} 14} 具体的比萨店 芝加哥的比萨店：
1public class ChicagoPizzaStore extends PizzaStore { 2 3	Pizza createPizza(String item) { 4 if (item.</description>
    </item>
    
    <item>
      <title>装饰者模式</title>
      <link>akynazh.site/posts/2022/08/decorator-mode/</link>
      <pubDate>Sun, 21 Aug 2022 23:17:27 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/08/decorator-mode/</guid>
      <description>我的思考 装饰，如其名，就是对一个对象进行加工，包装，修饰。
假设一杯“普通的咖啡，价格10”，我们可以选择添加自己喜欢的配料。
首先我们添加牛奶，那么就变成了一杯“含牛奶配料的咖啡，价格2 +（价格12）”；
我想再加点巧克力，那么再往上包装变成“含巧克力的含牛奶配料的咖啡，价格3 +【价格2+（价格12）】”。
这么一层层封装上去就是装饰模式。
我们要在每一个配料中定义一个可包装的对象，在包装后返回这个对象。具体代码如下文。
代码实现 定义抽象类 饮料抽象类：
1public abstract class Beverage { 2	String description = &amp;#34;Unknown Beverage&amp;#34;; 3 4	public String getDescription() { 5	return description; 6	} 7 8	public abstract double cost(); 9} 配料抽象类：
注意这里配料也继承了饮料类，这样Beverage在通过包装之后还是返回一个Beverage，具体见测试代码。
1public abstract class CondimentDecorator extends Beverage { 2	Beverage beverage; 3	public abstract String getDescription(); 4} 定义具体类 牛奶配料：（其他配料省略）
1public class Milk extends CondimentDecorator { 2	public Milk(Beverage beverage) { 3	this.</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>akynazh.site/posts/2022/08/observer-mode/</link>
      <pubDate>Sun, 21 Aug 2022 22:59:33 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/08/observer-mode/</guid>
      <description>我的思考 对于观察者模式，既然有观察者，那么就首先有被观察者。
观察者可以通过订阅，监听等方式实现“观察”，被观察者需要通过通知，发消息之类的方式通知观察者接收信息。
假设有一个气象观测站，天气数据对象作为被观察者，各个气象观测站作为观察者订阅天气数据，而天气数据记录各个订阅了自己的观测站，以便于通知。具体代码实现如下文。
代码实现 定义接口 被观察者：
1public interface Subject { 2	public void registerObserver(Observer o); 3	public void removeObserver(Observer o); 4	public void notifyObservers(); 5} 观察者：
1public interface Observer { 2	public void update(float temp, float humidity, float pressure); 3} 定义对象实现接口 天气数据对象：
1public class WeatherData implements Subject { 2	private List&amp;lt;Observer&amp;gt; observers; 3	private float temperature; 4	private float humidity; 5	private float pressure; 6	7	public WeatherData() { 8	observers = new ArrayList&amp;lt;Observer&amp;gt;(); 9	} 10	11	public void registerObserver(Observer o) { 12	observers.</description>
    </item>
    
    <item>
      <title>Batch 基本编写方法记录</title>
      <link>akynazh.site/posts/2022/08/batch-basic-compilation-method-record/</link>
      <pubDate>Wed, 03 Aug 2022 23:34:36 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/08/batch-basic-compilation-method-record/</guid>
      <description>读取输入 1set /p ch=&amp;#34;y/n:&amp;#34; 2echo %ch% 变量运算 通过%{var}%访问变量，通过/a进行表达式计算设置值。
1@echo off 2 3set money=100 4echo 初始金额： %money% 5 6set /a money=%money%*2 7set /a money=%money%+100 8echo 现在的金额：%money% 选择并跳转 :{point} 用于指定一个跳转点。
1@echo off 2 3set /p ch=&amp;#34;y/n:&amp;#34; 4if &amp;#34;%ch%&amp;#34;==&amp;#34;&amp;#34; ( 5 goto end 6) else if &amp;#34;%ch%&amp;#34;==&amp;#34;n&amp;#34; ( 7 goto no 8) else if &amp;#34;%ch%&amp;#34;==&amp;#34;y&amp;#34; ( 9 goto yes 10) else ( 11 goto end 12) 13 14:no 15echo NO 16goto end 17 18:yes 19echo YES 20goto end 21 22:end 循环语句 通过%%x设置和访问循环值； 通过(start, steps, end)设置循环； /l 将通过比较start和end来执行迭代。 1@echo off 2 3for /l %%x in (1, 5, 100) do ( 4 echo hello, jzh-%%x 5) 变量动态变化 setlocal enabledelayedexpansion开启变量延迟，使得变量可以动态变化; 需通过!</description>
    </item>
    
    <item>
      <title>Window 添加命令别名的方法</title>
      <link>akynazh.site/posts/2022/06/how-to-add-command-alias-in-window/</link>
      <pubDate>Fri, 24 Jun 2022 22:52:59 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/06/how-to-add-command-alias-in-window/</guid>
      <description>前言 下面将介绍3种方法：
CMD添加别名的方法 PowerShell添加别名的方法 通过添加环境变量的方式设置别名 CMD添加别名的方法 设置临时的别名 可以通过doskey命令实现。
1doskey ls=echo ====== ^&amp;amp;^&amp;amp; dir /b $* ^&amp;amp;^&amp;amp; echo ====== $*表示还可能有其他命令参数，^&amp;amp;^&amp;amp;用于分开多条命令。
单纯在一个cmd窗口中使用doskey设置别名，别名只能在该窗口中使用。
设置永久的别名 可以通过将doskey命令写入bat脚本，再把脚本路径添加到注册表Autorun实现永久且所有cmd都可用的别名，具体步骤如下：
编写脚本： 1@echo off 2doskey ls=dir /b $* 3doskey lss=echo ====== ^&amp;amp;^&amp;amp; dir /b $* ^&amp;amp;^&amp;amp; echo ====== 添加路径到注册表 在HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor下的Autorun中，将数值设为doskey命令脚本所在的路径即可。这样所有用户都可以使用设置好的别名。
也可在HKEY_CURRENT_USER下的对应位置设置，只针对当前用户设置别名。
优缺点 通过doskey的方式，挺方便的，但是在命令非常多的情况下不是很方便，同时，设置的命令还不可以在powershell下运行。
PowerShell添加别名的方法 为PowerShell设置临时的别名 1PS C:\Users\akyna&amp;gt; set-alias escc esc 2PS C:\Users\akyna&amp;gt; escc 3...... 如果带参数，则可以通过function进行：
1PS C:\Users\akyna&amp;gt; function func{nircmd emptybin} 2PS C:\Users\akyna&amp;gt; set-alias ctrash func 3PS C:\Users\akyna&amp;gt; ctrash 这样的别名只是在当前会话下有效，开启另一个shell就失效了。</description>
    </item>
    
    <item>
      <title>Quartz 实现定时任务</title>
      <link>akynazh.site/posts/2022/06/quartz-implements-timed-tasks/</link>
      <pubDate>Wed, 15 Jun 2022 21:11:27 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/06/quartz-implements-timed-tasks/</guid>
      <description>一、添加注解 主启动类添加@EnableScheduling注解；
二、添加依赖： 1&amp;lt;!--定时任务 --&amp;gt; 2&amp;lt;dependency&amp;gt; 3 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 4 &amp;lt;artifactId&amp;gt;spring-boot-starter-quartz&amp;lt;/artifactId&amp;gt; 5&amp;lt;/dependency&amp;gt; 三、创建任务 /TestTask1.java
1public class TestTask1 extends QuartzJobBean { 2 @Override 3 protected void executeInternal(JobExecutionContext context) { 4 SimpleDateFormat sdf = new SimpleDateFormat(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;); 5 System.out.println(&amp;#34;Test1---&amp;#34; + sdf.format(new Date())); 6 } 7} /TestTask2.java
1public class TestTask2 extends QuartzJobBean { 2 @Override 3 protected void executeInternal(JobExecutionContext context) { 4 SimpleDateFormat sdf = new SimpleDateFormat(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;); 5 System.out.println(&amp;#34;Test2---&amp;#34; + sdf.format(new Date())); 6 } 7} 四、配置任务 /QuartzConfig.</description>
    </item>
    
    <item>
      <title>Java 复习记录（一）</title>
      <link>akynazh.site/posts/2022/05/java-review-1/</link>
      <pubDate>Sun, 15 May 2022 15:15:51 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/05/java-review-1/</guid>
      <description>JDK JRE JVM 关系 为什么说 Java 语言“编译与解释并存”？ 高级编程语言按照程序的执行方式分为编译型和解释型两种。
编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码，不能跨平台。
解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行，一次编写，到处执行。
Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤。
由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须再经过 JVM，解释成操作系统能识别的机器码，在由操作系统执行。
因此，我们可以认为 Java 语言编译与解释并存。
重载（overload）和重写（override）的区别？ 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。
重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；
重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。
方法重载的规则：
方法名一致，参数列表中参数的顺序，类型，个数不同。 重载与方法的返回值无关，存在于父类和子类，同类中。 可以抛出不同的异常，可以有不同修饰符。 抽象类(abstract class)和接口(interface)有什么区别？ 接口的方法默认是public，所有方法在接口中不能有实现(Java8开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
接口中除了static、final变量，不能有其他变量，而抽象类中则不⼀定。
⼀个类可以实现多个接口，但只能实现⼀个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰）。
从设计层面来说，抽象是对类的抽象，是⼀种模板设计，而接口是对行为的抽象，是⼀种行为的规范。
注意jdk7~jdk9中接口的变化：
在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。 jdk 8 的时候接口可以有默认方法和静态方法功能。 jdk 9 在接口中引⼊了私有方法和私有静态方法 try和finally中的return 若try中有return，而finally中无return，会先将值暂存，无论finally语句中对该值做什么处理，最终返回的都是try语句中的暂存值。另外，finally语句中执行的语句先于try的return之前执行。
当try与finally语句中均有return语句，会忽略try中return，执行finally的return。注意如果try的return语句是return ++x，则++x是会执行的。
验证如下：
1public class TryReturnTest { 2 public int test1(int x) { 3 try { 4 x += 1; 5 return ++x; 6 } catch (Exception e) { 7 e.</description>
    </item>
    
    <item>
      <title>Window 实用命令记录之进程与网络控制</title>
      <link>akynazh.site/posts/2022/04/process-and-network-control-of-window-practical-command-recording/</link>
      <pubDate>Mon, 18 Apr 2022 23:10:39 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/04/process-and-network-control-of-window-practical-command-recording/</guid>
      <description>进程相关 tasklist tasklist用于查看运行的进程 findstr相当于linux的grep 1PS C:\Users\akyna&amp;gt; Tasklist | findstr Code 2Code.exe 19184 Console 1 94,012 K 3Code.exe 19300 Console 1 26,324 K 4...... taskkill 使用该工具按照进程 ID (PID) 或映像名称终止任务。
参数列表:
/PID processid 指定要终止的进程的 PID。 /IM imagename 指定要终止的进程的映像名称。 /T 终止指定的进程和由它启用的子进程。 /F 指定强制终止进程。 /? 显示帮助消息。 e.g.
1TASKKILL /IM notepad.exe 2TASKKILL /PID 1230 /PID 1241 /PID 1253 /T 3TASKKILL /F /IM cmd.exe /T 网络相关 ipconfig 执行网卡相关操作
1$ ipconfig # 查看网卡信息，如ip地址 2$ ipconfig /all # 查看mac地址 3 4$ ipconfig /displaydns # 查看dns缓存内容 5$ ipconfig /flushdns # 清除dns缓存 ping 测试本机与指定机器是否联通</description>
    </item>
    
    <item>
      <title>Java 开发中遇到的 bug 记录</title>
      <link>akynazh.site/posts/2022/01/record-of-bugs-encountered-in-java-development/</link>
      <pubDate>Thu, 06 Jan 2022 17:23:00 +0800</pubDate>
      
      <guid>akynazh.site/posts/2022/01/record-of-bugs-encountered-in-java-development/</guid>
      <description>持续更新中。
BufferedWriter 无法正确写出问题 这是一段客户端代码，向服务器端发送消息，然后接收服务器端的回复：
1try ( 2 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); 3 BufferedWriter out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())) 4) { 5 String message; 6 while((message = stdIn.readLine()) != null) { 7 out.write(message); 8 out.flush(); 9 System.out.println(&amp;#34;Receive from server: &amp;#34; + in.readLine()); 10 } 11} catch (Exception e) { 12 System.out.println(e.getMessage()); 13} 这是服务端代码的一部分，接收客户端消息，并向客户端回复：
1try ( 2 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); 3 BufferedWriter out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())) 4) { 5 String message; 6 while((message = in.</description>
    </item>
    
    <item>
      <title>关于 char*, char[], string 的理解</title>
      <link>akynazh.site/posts/2021/12/understanding-of-char-char-string/</link>
      <pubDate>Sun, 05 Dec 2021 12:37:32 +0800</pubDate>
      
      <guid>akynazh.site/posts/2021/12/understanding-of-char-char-string/</guid>
      <description>关于char[]与char*的区别 1char s1[] = &amp;#34;abc&amp;#34;; 2cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl; // abc 3s1[1] = &amp;#39;d&amp;#39;; // 改变值 4cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl; // adc &amp;ldquo;abc&amp;quot;为字符串常量，s1为指针常量，即指针是一个常量，所以指向地址不能改变，指向地址的值可变
1const char* s2 = &amp;#34;abc&amp;#34;; // const是默认存在的 2cout &amp;lt;&amp;lt; s2 &amp;lt;&amp;lt; endl; // abc 3s2 = &amp;#34;dfs&amp;#34;; // 改变地址 4cout &amp;lt;&amp;lt; s2 &amp;lt;&amp;lt; endl; // dfs &amp;ldquo;abc&amp;quot;为字符串常量，s2为常量指针，指向地址可变，但指向的地址的值不能变
以上两者皆可用于函数传值
1void print_str(const char * str) { 2 printf(&amp;#34;%s\n&amp;#34;, str); 3} 4 5print_str(s1); // adc 6print_str(s2); // dfs 关于string和char[],char*的关系 string是类，string是对一个字符串的引用值 1const char* s1 = &amp;#34;abc&amp;#34;; 2string s = s1; 3cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl; // abc 4s += &amp;#34;a&amp;#34;; 5cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl; // abca 6cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl; 7// abc 证明string只是引用了s1 string引用字符串示例 1const char *s1 = &amp;#34;123&amp;#34;; 2string str1 = s1; // 若要这样赋值s1必须加const 3cout &amp;lt;&amp;lt; str1 &amp;lt;&amp;lt; endl; // 123 4 5char s2[] = &amp;#34;234&amp;#34;; 6string str2 = s2; 7cout &amp;lt;&amp;lt; str2 &amp;lt;&amp;lt; endl; // 234 string转char* 1const char* s1_1 = str1.</description>
    </item>
    
    <item>
      <title>Java 重写 equals 方法的同时为什么要重写 hashcode 方法</title>
      <link>akynazh.site/posts/2021/11/why-should-java-rewrite-the-hashcode-method-when-rewriting-the-equals-method/</link>
      <pubDate>Fri, 26 Nov 2021 09:23:27 +0800</pubDate>
      
      <guid>akynazh.site/posts/2021/11/why-should-java-rewrite-the-hashcode-method-when-rewriting-the-equals-method/</guid>
      <description>提出问题 先看一个例子：
当两个人年龄相同时，我们认为这两个对象相同：
1class Person { 2 private int age; 3 private String name; 4 5 public Person(int age, String name) { 6 this.age = age; 7 this.name = name; 8 } 9 10 @Override 11 public String toString() { 12 return &amp;#34;Person{&amp;#34; + 13 &amp;#34;age=&amp;#34; + age + 14 &amp;#34;, name=&amp;#39;&amp;#34; + name + &amp;#39;\&amp;#39;&amp;#39; + 15 &amp;#39;}&amp;#39;; 16 } 17 18 @Override 19 public boolean equals(Object o) { 20 if (this == o) return true; 21 if (o == null || getClass() !</description>
    </item>
    
    <item>
      <title>Synchronized 到底锁了谁</title>
      <link>akynazh.site/posts/2021/05/who-the-hell-is-synchronized-locking/</link>
      <pubDate>Wed, 19 May 2021 22:43:45 +0800</pubDate>
      
      <guid>akynazh.site/posts/2021/05/who-the-hell-is-synchronized-locking/</guid>
      <description>Synchronized方法 静态方法上的锁
静态方法是属于“类”，不属于某个实例，是所有对象实例所共享的方法。也就是说如果在静态方法上加入synchronized，那么它获取的就是这个类的锁，锁住的就是这个类。
普通方法上的锁
实例方法并不是类所独有的，每个对象实例独立拥有它，它并不被对象实例所共享。在实例方法上加入synchronized，那么它获取的就是这个类的锁，锁住的就是这个对象实例。
Synchronized代码块 synchronized(this){...} this关键字所代表的意思是该对象实例，这种用法synchronized锁住的是对象实例。
synchronized(Demo.class){...} 锁的是该类。
synchronized(obj){...} synchronized同步代码块对对象内部的实例加锁。
假设demo1与demo2方法不相关，此时两个线程对同一个对象实例分别调用demo1与demo2，均能获取各自的锁。
代码如下：
1public class Demo { 2 private Object lock1 = new Object(); 3 private Object lock2 = new Object(); 4 5 public void demo1() { 6 synchronized (lock1) { 7 while (true) { //死循环目的是为了让线程一直持有该锁 8 System.out.println(Thread.currentThread()); 9 } 10 } 11 } 12 13 public void demo2() { 14 synchronized (lock2) { 15 while (true) { 16 System.</description>
    </item>
    
    <item>
      <title>Java 与 C&#43;&#43; 中的值传递和引用传递解析</title>
      <link>akynazh.site/posts/2021/05/value-passing-and-reference-passing-parsing-in-java-and-c/</link>
      <pubDate>Sat, 01 May 2021 20:16:39 +0800</pubDate>
      
      <guid>akynazh.site/posts/2021/05/value-passing-and-reference-passing-parsing-in-java-and-c/</guid>
      <description>先说结论：Java只有值传递，而C++既有值传递又有引用传递。
Java的参数传递 先定义3个方法如下：
1public static void change1(String str, int num) { 2 str = &amp;#34;world&amp;#34;; // 这里就相当与新new了一个对象! 3 num = 100; 4} 5public static void change2(User user) { 6 user.age = 1; 7 user.name = &amp;#34;mary&amp;#34;; 8} 9public static void change3(User user) { 10 user = new User(1, &amp;#34;mary&amp;#34;); 11} 进行测试：
1public static void main(String[] args) { 2 String str = &amp;#34;hello&amp;#34;; 3 int num = 1; 4 System.out.println(str + &amp;#34; &amp;#34; + num); // hello 1 5 change1(str, num); 6 System.</description>
    </item>
    
    <item>
      <title>Window 实用命令记录之文件操作</title>
      <link>akynazh.site/posts/2021/04/file-operation-recorded-by-window-utility-command/</link>
      <pubDate>Mon, 19 Apr 2021 13:48:19 +0800</pubDate>
      
      <guid>akynazh.site/posts/2021/04/file-operation-recorded-by-window-utility-command/</guid>
      <description>创建文件或文件夹 cmd下创建文件 1type nul &amp;gt; test.jpg powershell下创建文件 1new-item test.jpg 创建文件夹 1mkdir test 重命名文件 注意不能指定到新的路径。
1PS D:\a\tmp\test&amp;gt; ren test.txt my.txt 移动文件 该命令也可用于重命名。
1PS D:\a\tmp\test&amp;gt; move test.jpg mydir 复制文件和文件夹 copy无法递归复制，而xcopy可以。
1PS D:\a\tmp\test\mydir&amp;gt; copy test.jpg test1.jpg 1# mydir not empty 2PS D:\a\tmp\test&amp;gt; copy mydir mydir1 3PS D:\a\tmp\test&amp;gt; ls mydir1 4# empty 5 6PS D:\a\tmp\test&amp;gt; xcopy mydir mydir2 7目标 mydir2 是文件名 8还是目录名 9(F = 文件，D = 目录)? D 10mydir\test.jpg 11mydir\test1.jpg 12复制了 2 个文件 删除文件或文件夹 del 删除文件。powershell可以使用rm。</description>
    </item>
    
    <item>
      <title>equals 方法和 == 运算符的作用区别</title>
      <link>akynazh.site/posts/2020/11/the-difference-between-the-equals-method-and-the---operator/</link>
      <pubDate>Wed, 25 Nov 2020 00:21:05 +0800</pubDate>
      
      <guid>akynazh.site/posts/2020/11/the-difference-between-the-equals-method-and-the---operator/</guid>
      <description>equals方法与&amp;quot;==&amp;ldquo;的比较与分析 首先提出一个重要的点:
== 比较时进行地址的比较
equals 比较时进行值的比较
1String a = &amp;#34;123&amp;#34;; 2String b = &amp;#34;123&amp;#34;; 3System.out.println(a.equals(b)); // true 4System.out.println(a == b); // true 5 6String a1 = new String(&amp;#34;123&amp;#34;); 7String b1 = new String(&amp;#34;123&amp;#34;); 8System.out.println(a1.equals(b1)); // true 9System.out.println(a1 == b1); // false 好像没问题。
然而阅读源码Object类，可以发现对象中默认equals方法进行的是地址的比较
1public boolean equals(Object obj) { 2 return (this == obj); 3} 再阅读源码String类，可以发现String类中重写了equals方法，覆盖掉了Object的equals方法，所以String的equals是值比较！
1public boolean equals(Object anObject) { 2 if (this == anObject) { 3 return true; 4 } 5 if (anObject instanceof String) { 6 String aString = (String)anObject; 7 if (coder() == aString.</description>
    </item>
    
    <item>
      <title>Cmd 重要且实用的一些命令</title>
      <link>akynazh.site/posts/2020/11/cmd-some-important-and-practical-commands/</link>
      <pubDate>Fri, 20 Nov 2020 18:17:33 +0800</pubDate>
      
      <guid>akynazh.site/posts/2020/11/cmd-some-important-and-practical-commands/</guid>
      <description>写入文件 写入hello字符串（同时新建了a.txt） 1echo hello &amp;gt; a.txt 追加写入hello字符串 1echo hello &amp;gt;&amp;gt; a.txt 将a.txt内容追加写入b.txt 1type a.txt &amp;gt;&amp;gt; b.txt 新建文件 新建空文件a.txt 1type null &amp;gt; a.txt 换行（分号换行输出） 1echo hello; echo peter 关于程序编译 test.cpp: 一个含cin输入的程序
编译cpp
1g++ test.cpp -o test 以1.in作为标准输入，2.out作为标准输出执行test
1test &amp;lt; 1.in &amp;gt; 2.out test_err.cpp: 一个会导致编译错误的程序
把编译后出现的错误输入log.txt，命令行不会报错
1g++ test_err.cpp -o terr 2&amp;gt; log.txt 打开并编辑文件 cmd下没有bash下好用的vim=_=
使用记事本打开编辑 1.py
1notepad 1.py 记事本不好用呀，还是vscode香，如下~
使用vscode打开编辑1.py，首先需配置环境变量
(${vscodepath}\bin)
1code 1.py over</description>
    </item>
    
    <item>
      <title>Matlab 基本用法整理</title>
      <link>akynazh.site/posts/2020/02/basic-usage-sorting-of-matlab/</link>
      <pubDate>Thu, 06 Feb 2020 20:41:12 +0800</pubDate>
      
      <guid>akynazh.site/posts/2020/02/basic-usage-sorting-of-matlab/</guid>
      <description>基本语法方面 提取矩阵某行或某列 1A(:, [2 3]) 返回第2和第3列 获取随机数 1randi(100); % 1 到 100 之间的随机整数 初始化数组 1zeros(1, 30); % 1行30列的全0数组 控制语句 1for i = 0 : 100 2 for j = 1 : 10 3 if (...) 4 ... 5 else 6 ... 7 end 8 end 9 ... 10end 格式化输出 1fprintf(&amp;#34;若选手选择改变，则成功次数为：%d, 成功率为：%f\n&amp;#34;, count, count / SUM); 初等数学方面 求解方程组 注：solve已经改版，不可传入字符串
实例：求解二元一次方程
1syms x y; 2s = x - 6 * y == 2; 3t = 5 * x + 4 * y == 3; 4result = solve(s, t); 求平均值，中值与标准差 1A = [12 13 7 18 16 21 9 10 2 18]; 2A = sort(A); 3ave = mean(A); 4md = median(A); 5sigma = std(A); 解一阶导数方程 1syms x y; 2y = -0.</description>
    </item>
    
  </channel>
</rss>