---
title: 8086汇编学习记录
date: 2022-10-04T23:18:24+08:00
categories: [Language]
tags: [assembly, cpu]
slug: 8086-assembly-learning-record
---

## 8086PC机内存地址空间分配

- 00000~9FFFF: 主存储器地址空间（RAM）
- A0000~BFFFF: 显存地址空间
- C0000~FFFFF: 各类ROM地址空间

## 段寄存器

8086CPU不支持将数据直接送入段寄存器的操作，ds 是一个段寄存器，所以mov ds，1000H这条指令是非法的。

要将1000H送入ds，只好用一个寄存器来进行中转，即先将1000H送入一个一般的寄存器，如bx，再将bx中的内容送入ds。

为什么8086CPU不支持将数据直接送入段寄存器的操作?

这属于8086CPU硬件设计的问题。

## 关于SS，SP

8086CPU中，有两个寄存器，段寄存器 SS 和寄存器 SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。

任意时刻，SS∶SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。

## 伪指令

在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。

汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。

而伪指令**没有对应的机器指令**，最终不被 CPU 所执行。那么谁来执行伪指令呢?

伪指令是由**编译器**来执行的指令，编译器根据伪指令来进行相关的编译工作。

## 汇编程序

在汇编源程序中，数据不能以字母开头，所以要在前面加0。比如，9138h在汇编源程序中可以直接写为“9138h”，而A000h在汇编源程序中要写为“0A000h”。

- 对于`mov al,[0]`，是将常量0送入al中，等同于`mov al,0`；
- 对于`mov al,ds:[0]`，含义是`(al)=((ds)*16+0)`；
- 对于`mov al,[bx]`，含义是`(al)=((ds)*16+(bx))`；
- 对于`mov al,ds:[bx]`，含义等同于上者。

## Debug

- R命令：查看、改变CPU寄存器的内容；
- D命令：查看内存中的内容；
- E命令：改写内存中的内容；
- U命令：将内存中的机器指令翻译成汇编指令；
- T命令：执行一条机器指令；
- A命令：以汇编指令的格式在内存中写入一条机器指令；
- P命令：可用于快速结束一段LOOP，遇到loop时使用；
- G命令：可以让指令直接执行到某个地址处，如`-g 0016`执行到0016处代码。

## 实模式和保护模式

实模式是Intel 80286和之后的x86兼容CPU的操作模式。

实模式的特性是一个20位元的区段存储器地址空间（意思为只有1MB的存储器可以被寻址），软件可以直接访问BIOS例程以及周边硬件，没有任何硬件等级的存储器保护观念或多任务。

保护模式是一种80286系列和之后的x86兼容CPU的运行模式。

保护模式有一些新的特性，如存储器保护，标签页系统以及硬件支持的虚拟内存，能够增强多任务处理和系统稳定度。

现今大部分的x86操作系统都在保护模式下运行，包含Linux、FreeBSD、以及微软Windows 2.0和之后版本。



在纯 DOS 方式（实模式）下，可以不理会 DOS，直接用汇编语言去操作真实的硬件。

因为运行在 CPU 实模式下的 DOS，没有能力对硬件系统进行全面、严格的管理。

但在Windows 2000、Unix 这些运行于CPU保护模式下的操作系统中，不理会操作系统，用汇编语言去操作真实的硬件，是根本不可能的。硬件已被这些操作系统利用 CPU 保护模式所提供的功能全面而严格地管理了。

## 问题

**向内存0:200~0:23F依次传送0~63(3FH)：**

注意0:200~0:23F等同于0020:0~0020:3f，它们描述的是同一内存单元。

```
assume cs:code
code segment
    
    mov  bx,20h
    mov  ds,bx
    mov  bx,0
    mov  cx,40h
  s:mov  [bx],bx
    inc  bx
    loop s

    mov  ax,4c00h
    int  21h

code ends
end
```

将`mov ax,4c00h`之前的指令复制到内存0:200处：

CX寄存器在debug调试一个可执行程序时，初始值为该程序的字节尺寸大小，要复制`mov ax,4c00h`之前的指令，需要减去`mov ax,4c00h` 和 `int 21h` 包含的5个字节。而由于程序指令的起始地址由CS:IP指定，所以将ds赋值为cs。

```
assume cs:code
code segment
    mov ax,cs ; 程序指令的起始地址由CS:IP指定
    mov ds,ax
    mov ax,0020h
    mov es,ax
    mov bx,0
    sub cx,5 ; 减去5个字节 mov ax,4c00h 和 int 21h
  s:mov al,[bx]
    mov es:[bx],al
    inc bx
    loop s
    
    mov ax,4c00h
    int 21h
code ends
end
```

---

**参考：**

- 维基百科
- 王爽《汇编语言》

**From My Blog: [akynazh](https://akynazh.site)**.

**Over.**