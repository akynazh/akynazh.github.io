<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Norwegian Wood</title>
    <link>/</link>
    <description>Recent content on Norwegian Wood</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Jzh</copyright>
    <lastBuildDate>Fri, 13 Jan 2023 21:43:06 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Clash-Linux配置使用记录</title>
      <link>/posts/2023/01/clash-linux-configuration-usage-record/</link>
      <pubDate>Fri, 13 Jan 2023 21:43:06 +0800</pubDate>
      
      <guid>/posts/2023/01/clash-linux-configuration-usage-record/</guid>
      <description>安装 1 2 3 4 wget https://github.com/Dreamacro/clash/releases/download/v1.11.8/clash-linux-amd64-v1.11.8.gz gzip -d clash-linux-amd64-v1.11.8.gz sudo mv clash-linux-amd64-v1.11.8 /usr/bin/clash chmod +x /usr/bin/clash 获取订阅链接并配置 在自己使用的机场中获取clash订阅链接，然后下载配置文件到 ~/.config/clash/config.yaml:
1 2 3 4 5 6 7 8 9 mkdir -p ~/.config/clash cd ~/.config/clash wget -O config.yaml {link} vim config.yaml # 不允许局域网中其它电脑使用该代理，以及设置clash管理界面密码。 allow-lan: false secret: your password 运行代理并选择节点 1 2 3 4 # 第一次需要下载Country.mmdb，可考虑先运行以下命令 # clash -f ~/.config/clash/config.yaml nohup clash -f ~/.config/clash/config.yaml &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp; 登录clash管理界面进行网速的测试和节点的切换：
访问clash.razord.top，设置Host为主机IP，端口默认为9090，密钥为刚刚配置的密码。
最后设置proxy环境变量，可通过alias进行配置以方便使用。
实现开机自启动 vim /etc/systemd/system/clash.</description>
    </item>
    
    <item>
      <title>基本乐理知识记录</title>
      <link>/posts/2023/01/record-of-basic-music-theory-knowledge/</link>
      <pubDate>Fri, 06 Jan 2023 17:22:27 +0800</pubDate>
      
      <guid>/posts/2023/01/record-of-basic-music-theory-knowledge/</guid>
      <description>八度 我们可以用唱名Do[1] Re[2] Mi[3] Fa[4] Sol[5] La[6] Ti[7] Do[8]唱出歌曲的旋律，“[]”中的数字就是 音级（Degree ）。
我们以Do[1]到Do[1]为一度，Do[1]到Re[2]为二度，以此类推。于是从Do[1]到上面Do[8]之间音高上的距离(音程，Interval)就叫做 八度（Octave），因此说Do[8]比Do[1]高了一个八度。
音名和唱名 音名：用C，D，E，F，G，A，B来标记基本音级的，叫做音名，它们表示一定的音高。
唱名：与C，D，E，F，G，A，B对应的唱名用do、re、mi、fa、so、la、si来作为 音级 名称。
在吉他中，从六弦到一弦，音名依次为E，B，G，D，A，E。
半音与十二平均律 在乐音体系中，音高关系最小的计量单位叫 半音（Semitone），两个半音就是一个全音。
在C，D，E，F，G，A，B，C中，EF和BC 之间相差一个半音，其它相邻音相差一个全音。
在吉他中，相邻两个品格之间相差半音。
十二平均律（Equal temperament），或平均律, 是将八度的二倍音程等比例地划分为十二份的定律方式。它让每一个临近的音在音程上都是同样的倍数关系。这每一个音和主音Do[1]组成的音程的倍数关系分别是 $2^{n/12}$，n=0到12。
当 n=12，倍数正好是 二倍 即纯八度，它对应的音名和当 n=0 时纯一度上的音是一样的。所以去掉12，从0数到11正好产生十二个不一样的音名。
对于C大调，如果是以国际标准音 A-la-440HZ 为准，通过十二平均律可以计算出各个音的频率（单位：HZ）为：
C C#/Db D D#/Eb E F F#/Gb G G#/Ab A A#/Bb B 261.6 277.2 293.7 311.1 329.6 349.2 370.0 392.0 415.3 440.0 466.2 493.9 可以看出，根据十二平均律分出了12个音，每个音之间相差的频率大小就是一个半音的大小。
音组 不同八度的音名如果都长一样会造成误解，因此有必要用不同的标记以示区分。
音高的标记国际上通用两套体系：科学音高记号法 与 亥姆霍兹音高记号法。
科学音高记号法 我们把从C开始的一个八度设定为一个音组，音组中的音名用大写英文字母CDEFGAB和升降符号标记。每个音组都把C作为音组的第一个音，B作为音组的最后一个音。</description>
    </item>
    
    <item>
      <title>pipenv简单使用记录</title>
      <link>/posts/2023/01/simple-use-record-of-pipenv/</link>
      <pubDate>Wed, 04 Jan 2023 22:55:27 +0800</pubDate>
      
      <guid>/posts/2023/01/simple-use-record-of-pipenv/</guid>
      <description>关于pipenv pipenv集成了pip，virtualenv两者的功能，且完善了两者的一些缺陷。
安装pipenv 1 pip install pipenv -U 创建虚拟环境 初次创建环境可以使用以下类似命令：
1 pipenv install --python C:/Users/akyna/AppData/Local/Programs/Python/Python37/python.exe --pypi-mirror https://pypi.tuna.tsinghua.edu.cn/simple --python 是可选的，可以指定python版本，参数为python解释器的绝对路径，如果不指定，默认使用当前系统的python。
--pypi-mirror 是可选的，可以指定镜像，加速下载。
创建好后，在当前目录下将会生成 Pipfile 文件，在 ~\.virtualenvs 下生成虚拟环境目录（存放python解释器和依赖）。
如果目录中已经存在 Pipfile 或者 requirements.txt，pipenv会自动检测这两个文件并将对应依赖进行安装。
查看虚拟环境目录位置：
1 pipenv --venv 激活虚拟环境 1 2 3 pipenv shell # 激活虚拟环境 python -V 如果激活了虚拟环境，在当前shell下，使用的python或者pip都是虚拟环境中的python和pip。
配置Pip并安装依赖 配置镜像源为清华源：
1 2 3 4 vim Pipfile [[source]] url = &amp;#34;https://pypi.tuna.tsinghua.edu.cn/simple&amp;#34; 以后所有依赖的安装都不需要指定 --pypi-mirror 了。
安装依赖：（建议关闭代理，如果有的话）
1 2 pipenv install {pkg} # 如果激活了虚拟环境，可以使用pip # pipenv install -r requirements.</description>
    </item>
    
    <item>
      <title>从面包板的制作中得到的一些感悟</title>
      <link>/posts/2022/12/some-insights-from-making-bread-boards/</link>
      <pubDate>Fri, 16 Dec 2022 21:21:16 +0800</pubDate>
      
      <guid>/posts/2022/12/some-insights-from-making-bread-boards/</guid>
      <description>大三上半学期有个有趣的实验，要求学生设计电路并制作一个面包板。
刚听到这个实验时，我倒是不怎么在意，感觉应该就是一个普通的硬件实验，应该挺快能完成水过去。
到了实验室上手时才发现，确实还是太天真，很多事情并不是想象中那么容易的。
第一次去做时，没做好充足准备。图没画好，几个元件的作用也没怎么搞懂。当时课程和其他实验也比较多，实验室和教室来回跑，没去成几次实验室，又觉得时间应该够，没和其他同学一起去实验室通宵，结果没能顺利做完，但基本搞懂了面包板的原理，申请到下一次实验。
这一次算是可以心无旁骛地开始做面包板了，通过询问老师，理解了一些之前实验中尚不明白的点（特别是构建电源那一块，很感谢王老师的指导），然后便着手开始连线了。
这次连线一开始是非常顺利的，我先搜集好了大部分要用到的原件，然后根据电路图，一个一个模块地连接好，每连完一个模块，就对该模块进行测试，确认仿真波形无误后便开始连接下一个模块。
花了一个下午和晚上，已经完成3到4个模块的连接了，晚上8:30准时返回宿舍洗洗睡！
第二天睡了懒觉，10点左右到达实验室，开始连线。连接 74LS153 那部分时，电路图较为复杂，连完之后，波形总是不正确，重新连又要话不少时间，所以我一直debug，debug，测试各个部分的电压，反复检查各个位置的连线&amp;hellip;&amp;hellip;
不幸的是，还是没有发现问题所在，这很大一部分要归咎于我连得实在是太乱了，很难debug。中午到点了，肚子罢工了，只能去吃饭了！
下午回宿舍困觉，到了3点多精神饱满，返回实验室。我下定决心，把那个模块的连线都拆了重新开始连！
这次我吸取上次的教训，将该模块所有的连线都尽可能整洁有序地连好了，功夫不负有心人，连完后测试顺利通过了。
到了下午6点左右，所有模块基本连完，想找老师验收，可惜到饭点了，老师不在，我也吃饭去咯。
晚上找老师验收，图像看了，老师说没啥问题了。可惜老师说所有人要统一到明天验收，不能提前走。。真是令人费解的操作，遂返回宿舍摸鱼了。
第二天前往验收，竟然在画图这部分出了点问题，第一次验收没通过，把图改了改，第二次顺利通过验收。如下是我的丑陋的面包板：
实验结束了，要求拆掉板子。拆板子时，真是感慨万千，真正感受到“世上无难事，只怕有心人”这个哲理。
我觉得真要想办成什么事，首先要做完充足的准备，不要轻敌，不能自大。
要认真地去对待每一件事，不要在关键的时候还不知轻重，懒懒散散的。
不懂的地方，经过思考后仍得不出解决方法的，要虚心请教老师或同学。
要敢于去改变，就像当时debug许久无果，要敢于重新开始，不要害怕失败。
最后就是，在接近于成功的边缘时，不要以为自己已经成功了，永远要沉得住气，不到最后一刻不要掉以轻心。
2022-12-11：面包板日。
感谢自己，以及给予我许多帮助的老师。
From my blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>对于Rest风格的理解</title>
      <link>/posts/2022/12/understanding-of-rest-style/</link>
      <pubDate>Thu, 08 Dec 2022 16:35:54 +0800</pubDate>
      
      <guid>/posts/2022/12/understanding-of-rest-style/</guid>
      <description>REST，全称 Representational State Transfer，即表现层状态转移。
符合REST规范的写法：
1 2 3 4 POST http://www.test.com/lemon // 创建 Get http://www.test.com/lemon // 查询 PUT http://www.test.com/lemon // 修改 DELETE http://www.test.com/lemon //删除 不符合REST规范的写法：
1 2 3 4 POST http://www.test.com/Createlemon // 创建 POST http://www.test.com/Querylemon // 查询 POST http://www.test.com/Modifylemon // 修改 POST http://www.test.com/Deletelemon //删除 也就是用 URL 定位资源，用 HTTP 描述操作。
实际操作：
对于前端，在 js 中可以指定请求类型，以通过 ajax 发送请求为例，可以通过 type 属性进行指定，假如我要进行一条插入操作，则 type 值应为 &amp;ldquo;PUT&amp;rdquo;:
1 2 3 4 5 6 7 $.ajax({ type: &amp;#34;PUT&amp;#34;, url: &amp;#34;http://www.</description>
    </item>
    
    <item>
      <title>开发中遇到的命名规范问题</title>
      <link>/posts/2022/12/naming-standard-problems-encountered-in-development/</link>
      <pubDate>Thu, 08 Dec 2022 15:40:09 +0800</pubDate>
      
      <guid>/posts/2022/12/naming-standard-problems-encountered-in-development/</guid>
      <description>后端中与数据库交互时 数据库一般采用下划线命名，而对于 java 而言，实体类的命名应当是驼峰式的命名，所以在与数据库交互时需要注意进行转换。
对于采用了 Mybatis-plus 框架的应用，无需考虑此问题，因为它已经帮我们做好转换了，对应的配置如下：
1 2 3 mybatis-plus: configuration: map-underscore-to-camel-case: true 如果你数据库命名已经采用了驼峰式命名，需要将该配置置为 false。（默认为 true）
对于没采用该框架的应用，需要注意在编写的 sql 语句中进行转换。
关于后端返回的 json 数据 首先注意，json 采用驼峰命名法。
一般对于前后端分离的项目，后端都是返回 json 格式数据，比如使用 @RestController 进行自动的转换。
对于一个采用驼峰命名法命名的变量，比如 userId，转换后返回前端的 json 属性名是 userId，没有问题。
但是当变量名为 uId时，转换后则变为 uid，这就产生了问题。我还测试了其它一些变量，如下：
1 2 3 4 5 6 7 8 # userId {&amp;#34;code&amp;#34;:200,&amp;#34;msg&amp;#34;:&amp;#34;ok&amp;#34;,&amp;#34;obj&amp;#34;:{&amp;#34;userId&amp;#34;:&amp;#34;hello&amp;#34;}} # uId {&amp;#34;code&amp;#34;:200,&amp;#34;msg&amp;#34;:&amp;#34;ok&amp;#34;,&amp;#34;obj&amp;#34;:{&amp;#34;uid&amp;#34;:&amp;#34;hello&amp;#34;}} # Id {&amp;#34;code&amp;#34;:200,&amp;#34;msg&amp;#34;:&amp;#34;ok&amp;#34;,&amp;#34;obj&amp;#34;:{&amp;#34;id&amp;#34;:&amp;#34;hello&amp;#34;}} # uuId {&amp;#34;code&amp;#34;:200,&amp;#34;msg&amp;#34;:&amp;#34;ok&amp;#34;,&amp;#34;obj&amp;#34;:{&amp;#34;uuId&amp;#34;:&amp;#34;hello&amp;#34;}} 可见当为 uId 和 Id 时，都会出现问题。
一般可以考虑在后端变量命名时，不让第二个字符大写，或者采用 @JsonProperty(&amp;quot;uId&amp;quot;) 进行解决。
关于前端的命名问题 css 采用串式命名法（kebab-case）。
在串式命名法中，各个单词之间通过下划线“-”连接，比如：</description>
    </item>
    
    <item>
      <title>Git版本与提交管理</title>
      <link>/posts/2022/12/git-version-and-submission-management/</link>
      <pubDate>Tue, 06 Dec 2022 11:42:39 +0800</pubDate>
      
      <guid>/posts/2022/12/git-version-and-submission-management/</guid>
      <description>关于HEAD HEAD 代表当前分支的最新提交名称，它可以由一些修饰符进行修饰进而产生不同的含义。
关于 HEAD~{n}
~ 是用来在当前提交路径上回溯的修饰符。
HEAD~{n} 表示当前所在的提交路径上的前 n 个提交（n &amp;gt;= 0）：
HEAD = HEAD~0 （即当前最新的一次commit） HEAD~ = HEAD~1 HEAD~~ = HEAD~2 关于 HEAD^{n}
^ 是用来切换父级提交路径的修饰符。
当我们始终在一个分支比如 dev 开发/提交代码时，每个 commit 都只会有一个父级提交，就是上一次提交。此时 HEAD~1 等价于 HEAD^。
当并行多个分支开发，feat1, feat2, feat3，完成后 merge feat1 feat2 feat3 回 dev 分支后，此次的 merge commit 就会有多个父级提交。
HEAD^ = HEAD^1 第一个父级提交 HEAD^2~1 第二个父级提交的上一次提交 强行覆盖本地分支（不关心本地修改） 若在其它分支上进行了修改，而本地也有了一定的修改，但本地的修改是可以忽略的（或者你不小心放入了一些无关文件），那么，这时你很需要用强行覆盖这个操作。
1 2 3 git fetch git reset --hard HEAD git merge origin/$CURRENT_BRANCH # 若已做映射：git merge 修改提交过的版本 修改上次提交 这里对提交的信息和作者进行修改，注意邮箱两侧由&amp;lt;&amp;gt;包括住</description>
    </item>
    
    <item>
      <title>Linux软件安装和配置记录</title>
      <link>/posts/2022/11/linux-software-installation-and-configuration-records/</link>
      <pubDate>Sun, 13 Nov 2022 21:15:53 +0800</pubDate>
      
      <guid>/posts/2022/11/linux-software-installation-and-configuration-records/</guid>
      <description>BASE 1 2 3 4 5 6 7 8 9 apt update -y apt install curl wget vim net-tools git nginx -y # apt install openssh* -------------------------------------------- yum update -y yum install curl wget vim net-tools git nginx -y yum install openssh* yum镜像 1 2 3 4 5 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo # centos7 yum makecache yum -y update apt镜像 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 cp /etc/apt/sources.</description>
    </item>
    
    <item>
      <title>Python开发中遇到的bug记录</title>
      <link>/posts/2022/11/record-of-bugs-encountered-in-python-development/</link>
      <pubDate>Fri, 04 Nov 2022 22:53:34 +0800</pubDate>
      
      <guid>/posts/2022/11/record-of-bugs-encountered-in-python-development/</guid>
      <description>持续更新中。
pipenv无法正常install 1 2 3 4 PS C:\Users\akyna\Codes\test\test_py&amp;gt; pipenv install Usage: pipenv install [OPTIONS] [PACKAGES]... ERROR:: --system is intended to be used for pre-existing Pipfile installation, not installation of specific packages. Aborting. 解决方法：
因为pipenv检测到之前在该目录下创建过了环境，需要先删除之前的环境才可以：
1 2 PS C:\Users\akyna\Codes\test\test_py&amp;gt; pipenv --rm Removing virtualenv (C:\Users\akyna\.virtualenvs\test_py-_qApXuy4)... requests库headers字段编码错误 1 UnicodeEncodeError: &amp;#39;latin-1&amp;#39; codec can&amp;#39;t encode characters in position 30-34: ordinal not in range(256) 解决方法：
加上.encode(&amp;lsquo;utf-8&amp;rsquo;)：
1 2 3 4 5 6 7 8 return { &amp;#39;User-Agent&amp;#39;: &amp;#39;Mozilla/5.</description>
    </item>
    
    <item>
      <title>Shell基本操作总结</title>
      <link>/posts/2022/10/shell-basic-operation-summary/</link>
      <pubDate>Wed, 19 Oct 2022 22:44:10 +0800</pubDate>
      
      <guid>/posts/2022/10/shell-basic-operation-summary/</guid>
      <description>shell参数 $# 参数个数 $@ 取出所有参数 $0 取出第一个参数 1 2 3 4 5 if [ &amp;#34;$1&amp;#34; = &amp;#34;-u&amp;#34; ] then echo update fi echo $0 ans:
1 2 3 4 5 [root =&amp;gt; ~]$ ./test.sh ./test.sh [root =&amp;gt; ~]$ ./test.sh -u update ./test.sh 算术运算 1 2 3 4 [root@VM-0-11-centos ~]# a=1 [root@VM-0-11-centos ~]# b=$((a*12)) [root@VM-0-11-centos ~]# echo $b 12 比较运算 指令：-eq -ne -lt -gt -ge -le
注：字符串比较直接用“=”而不是上述指令。
1 2 3 4 5 [root@VM-0-11-centos ~]# a=10 [root@VM-0-11-centos ~]# [ $a -eq 10 ] &amp;amp;&amp;amp; echo yes yes [root@VM-0-11-centos ~]# [ $a -ge 11 ] &amp;amp;&amp;amp; echo yes || echo no no 指令：-a -o</description>
    </item>
    
    <item>
      <title>Linux文件部分总结</title>
      <link>/posts/2022/10/linux-files-section-summary/</link>
      <pubDate>Wed, 19 Oct 2022 22:43:03 +0800</pubDate>
      
      <guid>/posts/2022/10/linux-files-section-summary/</guid>
      <description>文件类型 d: directory -: file l: link p: pipeline，管道文件 b: block，块设备文件 c: character，字符设备文件 s: socket，套接字文件 配置文件 对于bashrc：
/etc/bashrc：针对所有用户，每开启一个shell都会执行一次
/etc/skel/.bashrc：针对所有用户，用于在新建一个用户时默认给用户配置的bashrc
~/.bashrc：只针对单个用户，每开启一个shell执行一次
对于profile：
/etc/profile: 针对所有用户，首次登录执行一次
/etc/skel/bash_profile: 针对所有用户，用于在新建一个用户时默认给用户配置的bashr_profile
~/.bash_profile: 只针对单个用户，首次登录执行一次
每次修改完配置文件后，都必须 source 一下已生效。
cp命令 常用 cp -au：
-a，即-dpR，-d 复制时保留链接，-p 保持权限不变，-R 递归复制，-u 表示在源文件有更新或者目标文件不存在时进行目标文件的复制。
Dos 与 Linux 换行符差异 首先知道：
回车 CR \r 换行 LF \n win/dos的换行： \r\n
unix mac linux的换行： \n
unix to win 换行失败。
win to unix 多了\r -&amp;gt; \r\n -&amp;gt; ^M。
解决方法，全部统一为LF即可。
如果win下已经为CRLF，那么可以在linux下运行：</description>
    </item>
    
    <item>
      <title>Git配置记录</title>
      <link>/posts/2022/10/git-configuration-record/</link>
      <pubDate>Thu, 13 Oct 2022 21:40:46 +0800</pubDate>
      
      <guid>/posts/2022/10/git-configuration-record/</guid>
      <description>Git 初始化 1 2 git config --global user.name=&amp;#34;akynazh&amp;#34; git config --global user.email=&amp;#34;akynazh@qq.com&amp;#34; 配置 Http 代理 1 git config --global http.https://github.com.proxy socks5://127.0.0.1:7890 配置 SSH 代理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # ~/.ssh/config Host github.com User git Port 22 Hostname github.com IdentityFile ~/.ssh/id_rsa ProxyCommand connect -S 127.0.0.1:7890 -a none %h %p Host ssh.github.com User git Port 443 Hostname ssh.github.com IdentityFile ~/.ssh/id_rsa ProxyCommand connect -S 127.</description>
    </item>
    
    <item>
      <title>Docker软件安装记录</title>
      <link>/posts/2022/10/docker-software-installation-record/</link>
      <pubDate>Thu, 13 Oct 2022 21:28:37 +0800</pubDate>
      
      <guid>/posts/2022/10/docker-software-installation-record/</guid>
      <description>Docker 1 2 curl -fsSL https://get.docker.com | bash -s docker # curl -sSL https://get.daocloud.io/docker | sh Mirror 1 2 3 4 5 6 7 8 9 10 11 12 13 vim /etc/docker/daemon.json { &amp;#34;registry-mirrors&amp;#34;: [ &amp;#34;https://docker.mirrors.ustc.edu.cn&amp;#34;, &amp;#34;http://hub-mirror.c.163.com&amp;#34;, &amp;#34;https://registry.docker-cn.com&amp;#34; ] } ---------------------------------------------- systemctl restart docker Docker-compose 1 2 3 4 5 6 curl -L &amp;#34;https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$(uname -s)-$(uname -m)&amp;#34; -o /usr/local/bin/docker-compose # curl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` &amp;gt; /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose # ln -s /usr/local/bin/docker-compose /usr/bin/dockerc 运行权限问题 1 2 sudo usermod -aG docker $USER sudo reboot MySQL 1 2 3 4 5 6 7 8 9 10 11 12 13 docker pull mysql:5.</description>
    </item>
    
    <item>
      <title>8086汇编学习记录</title>
      <link>/posts/2022/10/8086-assembly-learning-record/</link>
      <pubDate>Tue, 04 Oct 2022 23:18:24 +0800</pubDate>
      
      <guid>/posts/2022/10/8086-assembly-learning-record/</guid>
      <description>8086PC机内存地址空间分配 00000~9FFFF: 主存储器地址空间（RAM） A0000~BFFFF: 显存地址空间 C0000~FFFFF: 各类ROM地址空间 段寄存器 8086CPU不支持将数据直接送入段寄存器的操作，ds 是一个段寄存器，所以mov ds，1000H这条指令是非法的。
要将1000H送入ds，只好用一个寄存器来进行中转，即先将1000H送入一个一般的寄存器，如bx，再将bx中的内容送入ds。
为什么8086CPU不支持将数据直接送入段寄存器的操作?
这属于8086CPU硬件设计的问题。
关于SS，SP 8086CPU中，有两个寄存器，段寄存器 SS 和寄存器 SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。
任意时刻，SS∶SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。
伪指令 在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。
汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。
而伪指令没有对应的机器指令，最终不被 CPU 所执行。那么谁来执行伪指令呢?
伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。
汇编程序 在汇编源程序中，数据不能以字母开头，所以要在前面加0。比如，9138h在汇编源程序中可以直接写为“9138h”，而A000h在汇编源程序中要写为“0A000h”。
对于mov al,[0]，是将常量0送入al中，等同于mov al,0； 对于mov al,ds:[0]，含义是(al)=((ds)*16+0)； 对于mov al,[bx]，含义是(al)=((ds)*16+(bx))； 对于mov al,ds:[bx]，含义等同于上者。 Debug R命令：查看、改变CPU寄存器的内容； D命令：查看内存中的内容； E命令：改写内存中的内容； U命令：将内存中的机器指令翻译成汇编指令； T命令：执行一条机器指令； A命令：以汇编指令的格式在内存中写入一条机器指令； P命令：可用于快速结束一段LOOP，遇到loop时使用； G命令：可以让指令直接执行到某个地址处，如-g 0016执行到0016处代码。 实模式和保护模式 实模式是Intel 80286和之后的x86兼容CPU的操作模式。
实模式的特性是一个20位元的区段存储器地址空间（意思为只有1MB的存储器可以被寻址），软件可以直接访问BIOS例程以及周边硬件，没有任何硬件等级的存储器保护观念或多任务。
保护模式是一种80286系列和之后的x86兼容CPU的运行模式。
保护模式有一些新的特性，如存储器保护，标签页系统以及硬件支持的虚拟内存，能够增强多任务处理和系统稳定度。
现今大部分的x86操作系统都在保护模式下运行，包含Linux、FreeBSD、以及微软Windows 2.0和之后版本。
在纯 DOS 方式（实模式）下，可以不理会 DOS，直接用汇编语言去操作真实的硬件。
因为运行在 CPU 实模式下的 DOS，没有能力对硬件系统进行全面、严格的管理。
但在Windows 2000、Unix 这些运行于CPU保护模式下的操作系统中，不理会操作系统，用汇编语言去操作真实的硬件，是根本不可能的。硬件已被这些操作系统利用 CPU 保护模式所提供的功能全面而严格地管理了。
问题 向内存0:200~0:23F依次传送0~63(3FH)：</description>
    </item>
    
    <item>
      <title>关于hwbk文件问题的解决和思考</title>
      <link>/posts/2022/10/solution-and-thinking-about-hwbk/</link>
      <pubDate>Mon, 03 Oct 2022 20:52:12 +0800</pubDate>
      
      <guid>/posts/2022/10/solution-and-thinking-about-hwbk/</guid>
      <description>hwbk文件问题 假如你知道hwbk是什么，那么你肯定为它的存在而烦恼过。
在华为系的机子上，任何第三方工具想要删除相册的一张图片，系统都会做出保护，你使用的第三方工具并没有真的删除那张图片，系统拦截了删除操作并再对文件添加后缀名.hwbk。
更新：现在只要不卸载系统图库，系统会拦截第三方软件的删除操作，并将删除的照片送进图库的回收站，并不会生成hwbk文件。如果卸载了系统自带图库，则可以参考本文。
其它类似的问题 还有一个例子就是默认桌面程序了，第三方软件nova launcher比系统自带的桌面程序好用得多，而实际上却完全无法使用，因为默认程序无法修改，系统直接锁死。
同时，现在华为系的机子，只要是Android8以后的，似乎已经再也无法解开bootloader锁，官方不再给你申请的机会了，获取root，刷机已经成为一种幻想。
如何看待这些问题 商家总会告诉你这是处于安全保护的考虑，可以防止你误删了东西。其实完全没有必要，第三方软件也有回收站功能，只要自己注意不要安装来路不明的软件，病毒也不会莫名其妙找上门。
他不会给你一个选项，删除是否做出hwbk保护，而是直接强行做出保护，拒绝第三方的删除，这就等同于直接废了第三方软件的删除功能。这让许多人不得不使用系统自带软件，否则就是两头跑，这边删了，再到系统自带软件删一次。
你可以说这是为了更好的安全性用户所必须做出的牺牲，但也可以说这只是商家为了利益而主动选择的一种控制用户的手段。
从本质上看，无疑是一种很单纯的商业考量。他们让自己的系统封闭起来，强行让用户推动，发展自己的生态。
如果华为自带的软件够好，我想慢慢地，用户也会主动选择自带的软件（就像apple一样）。他们不是从自身找问题，改善自己的产品，而是强迫用户去适应，剥夺自由选择的权力。
如果是为了安全方面的问题，我想，一定也不只有这种一刀切的手段吧？对于安全方面的问题，我觉得应该让用户自己做决定，自己负责。就像有的人想获取root权限，他首先应该已经明白了获取root的后果是什么，愿意承担相应的风险。
为用户体验着想，绝不是强迫用户干什么，而是让用户自己决定干什么。
然而，他们凭什么为用户体验着想，能赚到钱不就完了？呵呵。
当然，对于大多普通用户而言，或许从来都遇不到这些问题，但是当有一天你遇到这些问题并为之困扰时，你多少会感觉自由被剥夺了。毕竟，我们自己花钱买的东西，为什么不能让我们自己自由支配呢？
通过adb干掉系统自带软件 电脑安装adb kits，adb所在目录加入环境变量（只是为了方便使用） 手机加入开发者模式 手机连接电脑，开启usb调试 命令行运行：adb devices 运行：adb shell 获取软件包名，写入applist.txt：pm list packages &amp;gt; applist.txt 通过包名卸载软件：pm uninstall --user 0 {pkg_name}（包名可自行google） 这是一个可选项，在你很反感系统自带软件时可以进行操作。
下面，回到hwbk问题。
让脚本帮我们自动消灭hwbk吧 假设你使用的是第三方的图库或者文件管理器，为了安全的考量，建议开启第三方软件的回收站。
当存在大量hwbk文件时，一个个手动删除是不存在的，而且每天都可能产生新的hwbk，所以定时地进行扫描删除也是必要的。
另外，通过尝试，将.hwbk后缀进行更改即可删除该文件。
通过脚本可以方便地进行操作，这里我通过js完成工作。
使用javascript进行删除操作 做法：每天固定一个时间（建议是在自己睡觉时）完成自动的清除。对所有目标文件夹进行扫描（递归性地），如果找到了.hwbk文件，将其后缀重命名为.hwbk.fuck_hwbk，再执行删除操作即可。
kill_hwbk.js
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 function kill_hwbk_r(parent_dir) { let child_dirs = files.</description>
    </item>
    
    <item>
      <title>关于定时任务的总结</title>
      <link>/posts/2022/10/summary-of-timed-tasks/</link>
      <pubDate>Mon, 03 Oct 2022 17:22:29 +0800</pubDate>
      
      <guid>/posts/2022/10/summary-of-timed-tasks/</guid>
      <description>Linux下的定时任务 规则 */1 * * * * cmd
5个单元：
分钟（0-59） 小时（0-23 日期（1-31） 月份（1-12） 星期几（0-6，其中0代表星期日）
例子 每分钟执行一次：* * * * * cmd
或者：*/1 * * * * cmd
每天早上6点10分执行一次：10 6 * * * cmd
每两个小时执行一次：0 */2 * * * cmd
在1月1日早上4点执行一次：0 4 1 1 * cmd
注意事项 一、crontab不会使用在.bashrc之类的文件中定义的变量。
解决方法：
若为python脚本，可以通过`os.environ.get(&amp;rsquo;{env}&amp;rsquo;)在脚本中访问变量； 若为shell脚本，可以在脚本中执行source {your_env_file}; 类似于2，可以在crontab语句中执行source {your_env_file}。 二、crontab用户配置位于：/var/spool/cron/{用户名}
可见，每个用户对应一个crontab配置，所以在crontab语句中使用~是可以的。
三、crontab日志位于：/var/log/cron
Windows下的定时任务 规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 SCHTASKS /parameter [arguments] Parameter List: /Create Creates a new scheduled task.</description>
    </item>
    
    <item>
      <title>Linux实用操作之进程管理</title>
      <link>/posts/2022/10/process-management-of-linux-practical-operation/</link>
      <pubDate>Sun, 02 Oct 2022 22:55:53 +0800</pubDate>
      
      <guid>/posts/2022/10/process-management-of-linux-practical-operation/</guid>
      <description>查看所有进程 ps -ef -e : all processes (-A) -f : full-format, including command lines 1 2 [root@VM-0-11-centos ~]# ps -ef | head -n 1 UID PID PPID C STIME TTY TIME CMD 解释如下：
PPID 父进程ID C 占用CPU百分比 STIME 就是&amp;quot;start time&amp;quot; TTY 进程在哪个终端显示 CMD 命令的名称和参数 ps aux a: all with tty, including other users (和-a是不同的) u: user-oriented format x: processes without controlling ttys 1 2 [root@VM-0-11-centos ~]# ps -aux | head -n 1 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 解释如下：</description>
    </item>
    
    <item>
      <title>《房思琪的初恋乐园》文摘</title>
      <link>/posts/2022/09/fang-siqis-first-love-paradise-abstract/</link>
      <pubDate>Tue, 06 Sep 2022 17:16:05 +0800</pubDate>
      
      <guid>/posts/2022/09/fang-siqis-first-love-paradise-abstract/</guid>
      <description>作者：林奕含
她们以前是思想上的双胞胎，精神的双胞胎，灵魂的双胞胎。以前伊纹姊姊说书，突然说好羡慕她们，她们马上异口同声说我们才羡慕姊姊和一维哥哥。伊纹姊姊说：恋爱啊，恋爱是不一样的，柏拉图说人求索他缺失的另一半，那就是说两个人合在一起才是完整，可是合起来就变成一个了，你们懂吗？像你们这样，无论缺少或多出什么都无所谓，因为有一个人与你镜像对称，「只有永远合不起来，才可以永远作伴」。
思琪她们北上念书之后，伊纹的生活更苍白了。她开始陪一维出差。最喜欢陪一维飞日本，一维去工作，她就从他们在银座的公寓里走出来，闲晃大半天。日本真好，每个人脸上都写着待办事项四个字，每个人走路都急得像赶一场亲人的喜事，或是丧事。一个九十秒的路灯日本人只要十秒就可以走完，伊纹可以慢慢地走，走整整九十秒，想到自己的心事被投进人潮之中变得稀释，想到她总是可以走整整九十秒的斑马线，黑，白，黑，白地走。她浪费了多少时间啊。她还有那么多的人生等着被浪费！
那一次，钱一维凌晨酒醒了，觉得握在被子里的手湿湿的，蹑手蹑脚不要吵醒伊纹，拍打脸颊，走进浴室，开灯看见脸上是血手印。此时的一维像希腊悲剧里的一幕，主人公不可思议地看着自己捧势却成空的双手，浴室灯光如舞台灯光如一束倒挂的郁金香包裹住他。他马上洗了脸，跑回房，开了灯，掀被子，发现睡在右手的伊纹下身全是血。一维突然想起昨天半夜回家，他用皮鞋尖勐踢伊纹。窄皮鞋头如一窝尖头毒蛇疯窜出去。伊纹抱紧双腿，他只能踢她的背。他想起伊纹一直说不要不要，不要不要。原来，伊纹说的是宝宝，宝宝。
窗外有鸟啼春，伊纹的表情像从一个前所未有的好梦中醒过来，从此才明白好梦比噩梦更令人恐怖。她发出从前那对万物好奇的声音：宝宝呢？她白得像一片被误报了花讯的樱花林，人人提着丰盛的野餐篮，但樱花早已全部被雨水打烂在地上，一瓣一瓣的樱花在脚下，花瓣是爱心形状，爱心的双尖比任何时候看起来都像是被爽约的缺口，而不是本来的形状。宝宝呢？对不起，伊纹，我的亲亲，我们可以再生一个。伊纹看着他，就像他是由她所不懂的语言所写成。伊纹宝贝？你没事最重要，不是吗？一维看着伊纹全身颤抖，隆隆的马达，催到极限，眼看要发动的时候，又整个人熄灭了。
伊纹听见思琪在啜泣，她在电话另一头，也可以看见思琪把手机拿远了小肩膀一耸一耸的样子。思琪说话了：「为什么这个世界是这个样子？为什么所谓教养就是受苦的人该闭嘴？为什么打人的人上电视上广告看板？姊姊，我好失望，但我不是对你失望，这个世界，或是生活，命运，或叫它神，或无论叫它什么，它好差劲，我现在读小说，如果读到赏善罚恶的好结局，我就会哭，我宁愿大家承认人间有一些痛苦是不能和解的，我最讨厌人说经过痛苦才成为更好的人，我好希望大家承认有些痛苦是毁灭的，我讨厌大团圆的抒情传统，讨厌王子跟公主在一起，正面思考是多么媚俗！可是姊姊，你知道我更恨什么吗？我宁愿我是一个媚俗的人，我宁愿无知，也不想要看过世界的背面。」思琪哭得字跟字都连在一起，伊纹也可以看见她涕泪满脸，五官都连在一起。
原来，人对他者的痛苦是毫无想像力的，一个恶俗的语境──有钱有势的男人，年轻貌美的小三，泪涟涟的老婆──把一切看成一个庸钝语境，一齣八点档，因为人不愿意承认世界上确实存在非人的痛苦，人在隐约明白的当下就会加以否认，否则人小小的和平就显得坏心了。在这个人人争著称自己为输家的年代，没有人要承认世界上有一群女孩才是真正的输家。那种小调的痛苦其实与幸福是一体两面：人人坐享小小的幸福，嘴里嚷着小小的痛苦──当赤裸裸的痛苦端到他面前，他的安乐遂显得丑陋，痛苦显得轻浮。
From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>《1Q84 Book1》文摘</title>
      <link>/posts/2022/09/1q84book1-excerpt/</link>
      <pubDate>Thu, 01 Sep 2022 14:15:44 +0800</pubDate>
      
      <guid>/posts/2022/09/1q84book1-excerpt/</guid>
      <description>作者：村上春树
第9章 青豆 风景变了，规则变了 1Q84年——我就这么来称呼这个新世界吧。青豆决定。
Q是question mark的Q。背负着疑问的东两。
她边走边独自点头。
不管喜欢还是不喜欢，目前我已经置身于这“1Q84年”。我熟悉的那个1984年已经无影无踪，今年是1Q84年。空气变了，风景变了。我必须尽快适应这个带着问号的世界。像被放进陌生森林中的动物一样，为了生存下去，得尽快了解并顺应这里的规则。
第16章 天吾 能让你喜欢，我很高兴 《十二平均律钢琴曲集》对学数学的人来说，简直是天国的音乐。均衡地使用全部的十二音阶，以大调和小调分别创作前奏曲和赋格曲。总共二十四支乐曲。第一部和第二部合计四十八支曲子。形成一个完美的圆。
第16章 天吾 能让你喜欢，我很高兴 回到家里，睡觉，做了个梦。许久没有的印象鲜明的梦境。梦中，自己变成了巨大拼图中的一个小块。不是固定在一处的小块，而是一个时时刻刻都在变幻形状的小块，因此任何位置都不能容纳他。这也是当然。另外，在寻找自身位置的同时，他还必须在规定时间内把定音鼓的分谱捡拾起来。这些乐谱被狂风吹散，七零八落，他必须一页页地拾起，确认页码，按照顺序整理成册。做这些事时，他自己还像阿米巴原虫一样不断地变幻形状。事态变得无法收拾。
后来深绘里不知从哪儿赶来，握住他的左手。于是天吾停止了变形，风也骤然停下，乐谱不再飘散。这下好啦。天吾心想。但同时，规定时间也将结束。“到此结束。”深绘里小声宣告。依旧只有一个句子。时间戛然而止，世界在此终结。地球缓缓地停止转动，所有的声音和光芒都消失殆尽。
翌日睁开眼时，世界安然无恙，还在继续。并且事物已经向前运转起来。就像印度神话中把前方所有生物统统碾杀的转轮一般。
第22章 天吾 时间能以扭曲的形态前进 时间能以扭曲的形态前进，这一点天吾知道。时间自身固然是成分均一的东西，然而它一旦被消耗，就会变得形态扭曲。有的时间非常重而长，有的时间则轻而短。前后秩序有时还会颠来倒去，严重时甚至消失得无影无踪。而本来不应存在的东西又会被添加进来。人类大概就是这样随意地对时间进行调整，从而调整自己的存在意义。换个说法，就是通过这样的操作，人类才能保持神经正常。假如对自己经历过的时间，一定得严守顺序、依照原样均等地接受，只怕人类的神经注定忍受不了。那样的人生恐怕等于拷问。天吾浮想联翩。
天吾一如往日，每周三天去补习学校讲课，其余的日子便继续伏案写作长篇小说，星期五和前来幽会的女朋友进行浓郁的午后做爱。但不论他做什么，都无法做到集中注意力。仿佛一个错把厚重云团的碎片吞进肚子里的人，郁塞滞重、心绪不宁地度日，食欲也慢慢减退。在半夜莫名其妙的时刻醒来，便再也无法入睡。在这样的不眠之夜思念着深绘里。她此刻在哪里？在做什么？和谁在一起？遭遇了什么？他在脑海中想象着种种状况，每一种尽管多少有差异，却都是带着悲观色彩的想象。而且在他的想象中，她总是身穿紧身夏季薄毛衣，胸脯呈现出美丽的形状。这个形象让天吾透不过气来，在他心中制造出更为剧烈的躁动。
From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>/posts/2022/08/policy-mode/</link>
      <pubDate>Fri, 26 Aug 2022 16:04:19 +0800</pubDate>
      
      <guid>/posts/2022/08/policy-mode/</guid>
      <description>定义 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
比如对于鸭子而言，不同鸭子的叫声方式可能不一样也可能一样，我们可以定义一个叫声行为接口，然后通过创建不同的叫声行为实现这个接口，在实例化鸭子时设定叫声行为即可。
这样相比于直接继承抽象鸭子后重写叫声行为方法，好处是减少了重复代码，而坏处是增加了类的数量。
代码展示 下面就以鸭子为例进行说明。
从接口开始 定义一个叫声接口：（其它接口省略）
1 2 3 public interface QuackBehavior { public void quack(); } 实现叫声接口 1 2 3 4 5 public class MuteQuack implements QuackBehavior { public void quack() { System.out.println(&amp;#34;&amp;lt;&amp;lt; Silence &amp;gt;&amp;gt;&amp;#34;); } } 其它接口省略。
创建抽象鸭子 每只鸭子都有Fly和Quack这两种行为。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public abstract class Duck { FlyBehavior flyBehavior; QuackBehavior quackBehavior; public Duck() { } public void setFlyBehavior(FlyBehavior fb) { flyBehavior = fb; } public void setQuackBehavior(QuackBehavior qb) { quackBehavior = qb; } abstract void display(); public void performFly() { flyBehavior.</description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>/posts/2022/08/proxy-pattern/</link>
      <pubDate>Fri, 26 Aug 2022 10:41:19 +0800</pubDate>
      
      <guid>/posts/2022/08/proxy-pattern/</guid>
      <description>定义 代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。
我们对一个对象的使用或者一个对象中方法的调用，可以通过这个对象的代理人进行访问，这个代理人可以方便地控制这个对象，让对象的功能更为强大或更易于使用。
常见的代理有：远程代理，虚拟代理，动态代理。
远程代理 对于远程代理，其实就是本地调用远程的方法，本地堆（客户端）有一个Stub代理对象，这个对象负责完成RMI操作，也就是远程方法调用，而远程堆（服务端）有一个Skeleton代理对象，它接收客户端的RMI操作，并传递给真正的服务对象进行服务，之后再返回给客户端结果。
使用过程中需要注意调用的对象必须是可序列化的，无需序列化的对象可以添加transient关键字。通过rmiregistry &amp;amp;开启RMI，之后进行服务注册。服务端通过Naming.rebind()绑定服务地址，客户端通过Naming.lookup()调用远程方法。另外，远程传输对象需要继承于UnicastRemoteObject。
在Java5中，RMI和动态代理搭配使用，动态代理动态产生Stub，远程对象的Stub是Proxy实例，它是自动产生的，来处理所有把客户的本地调用变成远程调用的细节。
虚拟代理 对于虚拟代理，也就是说这个代理对象是虚拟的，由代理来扮演对象的替身。
比如对于从网络加载一副图像展现给用户，我们可能需要等待一定时间，这段时间内图像应该展现为用户友好的“等待中”字样，而在网络图像获取成功后进行网络图像的展现。
这个过程可以通过代理的方式方便地完成：虚拟代理对象扮演图像的替身，它通过创建一个线程加载网络图像，加载期间将图像动态地变为用户友好字样，完成加载后改为网络图像。
可以发现我们不是直接使用图像本身，而使用了代理对象作为图像，也就是说，代理扮演了图像这个角色。
下面是一个图像代理对象：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class ImageProxy implements Icon { volatile ImageIcon imageIcon; final URL imageURL; Thread retrievalThread; boolean retrieving = false; public ImageProxy(URL url) { imageURL = url; } public int getIconWidth() { .</description>
    </item>
    
    <item>
      <title>状态模式</title>
      <link>/posts/2022/08/status-mode/</link>
      <pubDate>Thu, 25 Aug 2022 22:54:26 +0800</pubDate>
      
      <guid>/posts/2022/08/status-mode/</guid>
      <description>定义 状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
比如某个机器有各种复杂的状态，每个状态都着共同的参数，而这些参数值有区别。用户通过某些操作会改变机器的状态，机器转变状态后，以当前状态的方法给用户反馈。
代码展示 以机器的例子说明。
从接口开始 编写状态接口：
1 2 3 4 5 6 7 8 9 public interface State { public void insertQuarter(); public void ejectQuarter(); public void turnCrank(); public void dispense(); public void refill(); } 创建机器类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 package headfirst.</description>
    </item>
    
    <item>
      <title>组合模式</title>
      <link>/posts/2022/08/combination-mode/</link>
      <pubDate>Thu, 25 Aug 2022 21:58:13 +0800</pubDate>
      
      <guid>/posts/2022/08/combination-mode/</guid>
      <description>定义 组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。
对于菜单内容而言，假如只有简单的菜品项，那么通过迭代器可以轻松地遍历，但是如果菜单内容中含有子菜单，那么就需要组合模式了。
代码展示 下面就以菜单为例子展示组合模式。
从抽象开始 创建菜单组件：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public abstract class MenuComponent { public void add(MenuComponent menuComponent) { throw new UnsupportedOperationException(); } public void remove(MenuComponent menuComponent) { throw new UnsupportedOperationException(); } public MenuComponent getChild(int i) { throw new UnsupportedOperationException(); } public String getName() { throw new UnsupportedOperationException(); } public String getDescription() { throw new UnsupportedOperationException(); } public double getPrice() { throw new UnsupportedOperationException(); } public boolean isVegetarian() { throw new UnsupportedOperationException(); } public void print() { throw new UnsupportedOperationException(); } } 创建菜单 菜单本身是一个菜单组件，菜单继承于菜单组件，实现父类方法。</description>
    </item>
    
    <item>
      <title>迭代器模式</title>
      <link>/posts/2022/08/iterators-mode/</link>
      <pubDate>Thu, 25 Aug 2022 11:26:17 +0800</pubDate>
      
      <guid>/posts/2022/08/iterators-mode/</guid>
      <description>定义 迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。
通过一个Iterator，可以方便地遍历各种类型，如HashMap，ArrayList等。
代码展示 下面通过菜单的例子进行说明。
分别用简单数组String[]和ArrayList&amp;lt;String&amp;gt;类创建菜单内容。
从接口开始 创建菜单接口：
1 2 3 public interface Menu { public Iterator&amp;lt;String&amp;gt; createIterator(); } 每个菜单都可以返回一个迭代器。
创建Diner菜单 该菜单用String[]创建内容，需要编写自己的迭代器。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class DinerMenu implements Menu { static final int MAX_ITEMS = 6; int numberOfItems = 0; String[] menuItems; public DinerMenu() { menuItems = new String[MAX_ITEMS]; addItem(&amp;#34;Vegetarian BLT&amp;#34;); addItem(&amp;#34;BLT&amp;#34;); addItem(&amp;#34;Soup of the day&amp;#34;); addItem(&amp;#34;Hotdog&amp;#34;); addItem(&amp;#34;Steamed Veggies and Brown Rice&amp;#34;); addItem(&amp;#34;Pasta&amp;#34;); } public void addItem(String name) { if (numberOfItems &amp;gt;= MAX_ITEMS) { System.</description>
    </item>
    
    <item>
      <title>模板方法模式</title>
      <link>/posts/2022/08/template-method-mode/</link>
      <pubDate>Wed, 24 Aug 2022 17:14:16 +0800</pubDate>
      
      <guid>/posts/2022/08/template-method-mode/</guid>
      <description>定义 模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
“好莱坞”原则 别调用我们，我们会调用你。
其实就是防止“依赖腐败”，也就是要避免高层组件和低层组件相互依赖。一般由高层组件依赖低层组件。
代码展示 泡茶和泡咖啡有着几乎相同的步骤，但在某些子步骤中有差别。通过模板方法可以很好地解决问题。
定义模板方法 子步骤brew()和addCondiments()为抽象方法，由子类具体实现。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public abstract class CaffeineBeverage { final void prepareRecipe() { boilWater(); brew(); pourInCup(); addCondiments(); } abstract void brew(); abstract void addCondiments(); void boilWater() { System.out.println(&amp;#34;Boiling water&amp;#34;); } void pourInCup() { System.out.println(&amp;#34;Pouring into cup&amp;#34;); } } 定义具体方法 继承CaffeineBeverage并实现抽象方法。
1 2 3 4 5 6 7 8 public class Coffee extends CaffeineBeverage { public void brew() { System.</description>
    </item>
    
    <item>
      <title>外观模式</title>
      <link>/posts/2022/08/appearance-mode/</link>
      <pubDate>Tue, 23 Aug 2022 16:20:06 +0800</pubDate>
      
      <guid>/posts/2022/08/appearance-mode/</guid>
      <description>外观模式 定义 外观模式提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。
“最少知识”原则 减少对象之间的交互，只和“密友”谈话，也就是减少一个类所交互的类的数量。
代码展示 执行一些复杂操作需要一步步执行许多小操作，那么可以将复杂操作封装为一个高层类中的方法，将所有复杂操作需要用到的类作为高层类的成员，在复杂操作的方法中可以方便的调用各个类执行各自的功能。
下面是一个家庭影院的例子：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 public class HomeTheaterFacade { Amplifier amp; Tuner tuner; StreamingPlayer player; CdPlayer cd; Projector projector; TheaterLights lights; Screen screen; PopcornPopper popper; public HomeTheaterFacade(Amplifier amp, Tuner tuner, StreamingPlayer player, Projector projector, Screen screen, TheaterLights lights, PopcornPopper popper) { this.</description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>/posts/2022/08/adapter-mode/</link>
      <pubDate>Tue, 23 Aug 2022 16:00:04 +0800</pubDate>
      
      <guid>/posts/2022/08/adapter-mode/</guid>
      <description>适配器模式 定义 适配器模式将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。
代码展示 鸭子和火鸡叫声不一样，通过编写适配器让火鸡适配鸭的方法。
从接口开始 1 2 3 4 public interface Duck { public void quack(); public void fly(); } 1 2 3 4 public interface Turkey { public void gobble(); public void fly(); } 编写适配器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class TurkeyAdapter implements Duck { Turkey turkey; public TurkeyAdapter(Turkey turkey) { this.turkey = turkey; } public void quack() { turkey.</description>
    </item>
    
    <item>
      <title>《菊与刀》文摘</title>
      <link>/posts/2022/08/chrysanthemum-and-knife-abstract/</link>
      <pubDate>Tue, 23 Aug 2022 15:14:43 +0800</pubDate>
      
      <guid>/posts/2022/08/chrysanthemum-and-knife-abstract/</guid>
      <description>作者：本尼迪克特
第5章 背负着历史和社会恩情债的日本人 日本人对于卷入“恩情”的事都表现得十分谨慎。即使是一支烟，递烟的人要是过去与他没有什么交往，也会让他感到别扭。碰到这种情况，日本人表达谢意的最礼貌回答一般是：“真过意不去”（日语是“の毒”，它原本的意思是让人为难的感情）。
曾经有一个日本人给我解释了为什么要这样说：“碰到这样的事，把自己感到为难的情况直接表达出来还会更好受一些，虽然拒绝总是让人难为情。如果轻易接受了这样的帮助，而你又根本没有想过为对方做事，那么你的‘受恩’就是让人感到羞耻的。”因此只能说，“真过意不去”（の毒）。
英语对于“の毒”这句话的翻译，有时是“Thank you”（谢谢。谢谢您的烟）有时是“I am sorry”（很抱歉，很遗憾），或者需要翻译成“I feel like a heel”（蒙您看得起。实在不好意思）。每个译法都没有错误，可是都不贴切。
第8章 名声的价值 他们觉得，如果不能洗刷有关自己的耻辱，那就是彼此之间存在着不公平，“世界就不平衡”。一个正义之士的最高理想就是尽自己最大的努力让世界重归平衡。这是一种高尚的美德，无关于人性中的罪恶。
在欧洲历史上也出现过人们非常看重名誉的时期，人们也把“对名誉的情义”看做一种道德准则，比如文艺复兴时期的意大利，这种风尚也曾盛极一时，还有古典时期西班牙的el valor Espanol（西班牙的勇敢）以及德意志的die Ehre（名誉），都与日本的“对名誉的情义”有很多共通的地方，甚至在一百多年以前欧洲颇为流行的决斗行为似乎也是在与这种道德准则相类似的观念驱使下进行的。
值得注意的是，不管是日本，还是西欧各国，只要是雪耻道德观念成为多数人认同的共同价值，那么这个地方的人多数都会把道德置于物质利益之上。所以，越是为了自己的“名誉”而牺牲财产、家庭及其生命的人，就越被认为是一个有着高尚道德的人。名誉已经成了道德的一部分，它被这个国家常常作为“精神”价值的基础而大大提倡。这种价值观必然会产生对物质价值观的贬抑，同样它能够给这个民族带来与众不同的东西。
这种对于名誉十分看重的观念，正与我们美国人在生活中到处都要激烈竞争和公开对抗的观念有一个鲜明的对比。在美国的一些政治或经济活动中，如果要获得或保持某种物质利益，那一定是一种“战争”。日本人对于名誉的捍卫就像我们对于利益的捍卫一样，没有什么不同。
不过，我们不要觉得亚洲大陆都会有出现因捍卫自己的名誉而有的敌意和伺机报复甚至是极端行动。这完全不是东方的气质，中国人就不会这样，暹罗人、印度人也没有这个特点。当中国人遇到侮辱或诽谤的时候，他们会认为这些人是“小人”，是没有道德的人。中国人非常重视名誉但中国人不会像日本人一样把名誉看成是高尚的理想。在中国，如果一个人因为名誉受损而使用不正当的暴力来肆意报复所遇的侮辱被视为一种十分愚蠢的行为。他们认为这是神经过敏，十分可笑。他们也不会一定要做什么以证明自己的清白，更多时候，他们会对毫无根据的侮辱和诽谤置之不理，因为在中国人眼里，“君子”是不值得和“小人”一般见识的。至于暹罗人，根本无法从他们身上看到有谁对侮辱多么敏感。他们和中国人一样，让诽谤者自己处于尴尬的地位，便足以保证自己的名誉不会受到损害。他们的格言说：“让对方暴露自己卑鄙的最好办法就是自己的容忍。”
如果说世界上有最不能饶恕的罪过的话，那就是待人没有诚意，而嘲笑别人是最没有诚意的待人之道。
如果有人朝我发火，我会原谅他，因为有些人就是有一副急脾气；如果有人对我撒谎，我也可以原谅他，因为有些谎言是被逼无奈的选择；如果有人在传一些没有任何根据的流言或者背后对别人品头论足，我同样可以原谅他，因为当人们在遇到别人聊起闲话时，有时候会不自觉地陷进去。
甚至就算是一个杀人犯，我也不会不分青红皂白彻底否定他。可是对于嘲笑别人的人，这是绝对无法原谅的，因为这样的人内心之中没有任何待人的真诚，所以他才不顾他人的感受让一个无辜者难堪。
现在让我来说明一下我对这两个词的定义。所谓杀人犯，就是残害他人肉体的人；而所谓嘲笑者，是残害他人心灵的人。
遇到失败、污蔑或者被排斥的日本人都非常敏感，因此常常生自己的气而不是生别人的气。现在的日本小说大多所描写的就是一个有教养的日本人是如何不安地面对极端狂怒与悲伤抑郁的故事，这能反映很多日本人的情绪。在小说中，主角对于一切不满，讨厌日常生活，讨厌家庭，讨厌城市，讨厌乡村。这种情绪不是因为自己的理想没有实现，而是在理想的目标面前，自己的努力太过渺小。其实如果有一个远大的目标远景，无论这是一个多么遥远的目标，日本人的厌倦情绪都会消失得无影无踪，之所以有这种厌倦情绪更多的是因为自己的敏感，他们常常害怕自己被排斥在伟大事业之外，因此内心没有依靠。
日本的小说所反映的内容总是一个弥漫着能够让人情绪爆发的有毒气体的社会。无论是小说的主人公还是作者本人都不会花心思弄明白为什么在日本社会中会弥漫着这样的空气，似乎这是一种正常现象。正是因为总有这种刺激人们情绪的氛围，所以人们都容易伤感。在封建时代，日本人会把自己的情绪指向对自己进行侵犯的人，可是现在，他们却将这种攻击转向自己。在他们看来，一个人忧郁不一定因为十分明确的原因，虽然能够找一些借口安慰自己：我是因为某事而心情不好，可是他们内心之中更多的是埋怨自己。
第十二章 儿童学习 在转入扩大精神自由的过渡时期，日本人或许可以借助两三种古老的传统而保持平稳。其中之一就是“自我负责”精神，亦印他们所说的自己负责擦掉“身上的锈”。这一形象的语言把身体比作刀，正如佩刀者有责任保护刀的光洁，人也要对自己行为的后果负责。他必须承认并接受由于自己的弱点、不坚定和无效性而产生的一切自然后果。在日本，对自我负责的解释远比自由的美国更加严格。在这种意义上，刀不是进攻的象征，而是理想和敢于自我负责者的比喻。在尊重个人自由的社会，这种德性将起着最有效的平衡轮的作用。而且，日本的儿童教养和行为哲学已使自我负责的德性深入人心，成为日本精神的一部分。现在日本人已经在西方意义上提出了“放下刀”（投降），但在日本意义上，他们仍将继续努力关注如何才能使心中那把易被锈蚀的刀保持光洁。就他们的道德术语而言，这把刀是一种即使在自由、和平世界也能保存的象征。</description>
    </item>
    
    <item>
      <title>《不能承受的生命之轻》文摘</title>
      <link>/posts/2022/08/abstract-of-unbearable-lightness-of-life/</link>
      <pubDate>Tue, 23 Aug 2022 14:52:39 +0800</pubDate>
      
      <guid>/posts/2022/08/abstract-of-unbearable-lightness-of-life/</guid>
      <description>作者：米兰·昆德拉
第一部 轻与重 他付了账，走出饭店，想在街上逛逛，满怀的忧郁渐渐地令他心醉。他同特蕾莎已经生活了七个春秋，此刻他才发现，对这些岁月的回忆远比他们在一起生活时更加美好。
他和特蕾莎之间的爱情无疑是美好的，但也很累人：总要瞒着什么，又是隐藏，又是假装，还得讲和，让她振作，给她安慰，翻来覆去地向她证明他爱她，还要忍受因为嫉妒、痛苦、做噩梦而产生的满腹怨艾，总之，他总感到自己有罪，得为自己开脱，请对方原谅。现在，再也不用受累了，剩下的只有美好。
星期六的夜晚开始了；他第一次独自在苏黎世漫步，深深地呼吸着自由的芬芳。在每个角落，都潜藏着诱惑。未来成了一个谜。他又回到了单身汉的生活，他曾坚信自己命中注定要过这种生活，因为只有在这样的生活中他才真正是他自己。
他跟特蕾莎捆在一起生活了七年，七年里，他每走一步，她都在盯着。仿佛她在他的脚踝上套了铁球。现在，他的脚步突然间变得轻盈了许多。他几乎都要飞起来了。此时此刻，他置身于巴门尼德的神奇空间：他在品尝着温馨的生命之轻。
第二部 灵与肉 我们每天的生活充满了各种偶然性，确切地说，是人、事之间的偶然相遇，我们称之为巧合。两件预料不到的事出现在同一时刻，就叫巧合。他俩的相遇，便是巧合：托马斯出现在酒吧的时刻，收音机里正播放着贝多芬的乐曲。这些巧合绝大多数都在不经意中就过去了。如果不是托马斯，而是街角卖肉的坐在酒吧的桌子旁，特蕾莎可能不会注意到收音机在播放贝多芬的乐曲（虽然贝多芬和卖肉的相遇也是一种奇怪的巧合）。但是萌生的爱情使她对美的感觉异常敏锐，她再也忘不了那首乐曲。每次听到这首乐曲，她都激动不已。那一刻发生在她身边的一切都闪耀着这首乐曲的光环，美轮美奂。
这不是喘息，也不是呻吟，是真正的喊叫。叫声太大了，托马斯不得不让头偏离她的脸远一点，仿佛这尖叫声就要震裂他的耳膜。这不是肉欲的发泄。所谓肉欲便是极度调动众感官：热切地注视对方的一举一动，全神贯注地倾听对方的每一丝声响。恰恰相反，特蕾莎喊叫，却是为了让感官迟钝，使它们无法去注视、去倾听。在她体内发出的喊叫，是为了表达她那幼稚的理想主义的爱情，要消除一切矛盾，消除肉体和灵魂的两重性，甚或消除时间。
特蕾莎读的书比他们多，对生活的了解也比他们透彻，但她自己从未意识到这些。自学者和学生的区别，不在于知识的广度，而在于生命力和自信心的差异。
第三部 不解之词 音乐对弗兰茨来说，最接近于酒神狄俄尼索斯那种狂醉之美的，是艺术。靠小说和画幅难以自遣，但是听贝多芬的《第九交响曲》，巴托克的《钢琴二重奏鸣曲》，或是披头士的一支歌，就能自我陶醉。弗兰茨对高雅音乐和轻音乐不加区分。区分在他看来是虚伪而老套的。他对摇滚乐和莫扎特的喜爱不偏不倚。
对他来说，音乐是救星：它将他从孤独、幽闭和图书馆里的灰尘之中解救出来，它在他的身躯上打开了多扇门，使灵魂得以释放，与他人相亲相爱。他喜欢跳舞，并为萨比娜不跟他一样喜欢跳舞而感到遗憾。
对萨比娜来说，活着意味着观看。视觉受双重边界所限：让人什么也看不见的强光与完全彻底的黑暗。她对任何极端主义的憎恶，或许产生于此。极端标志着生命的终极之界，极端主义的激情，不论是政治上的，还是艺术上的，都是一种改头换面的对死的渴望。
而对于弗兰茨，“光明”这个词不会让人联想到柔和的日光照耀下的风景，而会想到光源，如太阳，灯泡，探照灯。他想起一些常见的隐喻，如真理之太阳，理性的耀眼之光，等等。
他被光明吸引，同样也被黑暗所吸引。如今，关灯做爱，在世人看来委实可笑。对此他也明白，所以让床上方亮着一盏小灯。但在进入萨比娜身体的那一瞬，他还是闭上了双眼。吞噬着他的极度快感企求的是黑暗。那黑暗是彻底的，绝对的，没有形象也没有幻影，无穷无尽，无边无际。那黑暗是我们每个人内心所在的无限。（是的，凡寻求无限者，只需闭上双眼！）
就在快感在他全身蔓延开来的那一刻，弗兰茨在无边的黑暗中渐渐展开，融化，化作了无限。但是，人在内在的黑暗中变得越大，他的外在形象就越小。一个紧闭双眼的男人，只是一个毁弃了的自我，看起来让人心生厌恶。因此萨比娜不愿看着他，也闭上了眼睛。但这种黑暗对她来说并不意味着无限，而仅仅是对她所见的东西的拒绝，是对所见之物的否定，是拒绝去看。
从浴室出来，她摁下了开关。这是她第一次这么做。弗兰茨本该留心她这一举动。他并没注意到，因为光线对于他无关紧要，我们知道，做爱时他总是闭着眼睛。正是由于他紧闭的双眼萨比娜才将灯熄灭。她不愿看见，即便只是一秒，那垂下的眼帘。如俗语所说，眼睛是心灵之窗。弗兰茨的身体伏在她身上扭动，双眼紧闭，在她看来，这只是一具没有灵魂的躯体。他像是一只尚未睁眼的幼崽，因为饥渴而发出阵阵可怜的嗷叫。肌肉强健的弗兰茨做爱时就像一只吃奶的巨大幼犬。确实如此，他嘴里还含着她的一只乳头，如同吮奶一样！下半身的弗兰茨是个成年男子，而上半身则是个吮乳的婴儿，那么她是在跟一个婴儿上床，一想到这，她觉得厌恶到了极点。不，她再也不愿看到他无望地在她身上挣扎，再也不愿像母狗喂幼崽一样送上自己的乳房。今天是最后一次，无可挽回的最后一次！
当然，她明白，自己的决定极不公平。弗兰茨是她所遇见的男人中最优秀的。他聪明，懂她的画。他善良，正直，英俊。但她心里愈清楚，愈想去践踏他的聪明、善良，践踏他那脆弱的强健。
这一夜，她以胜过往日的激情与他做爱，因为想到是最后一次而万分激动。她与他缠绵着，而心早已到了遥远的别处。她再度听见远方吹响叛逆的金号角，清楚自己无力抗拒那号声的召唤。她眼前仿佛展开了一片更为广阔的自由天地，那天地之广大令她兴奋。她疯狂而粗野地与弗兰茨做爱，好像从未曾有过那样。
弗兰茨在她身上唏嘘，他肯定明白了一切：晚餐时，萨比娜默不作声，也没跟他说对他的决定是怎么想的。可是现在，她回应了他。她在向他显示她的欢悦、激情、允诺和与他共度一生的渴望。
他感觉自己像是骑士，驰骋在一片极其美妙的空白里，没有配偶，没有子女，没有家庭，被赫拉克勒斯巨人之帚清扫一空的绝对空白，他将以爱情来把它填满。
他们彼此以对方为坐骑，奔向他们所向往的远方。他们都沉醉在令自己获得解放的背叛之中，弗兰茨骑着萨比娜背叛了他的妻子，而萨比娜骑着弗兰茨背叛了弗兰茨。
人生的悲剧总可以用沉重来比喻。人常说重担落在我们的肩上。我们背负着这个重担，承受得起或是承受不起。我们与之反抗，不是输就是赢。可说到底，萨比娜身上发生过什么事？什么也没发生。她离开了一个男人，因为她想离开他。在那之后，他有没有再追她？有没有试图报复？没有。她的悲剧不是因为重，而是在于轻。压倒她的不是重，而是不能承受的生命之轻。
第四部 灵与肉 她只想在工程师家里待一会儿，只喝杯咖啡，看看自己是如何走向不忠的边缘的。她想把自己的身体推至那边缘，在不忠的示众柱上待上片刻，然后，当工程师试图把她抱在怀里的那一刻，她会像她在彼得山上对持枪的男人那样，对他说：“不，不！这不是我的意愿。”
那男人会垂下他的枪口，声音温柔地说：“如果这不是您的意愿，我就不能这样做。我没有这个权利。”
她会转过头去，朝向树干，号啕大哭。
第五部 轻与重 追逐众多女性的男人很容易被归为两类。一类人在所有女人身上寻找他们自己的梦，他们对于女性的主观意念。另一类人则被欲念所驱使，想占有客观女性世界的无尽的多样性。
前者的迷恋是浪漫型的迷恋：他们在女人身上寻找的是他们自己，是他们的理想。他们总是不断地失望，因为，正如我们所知，理想从来都是不可能找到的。失望把他们从一个女人推向另一个女人，赋予他们的善变一种感伤的借口，因此，许多多愁善感的女人为他们顽强的纠缠所感动。
后者的迷恋是放荡型的迷恋，女人在其中看不到丝毫感人之处：由于男人没有在女性身上寄托一个主观的理想，他们对所有女人都感兴趣，没有谁会令他们失望。的确，就是这从不失望本身带有某种可耻的成分。在世人眼中，放浪之徒的迷恋是不可宽恕的（因为从不为失望而补赎）。
他想起了柏拉图《会饮篇》中那个著名传说：以前人类是两性同体的，上帝把他们分成了两半，从那时起，这两半就开始在世界上游荡，相互寻找。爱情，是对我们自己失去的另一半的渴望。
From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>命令模式</title>
      <link>/posts/2022/08/command-mode/</link>
      <pubDate>Mon, 22 Aug 2022 11:41:33 +0800</pubDate>
      
      <guid>/posts/2022/08/command-mode/</guid>
      <description>定义 命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。
比如对于遥控器而已，我们会将操作封装为一个按钮（命令）对象，通过按下按钮执行操作。
代码展示 下面以遥控器作为例子：
从接口开始 命令接口：
1 2 3 public interface Command { public void execute(); } 定义操控对象 一个风扇对象：（其它对象省略了）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Light { String location = &amp;#34;&amp;#34;; public Light(String location) { this.location = location; } public void on() { System.out.println(location + &amp;#34; light is on&amp;#34;); } public void off() { System.out.println(location + &amp;#34; light is off&amp;#34;); } } 定义操控对象的命令 操作风扇的命令：</description>
    </item>
    
    <item>
      <title>单件模式</title>
      <link>/posts/2022/08/singleton-pattern/</link>
      <pubDate>Mon, 22 Aug 2022 11:14:23 +0800</pubDate>
      
      <guid>/posts/2022/08/singleton-pattern/</guid>
      <description>我的思考 单件模式，容易知道需要某个对象是独一无二的，那么它首先应该是静态的，不能在程序动态运行期间被再次创建。
当在多个线程中用到它时，在创建时需要考虑线程安全问题，可通过加锁等方式解决。
代码实现 传统的单件 定义一个私有实例化的对象，把单件对象作为一个私有的静态成员变量，通过静态方法Singleton.getInstance()获取，若获取为null则创建对象。
1 2 3 4 5 6 7 8 9 10 11 12 public class Singleton { private static Singleton uniqueInstance; private Singleton() {} public static Singleton getInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } } 线程安全的单件 传统的单件线程不安全，解决如下：
1 2 3 4 5 6 7 8 9 10 11 12 public class Singleton { private static Singleton uniqueInstance; private Singleton() {} public static synchronized Singleton getInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } } 改善多线程性能 如上线程安全的代码，getInstance()在多次调用的情况下性能太低，改善方法如下：</description>
    </item>
    
    <item>
      <title>工厂模式</title>
      <link>/posts/2022/08/factory-mode/</link>
      <pubDate>Sun, 21 Aug 2022 23:31:45 +0800</pubDate>
      
      <guid>/posts/2022/08/factory-mode/</guid>
      <description>我的思考 工厂模式，包括工厂方法模式和抽象工厂模式。
对于工厂方法模式，工厂是一个抽象类，提供了一些默认实现方法和一些抽象方法，具体工厂继承于它，实现对应抽象方法。
假设有多家比萨店，他们提供不同口味的比萨，而都有相同的订购比萨的方法，那么可以定义一个抽象类，提供订购比萨的具体方法和创建比萨的抽象方法。
对于抽象工厂模式，工厂是一个接口，提供了一些具体工厂会用到的方法，同时还需要定义这些方法可能用到的接口。具体工厂需要首先实现抽象工厂定义的方法可能用到的接口，然后实现抽象工厂的所有方法。
假设有多家生产比萨配料的工厂，他们都有自己的独特的配料（实现所有配料接口），那么可以定义一个抽象工厂（一个接口），提供所有配料创建方法，具体工厂各自实现所有创建方法即可。
总之，他们的具体区别如下：
工厂方法模式使用继承，把对象的创建委托给子类，子类实现工厂方法来创建对象。 抽象工厂模式使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中。 工厂方法模式代码 从抽象开始 比萨店抽象类：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 public abstract class PizzaStore { abstract Pizza createPizza(String item); public Pizza orderPizza(String type) { Pizza pizza = createPizza(type); System.out.println(&amp;#34;--- Making a &amp;#34; + pizza.getName() + &amp;#34; ---&amp;#34;); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; } } 具体的比萨店 芝加哥的比萨店：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ChicagoPizzaStore extends PizzaStore { Pizza createPizza(String item) { if (item.</description>
    </item>
    
    <item>
      <title>装饰者模式</title>
      <link>/posts/2022/08/decorator-mode/</link>
      <pubDate>Sun, 21 Aug 2022 23:17:27 +0800</pubDate>
      
      <guid>/posts/2022/08/decorator-mode/</guid>
      <description>我的思考 装饰，如其名，就是对一个对象进行加工，包装，修饰。
假设一杯“普通的咖啡，价格10”，我们可以选择添加自己喜欢的配料。
首先我们添加牛奶，那么就变成了一杯“含牛奶配料的咖啡，价格2 +（价格12）”；
我想再加点巧克力，那么再往上包装变成“含巧克力的含牛奶配料的咖啡，价格3 +【价格2+（价格12）】”。
这么一层层封装上去就是装饰模式。
我们要在每一个配料中定义一个可包装的对象，在包装后返回这个对象。具体代码如下文。
代码实现 定义抽象类 饮料抽象类：
1 2 3 4 5 6 7 8 9 public abstract class Beverage { String description = &amp;#34;Unknown Beverage&amp;#34;; public String getDescription() { return description; } public abstract double cost(); } 配料抽象类：
注意这里配料也继承了饮料类，这样Beverage在通过包装之后还是返回一个Beverage，具体见测试代码。
1 2 3 4 public abstract class CondimentDecorator extends Beverage { Beverage beverage; public abstract String getDescription(); } 定义具体类 牛奶配料：（其他配料省略）
1 2 3 4 5 6 7 8 9 10 11 12 13 public class Milk extends CondimentDecorator { public Milk(Beverage beverage) { this.</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>/posts/2022/08/observer-mode/</link>
      <pubDate>Sun, 21 Aug 2022 22:59:33 +0800</pubDate>
      
      <guid>/posts/2022/08/observer-mode/</guid>
      <description>我的思考 对于观察者模式，既然有观察者，那么就首先有被观察者。
观察者可以通过订阅，监听等方式实现“观察”，被观察者需要通过通知，发消息之类的方式通知观察者接收信息。
假设有一个气象观测站，天气数据对象作为被观察者，各个气象观测站作为观察者订阅天气数据，而天气数据记录各个订阅了自己的观测站，以便于通知。具体代码实现如下文。
代码实现 定义接口 被观察者：
1 2 3 4 5 public interface Subject { public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers(); } 观察者：
1 2 3 public interface Observer { public void update(float temp, float humidity, float pressure); } 定义对象实现接口 天气数据对象：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class WeatherData implements Subject { private List&amp;lt;Observer&amp;gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() { observers = new ArrayList&amp;lt;Observer&amp;gt;(); } public void registerObserver(Observer o) { observers.</description>
    </item>
    
    <item>
      <title>《克莱因壶》文摘</title>
      <link>/posts/2022/08/klein-pot-abstract/</link>
      <pubDate>Mon, 15 Aug 2022 20:11:50 +0800</pubDate>
      
      <guid>/posts/2022/08/klein-pot-abstract/</guid>
      <description>作者：冈岛二人
梨纱凝视着我。她的鼻子近在咫尺。我俩的鼻尖蹭在了一起，梨纱缓缓闭上了眼睛。于是我贴近她的脸，让唇与唇轻轻触碰。她的吐息拂过我的脸颊。我加深了吻，她的气息中顿时掺杂了如啜泣般的声音。
——快回去。
百濑的声音从梨纱的喘息中传来。
——趁现在还可以控制，快逃吧。
我抱住梨纱，手上用力。
梨纱双眸微闭，我学着她的样子，也慢慢闭上了眼。
镜子，映出了我的身影。
然而，人们为什么能断言自己在镜外、映出的影像在镜内呢?谁也无法直接看见自己的眼睛。想知道自己的瞳孔颜色，就只能窥视镜子。既然如此，或许双瞳仅存在于镜中，不是吗?
现在想想，与“克莱因壶”扯上关系的最初一瞬间，我就已经被吸进壶里了。一定是的。正如拿起镜子时，双瞳会被摄入镜中世界一样。一旦被吞入，就绝无可能爬出去。
从阁楼的窗户向外眺望，山叶开始渐渐转红。我下山买的报纸上还在大肆报道残暑未消，这一带却已是秋意袭人。
这时，一只翠羽鸟从我眼前飞过，唯有翅膀的中央夹着一道白纹。
我打算写完这段话，就下楼去浴室把脏胡子刮掉，然后从刮胡刀上拆下刀片，躺进浴缸。我想裸身在浴缸里躺下，用刀片割腕试试。
这是留给我的最后一招。
这里是壶内还是壶外，别无他法验证。我只能在浴缸里割腕。然后会怎样，我不知道。我甚至无法看到结果。
如果这是壶内，恐怕会游戏终止。如果这是壶外——
其实，结果如何并不重要，将这百转千回的思绪击个粉碎才是我的本意。 “从开始的地方开始，在结束的地方结束。这样就行。”
就这么做吧，我想。</description>
    </item>
    
    <item>
      <title>《只狼》游戏回忆和场景记录</title>
      <link>/posts/2022/08/sekiro-memoir/</link>
      <pubDate>Mon, 15 Aug 2022 16:11:17 +0800</pubDate>
      
      <guid>/posts/2022/08/sekiro-memoir/</guid>
      <description>记录下沉浸在只狼的世界中的那段时光里，让我印象深刻的一些地方。
这是白雪覆盖之下的苇名城，颇具美感。
第一个感觉难残的boss是赤鬼，但凡多贪一刀就很容易被抓住干掉，同时如果不知道红颜怪怕火这个特点，那么只能跟它一来一回磨血量了。后面双难模式下打赤鬼，虽然被抓到就是秒杀，但是如果使用火刀，反而轻而易举地可以拿下赤鬼。和赤鬼的战斗十分刺激，也十分绝望，当时花了不少时间，在一次又一次的死亡中，吸取教训，提高熟练度，最终战胜强敌。
之后打完赤鬼往前走，在悬崖峭壁之间，我初遇白蛇，开始真正被这个游戏所吸引：
这是一条巨大无比的白蛇，据考证应该是一条双头蛇，要么就是有两条这样的蛇，因为后期忍杀了一条后，还能发现在洞窟里发现另一个蛇头在动。它曾经是当地人信仰的白蛇神。遇见这条蛇时，我欣赏了许久（也挂了不少次=_=），颇有趣味，感觉来到了一个奇异的世界。
对战义父，父慈子孝。选择了保护神子，坚持自己的信念，就必须和义父反目成仇。此时的天守阁正是黄昏时刻，一场艰苦卓绝的战斗即将开始：
这是一场无比艰难的战斗。义父的攻击时快时慢，各种招数层出不穷。他的韧性很高，想把他逼入绝境，必须不断地进攻。
最后，狼是从背后忍杀了义父，留下一句“落影，物归原主”，取回落樱。而同时也是狼还给义父的一刀，还的是三年前义父背刺狼的那一刀。
在前往狮子猿所在地的路上，悬崖绝壁之间，筑有许多巨大佛雕，额外有意思，也令人生畏：
置身源之宫，如梦如画。满湖落樱，清水如镜。第一次来时的确感觉来到了世外桃源。但是后来慢慢深入内部，才发现这华美的景象背后潜藏着多么丑陋的东西&amp;hellip;&amp;hellip;
初见樱龙，气势凌人，这虽然只是一场表演战，但是还是特别有意思。第一次见的时候完全被樱龙的气势震撼到：
拿到龙泪后，便回到苇名城，准备最后的对决了。此时的苇名城已经混乱不堪，战斗愈演愈烈。
最后对战剑圣苇名一心。它无疑是只狼中难度仅次于怨恨之鬼的boss了。但在一周目时感觉和义父也五五开吧，在双难模式下就比义父难多了。
第一次遇见一心，很难不为他的剑圣风范所震慑到：
最后作为介错人处死一心，也能感受到他无比的剑圣气质。
在三周目尝试堕为修罗，这的确算是是最坏的结局，狼最后甚至把义父也杀了&amp;hellip;&amp;hellip;在高周目玩了一次这个结局，感觉没有动力在玩一次修罗结局了。
于火光中结束一切&amp;hellip;&amp;hellip;
个人最满意的结局，也是官方指定结局，龙之还乡：
狼和皇子都活了下来，和神子一道前往西方，送还樱龙，断绝不死之诅咒，走向新的征程：
到此结束。感谢fs社给我带来的这一段珍贵的经历！
From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>使用Seata处理分布式事务</title>
      <link>/posts/2022/08/using-seata-to-process-distributed-transactions/</link>
      <pubDate>Tue, 09 Aug 2022 21:41:53 +0800</pubDate>
      
      <guid>/posts/2022/08/using-seata-to-process-distributed-transactions/</guid>
      <description>关于分布式事务 ​分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作。
这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务。
例如用户下一个订单，需要首先创建订单，然后删减库存，接着扣除用户的金钱，最后完成订单。这个过程中，每个操作都可以作为一个微服务，每个微服务操作对应的数据库，而各个数据库可能分布在不同机器上，那么分布式事务就产生了，我们要确保一个事务被正确地处理，必须解决好分布式事务的数据提交与回滚。
关于Seata Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。（来源官网）
TC (Transaction Coordinator) - 事务协调者：
维护全局和分支事务的状态，驱动全局事务提交或回滚。
TM (Transaction Manager) - 事务管理器：
定义全局事务的范围：开始全局事务、提交或回滚全局事务。
RM (Resource Manager) - 资源管理器：
管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。
开始编码测试 架构说明 开启三个微服务，创建订单服务，删减库存服务，扣除用户金钱服务，均注册到nacos。
由订单服务作为入口，首先创建订单，然后删减库存，最后扣钱，完成订单，各个服务数据存取操作均处于不同数据库中。
使用seata作为分布式事务解决方案，也注册到nacos中。
配置Seata环境 一、下载Seata1.0.0
二、建seata表，sql链接
三、修改配置
(1) registry.conf:
type修改为nacos
1 2 3 4 5 6 7 8 9 10 11 registry { # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = &amp;#34;nacos&amp;#34; nacos { serverAddr = &amp;#34;localhost:8848&amp;#34; namespace = &amp;#34;&amp;#34; cluster = &amp;#34;default&amp;#34; } .</description>
    </item>
    
    <item>
      <title>Sentinel使用记录</title>
      <link>/posts/2022/08/sentinel-usage-record/</link>
      <pubDate>Mon, 08 Aug 2022 17:46:49 +0800</pubDate>
      
      <guid>/posts/2022/08/sentinel-usage-record/</guid>
      <description>Sentinel是什么 Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件，主要以流量为切入点，从流量路由、流量控制、流量整形、熔断降级、系统自适应过载保护、热点流量防护等多个维度来帮助开发者保障微服务的稳定性。（来源于官方文档）
个人使用感觉：类似于Hystrix，使用上感觉比Hystrix更容易，功能也更强大。
架构说明 两个生产者服务运行在9001和9002端口，一个消费者服务运行在80端口，均注册到nacos，消费者调用两个生产者的服务。
将消费者服务注册到sentinel中，通过修改一些规则进行测试。
controller下的方法指定好处理服务限流，降级或熔断等的方法blockHandler，以及处理未知异常的fallback方法，通过指定class的方法避免代码膨胀。
service下的方法指定好关于生产者的服务限流，降级或熔断等的处理方法。
代码编写记录 生产者端 一、配置
关于nacos的配置省略，只记录sentinel的配置：
1 2 3 4 5 6 7 8 spring: application: name: nacos-payment-provider cloud: sentinel: transport: dashboard: localhost:8080 port: 8179 二、controller编写
1 2 3 4 5 6 7 8 9 10 11 @RestController @Slf4j public class PaymentController { @Value(&amp;#34;${server.port}&amp;#34;) private String port; @GetMapping(&amp;#34;/payment/nacos/info&amp;#34;) public String paymentInfo() { return &amp;#34;port: &amp;#34; + port; } } 返回对应端口，方便测试负载均衡。
消费者端 一、配置
1 2 3 4 5 6 7 8 9 10 spring: application: name: nacos-order-consumer sentinel: transport: dashboard: localhost:8080 port: 8179 feign: sentinel: enabled: true 注意要开启feign的sentinel支持。</description>
    </item>
    
    <item>
      <title>Docker-compose快速配置nacos集群环境</title>
      <link>/posts/2022/08/docker-compose-quickly-configures-nacos-cluster-environment/</link>
      <pubDate>Sun, 07 Aug 2022 16:02:27 +0800</pubDate>
      
      <guid>/posts/2022/08/docker-compose-quickly-configures-nacos-cluster-environment/</guid>
      <description>前言 总体架构说明 在一台CentOS主机上部署，版本为7.9，IP为192.168.1.127。
通过docker创建三台nacos环境的机器，端口均运行在8848，分别映射到主机的8848，8858，8868端口上，名称（hostname）分别为nacos-server1，nacos-server2，nacos-server3。
主机通过nginx监听8080端口，通过负载均衡将请求转发到三台nacos机器上。
主机作为数据库源，使用mysql作为数据库，端口为3306，三台机器都安装mysql环境，端口运行在3306，映射到主机3307端口。
服务说明 创建一个简单的服务，注册到上述nacos环境中，通过在bootstrap.yaml中读取nacos配置来验证环境是否配置成功。
搭建nacos环境 编辑docker-compose的yaml文件 在nacos官网下载nacos-docker到主机上，编辑example/cluster-hostname.yaml文件。
根据官网说明，在nacos2中需要额外暴露两个端口，分别偏移8848这个端口1000和1001。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 version: &amp;#34;3&amp;#34; services: nacos1: hostname: nacos-server-1 container_name: nacos1 image: nacos/nacos-server:${NACOS_VERSION} volumes: - .</description>
    </item>
    
    <item>
      <title>Batch基本编写方法记录</title>
      <link>/posts/2022/08/batch-basic-compilation-method-record/</link>
      <pubDate>Wed, 03 Aug 2022 23:34:36 +0800</pubDate>
      
      <guid>/posts/2022/08/batch-basic-compilation-method-record/</guid>
      <description>读取输入 1 2 set /p ch=&amp;#34;y/n:&amp;#34; echo %ch% 变量运算 通过%{var}%访问变量，通过/a进行表达式计算设置值。
1 2 3 4 5 6 7 8 @echo off set money=100 echo 初始金额： %money% set /a money=%money%*2 set /a money=%money%+100 echo 现在的金额：%money% 选择并跳转 :{point} 用于指定一个跳转点。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @echo off set /p ch=&amp;#34;y/n:&amp;#34; if &amp;#34;%ch%&amp;#34;==&amp;#34;&amp;#34; ( goto end ) else if &amp;#34;%ch%&amp;#34;==&amp;#34;n&amp;#34; ( goto no ) else if &amp;#34;%ch%&amp;#34;==&amp;#34;y&amp;#34; ( goto yes ) else ( goto end ) :no echo NO goto end :yes echo YES goto end :end 循环语句 通过%%x设置和访问循环值； 通过(start, steps, end)设置循环； /l 将通过比较start和end来执行迭代。 1 2 3 4 5 @echo off for /l %%x in (1, 5, 100) do ( echo hello, jzh-%%x ) 变量动态变化 setlocal enabledelayedexpansion开启变量延迟，使得变量可以动态变化; 需通过!</description>
    </item>
    
    <item>
      <title>Zipkin使用记录</title>
      <link>/posts/2022/07/zipkin-usage-record/</link>
      <pubDate>Fri, 29 Jul 2022 18:26:44 +0800</pubDate>
      
      <guid>/posts/2022/07/zipkin-usage-record/</guid>
      <description>Zipkin的作用 查看微服务调用过程； 分析微服务依赖关系； 方便地找到调用过程错误发生位置。 Zipkin使用记录 一、下载Zipkin并运行：
1 java -jar zipkin.jar 这样成功运行后，默认在端口9411可以查看图形管理界面。
二、依赖引入
在所有调用到的微服务中引入：
1 2 3 4 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-zipkin&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 三、配置文件
1 2 3 4 5 6 spring: zipkin: base-url: http://localhost:9411 sleuth: sampler: probability: 1 # 采样率介于0和1之间，1表示全部采集 测试 通过service-name标签搜索自己的微服务名称，即可检索到与该微服务有依赖的所有微服务，可查看调用过程，依赖关系等。
From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>SpringCloud-Stream使用记录</title>
      <link>/posts/2022/07/springcloud-stream-usage-record/</link>
      <pubDate>Fri, 29 Jul 2022 17:26:05 +0800</pubDate>
      
      <guid>/posts/2022/07/springcloud-stream-usage-record/</guid>
      <description>为何使用Stream？ 实现消息的收发可以用许多种方式来实现，如Kafka，RabbitMQ等，而通过Stream可以方便地通过一个Binder对象与这些不同的实现工具对接，应用程序通过Inputs和Outputs来与Binder交互即可实现消息的收发，这样我们就只需要知道如何与Stream交互即可方便地使用消息驱动。
下图即Stream工作原理：
Stream使用记录 一、依赖导入 除去一些基本依赖之外，发布端和订阅端均导入：
1 2 3 4 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-stream-rabbit&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 二、基本配置 发布端：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 spring: cloud: stream: binders: defaultRabbit: type: rabbit environment: spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: output: destination: myExchange content-type: application/json binder: defaultRabbit 订阅端：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 spring: cloud: stream: binders: defaultRabbit: type: rabbit environment: spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: input: destination: myExchange content-type: application/json binder: defaultRabbit group: jzh1 注意，两个订阅端如果实现同一微服务，group应该一样，这样，在同一个组内会发生竞争关系，只有其中一个可以消费（默认采用轮询的机制处理），避免了出现重复消费的问题。</description>
    </item>
    
    <item>
      <title>Config结合Bus使用记录</title>
      <link>/posts/2022/07/config-combined-with-bus-usage-record/</link>
      <pubDate>Wed, 27 Jul 2022 22:00:55 +0800</pubDate>
      
      <guid>/posts/2022/07/config-combined-with-bus-usage-record/</guid>
      <description>为何要使用Config和Bus Config可以进行多个微服务下的全局配置，更加方便，易于管理。
当全局配置修改时，需要通知各个微服务，一个一个地通知是非常耗时的，如果可以通过广播的方式快速将消息传递出去就轻松多了，而通过Bus即可实现这一点。
测试方法 一、在6996端口通过git拉取全局配置，相当于一个ConfigServer，6886和6776端口作为ConfigClient；
二、Bus结合RabbitMQ实现，修改配置时，只通知ConfigServer，达到消息广播的效果。
依赖引入 一、ConfigServer端：
1 2 3 4 5 6 7 8 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 二、ConfigClient端：
1 2 3 4 5 6 7 8 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 其他一些基本包就省略了。
文件配置 一、ConfigServer端：
以下为application.yml:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 spring: cloud: config: server: git: # github项目地址 uri: https://github.</description>
    </item>
    
    <item>
      <title>SpringCloud-Gateway使用记录</title>
      <link>/posts/2022/07/springcloud-gateway-usage-record/</link>
      <pubDate>Tue, 26 Jul 2022 18:33:44 +0800</pubDate>
      
      <guid>/posts/2022/07/springcloud-gateway-usage-record/</guid>
      <description>网关的作用 如图所示，网关介于外部请求和具体微服务之间，在不暴露内部微服务端口的情况下，通过一个或者多个指定的网关端口统一地处理外部各种请求。
使用SpringCloud Gateway 依赖引入 除了基本依赖以外，引入下列依赖：
1 2 3 4 5 6 7 8 9 &amp;lt;!-- others --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-gateway&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 注意不能引入web相关依赖，因为Gateway是基于WebFlux的。
文件配置 列出部分重要配置：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 server: port: 9669 cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由 routes: - id: path_route uri: lb://CLOUD-PAYMENT-SERVICE # lb：负载均衡 predicates: - Path=/payment/** - After=2022-07-26T17:33:52.449+08:00[Asia/Shanghai] # ZonedDateTime.now() - Cookie=username,jzh 注意点如下：</description>
    </item>
    
    <item>
      <title>Hystrix实现服务熔断与监控</title>
      <link>/posts/2022/07/hytrix-realizes-service-fusing-and-monitoring/</link>
      <pubDate>Tue, 26 Jul 2022 11:39:11 +0800</pubDate>
      
      <guid>/posts/2022/07/hytrix-realizes-service-fusing-and-monitoring/</guid>
      <description>什么是服务熔断 概念 应对微服务雪崩效应的一种链路保护机制，类似保险丝。
关于雪崩效应 微服务之间的数据交互是通过远程调用来完成的。服务A调用服务，服务B调用服务C，某一时间链路上对服务C的调用响应时间过长或者服务C不可用，随着时间的增长，对服务C的调用也越来越多，然后服务C崩溃了，但是链路调用还在，对服务B的调用也在持续增多，然后服务B崩溃，随之A也崩溃，导致雪崩效应。
实现机制 当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。
通过Hystrix实现服务熔断，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，就会启动熔断机制，断路器打开。而在一段时间之后，断路器会变为半开状态，此时允许部分微服务调用，如果都成功了，即不超过设定好的阈值，那么断路器将恢复为关闭状态。
如下图所示：（来自Martin Fowler大神的博客）
应用场景 微服务架构中，多个微服务相互调用出使用
Hystrix实现服务熔断 环境搭建 1. 关于pom.xml 1 2 3 4 5 6 7 8 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 2. 启动类添加@EnableHystrix注解，表示使用熔断器。 实现服务熔断 1. PaymentService.java 1 2 3 4 public interface PaymentService { ... String circuitBreaker(Integer id); } 2. PaymentServiceImpl.java 设置服务熔断的核心配置：
（1）启用断路器:
1 @HystrixProperty(name = &amp;#34;circuitBreaker.enabled&amp;#34;, value = &amp;#34;true&amp;#34;) （2）设置请求次数:
1 @HystrixProperty(name = &amp;#34;circuitBreaker.requestVolumeThreshold&amp;#34;, value = &amp;#34;10&amp;#34;) （3）设置时间窗口期:</description>
    </item>
    
    <item>
      <title>Hystrix实现服务降级</title>
      <link>/posts/2022/07/hytrix-enables-service-degradation/</link>
      <pubDate>Tue, 26 Jul 2022 10:59:08 +0800</pubDate>
      
      <guid>/posts/2022/07/hytrix-enables-service-degradation/</guid>
      <description>什么是服务降级 概念 一般指在服务器压力剧增的时候，根据实际业务使用情况以及流量，对一些服务和页面有策略的不处理或者用一种简单的方式进行处理，从而释放服务器资源的资源以保证核心业务的正常高效运行。
应用场景 多用于微服务架构中，一般当整个微服务架构整体的负载超出了预设的上限阈值（和服务器的配置性能有关系），或者即将到来的流量预计会超过预设的阈值时。
大致实现过程 为了预防某些功能出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。
使用Hystrix实现服务降级 本实验配合了Feign实现，利用Feign通过接口的方式解耦服务这一特点，通过在实现服务接口的类来编写方法对应的fallback方法。
环境搭建 一、关于pom
在消费方实现服务降级，除了基本包导入外，导入以下：
1 2 3 4 5 6 7 8 9 10 11 12 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 二、关于application.yml
除了基本配置外，以下两个超时时间的配置需要格外注意：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 设置feign超时时间（默认为1秒） feign: hystrix: enabled: true client: config: default: ConnectTimeOut: 5000 ReadTimeOut: 5000 # 设置hystrix超时时间（默认为1秒） hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000 其他关于Feign的环境配置省略了。</description>
    </item>
    
    <item>
      <title>Linux实用操作之系统服务管理</title>
      <link>/posts/2022/07/system-service-management-of-linux-practical-operation/</link>
      <pubDate>Sun, 24 Jul 2022 20:42:27 +0800</pubDate>
      
      <guid>/posts/2022/07/system-service-management-of-linux-practical-operation/</guid>
      <description>systemctl指令 立即启动一个服务：systemctl start my.service 立即停止一个服务：systemctl stop my.service 重启一个服务：systemctl restart my.service 重新加载一个服务的配置文件：systemctl reload my.service 重载所有修改过的配置文件：systemctl daemon-reload 开启自启动服务：systemctl enable my.service 取消开启自启动：systemctl disable my.service 查看是否已经自启动：systemctl is-enabled my.service 查看服务运行状态：systemctl status my.service 查看所有服务：systemctl --type service service和chkconfig指令 启动服务：service my.service start 终止服务：service my.service stop 重启服务：service my.service restart 查看服务运行状态：service my.service status 开启或取消开机自启动：chkconfig my.service on/off 查看开机自启动列表：chkconfig --list Unit配置文件解释 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 - Unit - Description，服务的描述 - Requires，定义此unit需在哪个daemon启动后才能够启动 - Service - Type，定义启动时的进程行为。它有以下几种值。 - Type=simple，默认值，执行ExecStart指定的命令，启动主进程 - Type=forking，以 fork 方式从父进程创建子进程，创建后父进程会立即退出 - Type=oneshot，一次性进程，Systemd 会等当前服务退出，再继续往下执行 - Type=dbus，当前服务通过D-Bus启动 - Type=notify，当前服务启动完毕，会通知Systemd，再继续往下执行 - Type=idle，若有其他任务执行完毕，当前服务才会运行 - ExecStart，启动当前服务的命令 - ExecStartPre，启动当前服务之前执行的命令 - ExecStartPost，启动当前服务之后执行的命令 - ExecReload，重启当前服务时执行的命令 - ExecStop，停止当前服务时执行的命令 - ExecStopPost，停止当其服务之后执行的命令 - RestartSec，自动重启当前服务间隔的秒数 - Restart，定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog - TimeoutSec，定义 Systemd 停止当前服务之前等待的秒数 - Environment，指定环境变量 - Install - WantedBy，值是一个或多个Target，当前Unit激活(enable)时，符号链接会放入/etc/systemd/system目录下面以Target名+.</description>
    </item>
    
    <item>
      <title>Wsl主要操作记录</title>
      <link>/posts/2022/07/wsl-main-operation-records/</link>
      <pubDate>Sat, 23 Jul 2022 17:34:52 +0800</pubDate>
      
      <guid>/posts/2022/07/wsl-main-operation-records/</guid>
      <description>wsl在window开机后自启ssh服务 wsl下创建脚本，执行：vim /etc/init.wsl，并根据需要写入服务：
1 /etc/init.d/${需要的服务} # 或者使用service/systemctl命令 再赋予init.wsl执行权限，执行：chmod +x /etc/init.wsl
window下在启动目录下创建脚本：wsl.bat，写入开机命令如下：
1 wsl -d &amp;lt;DistributionName&amp;gt; -u root /etc/init.wsl 其中，版本通过wsl -l查看。
wsl一些常用命令 wsl ~ -u jzh: 以jzh用户登录并进入用户文件夹 wsl --shutdown: 关闭wsl wsl -l -v: 查看已安装的wsl版本 wsl --status: 检查wsl状态 wsl -l --online: 查看可通过在线商店获得的 Linux 发行版列表 wsl修改默认登录用户 &amp;lt;DistributionName&amp;gt; config --default-user root: 将登录默认用户设为root
手动安装wsl的话可能无法生效，可通过修改/etc/wsl.conf完成：
1 2 3 # Set the user when launching a distribution with WSL. [user] default = root 然后重启wsl即可完成。
切换wsl1和wsl2 1 wsl --set-version &amp;lt;distribution name&amp;gt; &amp;lt;versionNumber&amp;gt; &amp;lt;versionNumber&amp;gt;值为1或2，对应wsl1和wsl2。</description>
    </item>
    
    <item>
      <title>Wsl自定义安装位置</title>
      <link>/posts/2022/07/wsl-custom-installation-location/</link>
      <pubDate>Sat, 23 Jul 2022 17:27:31 +0800</pubDate>
      
      <guid>/posts/2022/07/wsl-custom-installation-location/</guid>
      <description>自定义wsl安装位置 下载wsl-ubuntu： 20.04版本：https://aka.ms/wslubuntu2004 18.04版本：https://aka.ms/wsl-ubuntu-1804 其他版本自行前往官网查找。
修改后缀名 下载后得到AppxBundle文件，将后缀名改为zip，然后解压。
解压后得到如下内容：
选择x64或ARM64的安装包均可均可，将后缀名改为zip，然后解压。
开始安装wsl-ubuntu 解压后得到如下内容：
双击ubuntu.exe，即可开始安装wsl-ubuntu。
安装完成后在该目录下得到虚拟盘：
注：虚拟盘也可能变成rootfs文件。
登录wsl 安装时会让你指定用户名和密码，这个用户是默认添加到sudoers里的。
如果想用root登录，通过sudo passwd root可以设置root密码（root刚开始没有密码），接着通过su即可登录root。
From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>OpenFeign使用记录</title>
      <link>/posts/2022/07/openfeign-usage-record/</link>
      <pubDate>Fri, 22 Jul 2022 17:39:24 +0800</pubDate>
      
      <guid>/posts/2022/07/openfeign-usage-record/</guid>
      <description>为什么要使用OpenFeign 之前在消费端使用RestTemplate时，每次请求都要进行诸如
1 restTemplate.postForObject(PAYMENT_URL + &amp;#34;/payment/create&amp;#34;, payment, CommonResult.class); 这样的调用，需要指定较多参数，当一个接口调用中需要非常多这样的请求时，会比较繁琐，而且这种方式不够抽象。
OpenFegin利用面向接口编程的思想，抽象化，简化了上述操作。
使用OpenFeign 关于pom.xml 1 2 3 4 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 关于application.yml 除了基本配置内容外，注意以下配置：
1 2 3 4 5 6 7 8 9 10 11 feign: # 设置feign客户端超时时间（默认为1秒） client: config: default: ConnectTimeOut: 10000 ReadTimeOut: 10000 # 针对每个接口设置日志监控级别 logging: level: com.jzh.springcloud.service.PaymentService: debug # feign日志以什么级别监控端口 编写服务接口 首先在启动类开启@EnableFeignClients注解，接着编写服务接口：
添加@FeignClient注解，值为对应微服务名； 方法对应微服务Controller下的方法即可。 1 2 3 4 5 6 7 8 9 @Component @FeignClient(value = &amp;#34;CLOUD-PAYMENT-SERVICE&amp;#34;) public interface PaymentService { @GetMapping(&amp;#34;/payment/get/{id}&amp;#34;) CommonResult&amp;lt;Payment&amp;gt; getPaymentById(@PathVariable(&amp;#34;id&amp;#34;) Long id); @PostMapping(&amp;#34;/payment/create&amp;#34;) CommonResult&amp;lt;Integer&amp;gt; createPayment(@RequestBody Payment payment); } 调用接口 注入PaymentController接口，然后即可调用它的方法。</description>
    </item>
    
    <item>
      <title>理解快速幂运算并进行应用</title>
      <link>/posts/2022/07/understand-and-apply-fast-power-operation/</link>
      <pubDate>Thu, 21 Jul 2022 20:44:54 +0800</pubDate>
      
      <guid>/posts/2022/07/understand-and-apply-fast-power-operation/</guid>
      <description>快速幂运算的解释 问n是否满足$x^n \mod n = x (1 &amp;lt; x &amp;lt; n)$？
先由一个例子引入：
$3^{11} = 3 \times 9^5 = 3 \times 9 \times 81^2 = 3 \times 9 \times 6561^1$
$result = 3 \times 9 \times 6561 = 3^{2^0} \times 3^{2^1} \times 3^{2^3}$
可见发现这次运算中，幂的结果等于变化中所有当指数为奇数时底数之积。其中，每次运算均发生指数除二（对应二进制右移一位），且当该指数为奇数时，原式乘上底数。
而这个过程其实相当于一个数进行模2取余求二进制数的过程，每次都除2，当模2余1，即对应二进制最末位为1时乘上底数，则由此可以推知快速幂运算的算法过程。
这个结论是可以证明的，如下：
对于任何十进制正整数n，设其对应二进制数为&amp;quot;$b_m&amp;hellip;b_3b_2b_1$&amp;quot;，则有：
二进制转十进制：$n = 1b_1+2b_2+4b_3+&amp;hellip;+2^{m-1}b_m$； 幂的二进制展开：$x^n = x^{1b_1}x^{2b_2}x^{4b_3}&amp;hellip;x^{2^{m-1}b_m}$。 则对于$x^n$的求解，可以转化为：
计算$x^1,x^2,x^4&amp;hellip;x^{m-1}$的值，相当于$x=x^2$的过程； 获取二进制各位$b_1,b_2,b_3,&amp;hellip;,b_m$的值，相当于模2求余的过程。 上述过程中，当$b_i=0$时，$x^{2^{i-1}b_i}=1$，反之为$x^{2^{i-1}}$，由此可以顺利计算$x^n$。
相应代码：
1 2 3 4 5 6 7 8 9 10 typedef long long ll; ll mod_pow(ll x, ll n, ll mod) { ll res = 1; while(n &amp;gt; 0) { if(n &amp;amp; 1 == 1) res = res * x % mod; // 一个数&amp;amp;1的结果就是取该数二进制的最末位 x = x * x % mod; n &amp;gt;&amp;gt;= 1; }	return res; } 注意，运用位运算可以提高效率！</description>
    </item>
    
    <item>
      <title>Hugo通过Algolia添加站内搜索功能</title>
      <link>/posts/2022/07/hugo-adds-onsite-search-function-through-algolia/</link>
      <pubDate>Wed, 20 Jul 2022 23:46:01 +0800</pubDate>
      
      <guid>/posts/2022/07/hugo-adds-onsite-search-function-through-algolia/</guid>
      <description>注册账号并创建Index 官网链接：Algolia，注册完成后保存好ApiID和ApiKey。
接着，创建一个Index，保存好Index的名称。
数据生成以及上传Algolia 方法一：通过hugo-algolia插件的方式 一、下载hugo-algolia： npm install -g hugo-algolia
二、编写config.yaml
网站根目录下创建config.yaml，编写参数如下：
1 2 3 4 5 6 --- algolia: index: &amp;#34;{indexName}&amp;#34; key: &amp;#34;{key}&amp;#34; appID: &amp;#34;{appID}&amp;#34; --- 三、生成algolia.json
网站根目录下运行： hugo-algolia -s，即可生成 {site}/public/algolia.json，同时该数据也同步到了algolia账户下，可以去官网查看。
四、前往algolia的indices进行搜索类型的设置
可以选择按tag，category，content等内容进行搜索，并指定优先级。
方法二：通过GithubAction的方式 这里不通过插件而是通过hugo定制化地生成algolia.json，然后通过GithubAction在每次push时上传数据。
个人更推荐这样做，更好定制化且方便。同时上面方法一有个bug，对中文数据好像不支持。
一、配置algolia输出文件 1 2 3 4 5 6 7 8 9 10 outputs: home: - HTML - RSS - Algolia outputFormats: Algolia: mediaType: application/json baseName: algolia isPlainText: true 二、生成algolia.json 编辑 {site}/themes/layouts/_default/list.algolia.json 如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [ {{- range $index, $entry := .</description>
    </item>
    
    <item>
      <title>理解Ribbon并自己实现负载均衡</title>
      <link>/posts/2022/07/understand-ribbon-and-realize-load-balancing-by-yourself/</link>
      <pubDate>Wed, 20 Jul 2022 17:07:35 +0800</pubDate>
      
      <guid>/posts/2022/07/understand-ribbon-and-realize-load-balancing-by-yourself/</guid>
      <description>负载均衡（LB）是什么 对于用户的某个请求，将有多个相同功能的服务点服务该请求，某个服务点挂了，其他服务点还是可以进行服务，这样就实现了系统的高可用。
关于集中式LB和进程内LB 集中式LB 在服务的消费方和提供方之间使用独立的LB设施，（软硬件均可，软件如Nginx，硬件如F5），由该设施负责把访问请求通过某种策略（可自行指定）转发至服务的提供方。
进程内LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务点进行服务。
Ribbon属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它获取服务提供方的地址。
使用Ribbon实现负载均衡 关于导包 1 2 3 4 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;!-- 已经包含了ribbon --&amp;gt; &amp;lt;/dependency&amp;gt; 注意eureka内置了ribbon。
开启注解 1 2 3 4 5 6 7 8 @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced // 赋予负载均衡能力 public RestTemplate getRestTemplate() { return new RestTemplate(); } } 访问相同服务名地址即可。
修改Ribbon负载均衡规则 所有规则均实现了IRule接口，通过查看接口实现类即可知道规则的种类。
默认是RoundRobinRule（轮询）这一规则。
下面修改为RandomRule（随机）这一规则：
在启动类扫描不到的包下创建规则： 1 2 3 4 5 6 7 @Configuration public class MyRibbonRule { @Bean public IRule myRule() { return new RandomRule(); } } 在启动类指定规则： 1 2 3 4 5 6 7 8 @SpringBootApplication @EnableEurekaClient @RibbonClient(name=&amp;#34;CLOUD-PAYMENT-SERVICE&amp;#34;, configuration = MyRibbonRule.</description>
    </item>
    
    <item>
      <title>Consul配置过程及测试</title>
      <link>/posts/2022/07/consul-configuration-process-and-test/</link>
      <pubDate>Tue, 19 Jul 2022 16:34:39 +0800</pubDate>
      
      <guid>/posts/2022/07/consul-configuration-process-and-test/</guid>
      <description>前言 类似于zookeeper和eureka，也起到微服务注册中心的作用, 满足分布式系统中的CP原则，是弱可用性的。
不同于zookeeper和eureka这两种主要由Java编写的语言，它主要由Go语言编写。
配置Consul环境 下载consul，配置环境变量。 运行consul agent -dev开启服务。 默认端口为8500，访问localhost:8500进入管理界面。 编写springcloud服务代码 一、关于pom.xml
除了一些基本包的导入之外，关于consul包的导入：
1 2 3 4 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-consul-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 二、关于application.yml
1 2 3 4 5 6 7 8 9 10 spring: application: name: cloud-consumer-order cloud: consul: host: localhost port: 8500 discovery: service-name: ${spring.application.name} 三、启动类添加@EnableDiscoveryClient注解。
consul测试 较为简单，访问localhost:8500查看即可。
From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>Zookeeper配置过程与测试</title>
      <link>/posts/2022/07/zookeeper-configuration-process-and-test/</link>
      <pubDate>Tue, 19 Jul 2022 12:00:37 +0800</pubDate>
      
      <guid>/posts/2022/07/zookeeper-configuration-process-and-test/</guid>
      <description>前言 Zookeeper类似于Eureka，起到微服务注册中心的作用，满足分布式系统中的CP原则，是弱可用性的。
配置zookeeper环境 安装zookeeper 下载并解压zookeeper包为zookeeper3.7.1（假设下载的是3.7.1版本）。
然后将zookeeper解压缩到/usr/local/zookeeper3.7.1。
配置参数 一、编辑/conf/zoo.cfg
编辑zookeeper包内配置文件/conf/zoo.cfg（先创建，再将zoo_sample.cfg内容复制到其中）
修改或添加以下内容：
1 2 dataDir=/usr/local/zookeeper3.7.1/dataDir dataLogDir=/usr/local/zookeeper3.7.1/dataLogDir 注意同时创建对应文件夹。其中端口号默认为2181，也可以进行修改。
二、 配置环境变量
1 2 3 # zookeeper export ZOOKEEPER_HOME=/usr/local/zookeeper3.7.1 export PATH=$PATH:$ZOOKEEPER_HOME/bin 接着通过source命令生效。
开启zookeeper连接 （前置条件是已配好java环境）
执行 zkServer.sh start即可。
查看连接情况： 1 2 3 4 5 6 zkServer.sh status ZooKeeper JMX enabled by default Using config: /usr/local/zookeeper3.7.1/bin/../conf/zoo.cfg Client port found: 2181. Client address: localhost. Client SSL: false. Mode: standalone 可见已经开启成功了。
客户端进行连接： 执行 zkCli.sh，连接成功后可查看：
1 2 3 [zk: localhost:2181(CONNECTED) 1] ls / [zookeeper] [zk: localhost:2181(CONNECTED) 2] get /zookeeper 编写springcloud服务代码 一、关于pom.</description>
    </item>
    
    <item>
      <title>Eureka配置过程与理解</title>
      <link>/posts/2022/07/eureka-configuration-process-and-understanding/</link>
      <pubDate>Sun, 17 Jul 2022 11:39:35 +0800</pubDate>
      
      <guid>/posts/2022/07/eureka-configuration-process-and-understanding/</guid>
      <description>前言 起到微服务注册中心的作用，满足分布式系统中的AP原则，是弱一致性的。
Eureka微服务架构图 服务接口采用集群模式，8001和8002端口都实现支付接口服务。 用户接口在运行在80端口，调用8001和8002的服务。 注册中心内部也采用集群模式，7001和7002端口都实现注册服务。 引入Eureka依赖说明 client端：
1 2 3 4 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; server端：
1 2 3 4 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 7001和7002端口关键配置内容 一、启动类开启注解
1 2 3 4 5 6 7 @SpringBootApplication @EnableEurekaServer public class EurekaMain7001 { public static void main(String[] args) { SpringApplication.run(EurekaMain7001.class, args); } } 二、application.yml文件配置
对于7001端口服务：（7002端口类似）
1 2 3 4 5 6 7 8 9 10 11 eureka: instance: hostname: eureka7001.com client: # false 表示不向注册中心注册自己 register-with-eureka: false # false 表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 fetch-registry: false service-url: # 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址 defaultZone: http://eureka7002.</description>
    </item>
    
    <item>
      <title>Linux展示性内容配置记录</title>
      <link>/posts/2022/07/linux-display-content-configuration-record/</link>
      <pubDate>Wed, 13 Jul 2022 21:21:50 +0800</pubDate>
      
      <guid>/posts/2022/07/linux-display-content-configuration-record/</guid>
      <description>Vim 1 2 3 4 5 vim /etc/vimrc set tabstop=4 # 修改vim中tab长度 set shiftwidth=4 # 修改vim自动缩进长度 set noeb vb t_vb= # 禁用vim蜂鸣声 1 2 3 vim /etc/inputrc set bell-style none # 禁用bash蜂鸣声 主机名称 1 2 3 hostnamectl hostnamectl set-hostname xxx 登录欢迎信息配置 1 vim /etc/update-motd.d 自行修改基本欢迎信息。
1 2 3 vim /etc/ssh/sshd_config PrintLastLog no 不打印上次登录信息。
命令提示符 1 2 3 vim ~/.bashrc export PS1=&amp;#34;[\u =&amp;gt; \w]\$ &amp;#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \a	铃声字符 \d	格式为“日 月 年”的日期 \e	ASCII 转义字符 \h	本地主机名 \H	完全合格的限定域主机名 \j	shell 当前管理的作业数 \1	shell 终端设备名的基本名称 \n	ASCII 换行字符 \r	ASCII 回车 \s	shell 的名称 \t	格式为“小时:分钟:秒”的24小时制的当前时间 \T	格式为“小时:分钟:秒”的12小时制的当前时间 \A	格式为“小时:分钟”的24小时制的当前时间 @	格式为 am/pm 的12小时制的当前时间 \s	shell的名字 \u	当前用户的用户名 \v	bash shell 的版本 \V	bash shell 的发布级别 \w	当前工作目录 \W	当前工作目录的基本名称 !</description>
    </item>
    
    <item>
      <title>《雪国》文摘</title>
      <link>/posts/2022/07/snow-country-abstract/</link>
      <pubDate>Tue, 12 Jul 2022 23:11:48 +0800</pubDate>
      
      <guid>/posts/2022/07/snow-country-abstract/</guid>
      <description>作者：川端康成
黄昏的景色在镜后移动着。也就是说，镜面映现的虚像与镜后的实物在晃动，好像电影里的叠影一样。出场人物和背景没有任何联系。而且人物是一种透明的幻象，景物则是在夜霭中的朦胧暗流，两者消融在一起，描绘出一个超脱人世的象征世界。特别是当山野里的灯火映照在姑娘的脸上时，那种无法形容的美，使岛村的心都几乎为之颤动。 在遥远的山巅上空，还淡淡地残留着晚霞的余晖。透过车窗玻璃看见的景物轮廓，退到远方，却没有消逝，但已经黯然失色。尽管火车继续往前奔驰，在他看来，山野那平凡的姿态显得更加平凡。由于什么东西都不十分惹他注目，他内心反而好像隐隐地存在着一股巨大的感情激流。这自然是由于镜中浮现出姑娘的脸的缘故。只有身影映在窗玻璃上的部分，遮住了窗外的暮景，然而，景色却在姑娘的轮廓周围不断地移动，使人觉得姑娘的脸也像是透明的。是不是真的透明呢？这是一种错觉。因为从姑娘面影后面不停地掠过的暮景，仿佛是从她脸的前面流过。定睛细看，却又扑朔迷离。 车厢里也不太明亮。窗玻璃上的映像，不像真的镜子那样清晰。没有反光。这使岛村看得入了神，他渐渐地忘却了镜子的存在，只觉得姑娘好像漂浮在流逝的暮景之中。 这当儿，姑娘的脸上闪现着灯光。镜中映像的清晰度并没有减弱窗外的灯火。灯火也没有把映像抹去。灯火就这样从她的脸上闪过，但并没有把她的脸照亮。这是一束从远方投来的寒光，模模糊糊地照亮了她眼睛的周围。她的眼睛同灯光重叠的那一瞬间，就像在夕阳的余晖里飞舞的夜光虫，妖艳而美丽。
岛村明白，自己从一开头就是想找这个女子，可偏偏和平常一样拐弯抹角，不免讨厌起自己来。与此同时，越发觉得这个女子格外的美。从刚才她站在杉树背后喊自己开始，他就感到这个女子的倩影是多么袅娜多姿啊。 玲珑而悬直的鼻梁，虽嫌单薄些，但在下方搭配着的小巧的紧闭的柔唇，却宛如美极了的水蛭环节，光滑而伸缩自如，在默默无言中也有一种动的感觉。如果嘴唇起了皱纹，或者色泽不好，就会显得不洁净。她的嘴唇却不是这样，而是滋润光泽的。两只眼睛，眼梢不翘起也不垂下，简直像有意描直了似的，虽逗人发笑，却恰到好处地镶嵌在两道微微下弯的浓密的短眉毛下。颧骨稍耸的圆脸，轮廓一般，但肤色恰似在白瓷上抹了一层淡淡的胭脂。脖颈底下的肌肉尚未丰满。她虽算不上是个美人，但比谁都要显得洁净。
岛村朝她望去，突然缩了缩脖子。镜子里白花花闪烁着的原来是雪。在镜中的雪里现出了女子通红的脸颊。这是一种无法形容的纯洁的美。 也许是旭日东升了，镜中的雪愈发耀眼，活像燃烧的火焰。浮现在雪上的女子的头发，也闪烁着紫色的光，更增添了乌亮的色泽。
玲珑而悬直的鼻梁，虽显得有点单薄，但双颊绯红，很有朝气，仿佛在窃窃私语：我在这里呢。那两片美丽而又红润的嘴唇微微闭上时，上面好像闪烁着红光，显得格外润泽。那樱桃小口纵然随着歌唱而张大，可是很快又合上，可爱极了，就如同她的身体具有的魅力一样。在微弯的眉毛下，那双外眼梢既不翘起，也不垂下，眼睛简直像有意描直了似的，如今滴溜溜的，带着几分稚气。她没有施白粉，都市的艺伎生活却给她留下惨白的肤色，而今天又渗入了山野的色彩，娇嫩得好像新剥开的百合花或是洋葱的球根，连脖颈也微微泛起了淡红，显得格外洁净无瑕。
火车开动之后，候车室里的玻璃窗豁然明亮起来，驹子的脸在亮光中闪闪浮现，眼看着又消失了。这张脸同早晨雪天映在镜中的那张脸一样，红扑扑的。在岛村看来，这又是介于梦幻与现实之间的另一种颜色。 火车从北面爬上县界的山，穿过长长的隧道，只见冬日下午淡淡的阳光，像被地底下的黑暗吞噬，又像那陈旧的火车把明亮的外壳脱落在隧道里，在重重叠叠的山峦之间，向暮色苍茫的峡谷驶去。山的这一侧还没有下雪。 沿着河流行驶不多久，来到了辽阔的原野，山巅好像精工的雕刻，从那里浮现出一道柔和的斜线，一直延伸到山脚下。山头上罩满了月色。这是原野尽头唯一的景色。淡淡的晚霞把整座山映成深宝蓝色，轮廓分明地浮现出来。月色还很淡，并不使人产生冬夜寒峭的感觉。天空没有一只飞鸟。山麓的原野，一望无垠，远远地向左右伸展，快到河边的地方，耸立着一座好像是水电站的白色建筑物。那是透过车窗望见的、在一片冬日萧瑟的暮色中仅留下来的景物。
村仿佛坐上了某种非现实的东西，失去了时间和距离的概念，陷入了迷离恍惚之中，徒然地让它载着自己的身躯奔驰。单调的车轮声，开始听的时候像是女子的絮絮话语。 这话语断断续续，而且相当简短，但它却是女子竭力争取生存的象征。他听了十分难过，以致难以忘怀。然而，对渐渐远去的岛村来说，现在这已经是徒增几许旅愁的遥远的声音了。
“银河，多美啊！” 驹子喃喃自语。她仰望着天空，又跑起来。 啊，银河！岛村也仰头叹了一声，仿佛自己的身体悠然飘上了银河当中。银河的亮光显得很近，像是要把岛村托起来似的。当年漫游各地的芭蕉￼，在波涛汹涌的海上所看见的银河，也许就像这样一条明亮的大河吧。茫茫的银河悬在眼前，仿佛要以它那赤裸裸的身体拥抱夜色苍茫的大地。真是美得令人惊叹。岛村觉得自己那小小的身影，反而从地面上映入了银河。缀满银河的星辰，耀光点点，清晰可见，连一朵朵光亮的云彩，看起来也像粒粒银沙子，明澈极了。而且，银河那无底的深邃，把岛村的视线吸引过去了。</description>
    </item>
    
    <item>
      <title>Swagger使用记录</title>
      <link>/posts/2022/06/swagger-usage-record/</link>
      <pubDate>Sat, 25 Jun 2022 21:20:38 +0800</pubDate>
      
      <guid>/posts/2022/06/swagger-usage-record/</guid>
      <description>依赖导入： 1 2 3 4 5 6 7 8 9 10 11 &amp;lt;!-- swagger所需依赖 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.6.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.6.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 配置Swagger /config/SwaggerConfig.java
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.withClassAnnotation(Api.class)) .paths(PathSelectors.any()) .build(); } // 基本信息的配置，信息会在api文档上显示 private ApiInfo apiInfo() { return new ApiInfoBuilder() .</description>
    </item>
    
    <item>
      <title>Window添加命令别名的方法</title>
      <link>/posts/2022/06/how-to-add-command-alias-in-window/</link>
      <pubDate>Fri, 24 Jun 2022 22:52:59 +0800</pubDate>
      
      <guid>/posts/2022/06/how-to-add-command-alias-in-window/</guid>
      <description>前言 下面将介绍3种方法：
CMD添加别名的方法 PowerShell添加别名的方法 通过添加环境变量的方式设置别名 CMD添加别名的方法 设置临时的别名 可以通过doskey命令实现。
1 doskey ls=echo ====== ^&amp;amp;^&amp;amp; dir /b $* ^&amp;amp;^&amp;amp; echo ====== $*表示还可能有其他命令参数，^&amp;amp;^&amp;amp;用于分开多条命令。
单纯在一个cmd窗口中使用doskey设置别名，别名只能在该窗口中使用。
设置永久的别名 可以通过将doskey命令写入bat脚本，再把脚本路径添加到注册表Autorun实现永久且所有cmd都可用的别名，具体步骤如下：
编写脚本： 1 2 3 @echo off doskey ls=dir /b $* doskey lss=echo ====== ^&amp;amp;^&amp;amp; dir /b $* ^&amp;amp;^&amp;amp; echo ====== 添加路径到注册表 在HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor下的Autorun中，将数值设为doskey命令脚本所在的路径即可。这样所有用户都可以使用设置好的别名。
也可在HKEY_CURRENT_USER下的对应位置设置，只针对当前用户设置别名。
优缺点 通过doskey的方式，挺方便的，但是在命令非常多的情况下不是很方便，同时，设置的命令还不可以在powershell下运行。
PowerShell添加别名的方法 为PowerShell设置临时的别名 1 2 3 PS C:\Users\akyna&amp;gt; set-alias escc esc PS C:\Users\akyna&amp;gt; escc ...... 如果带参数，则可以通过function进行：
1 2 3 PS C:\Users\akyna&amp;gt; function func{nircmd emptybin} PS C:\Users\akyna&amp;gt; set-alias ctrash func PS C:\Users\akyna&amp;gt; ctrash 这样的别名只是在当前会话下有效，开启另一个shell就失效了。</description>
    </item>
    
    <item>
      <title>SpringBoot邮箱服务</title>
      <link>/posts/2022/06/springboot-mailbox-service/</link>
      <pubDate>Thu, 16 Jun 2022 21:13:15 +0800</pubDate>
      
      <guid>/posts/2022/06/springboot-mailbox-service/</guid>
      <description>一、导入依赖： 1 2 3 4 5 &amp;lt;!--发送邮件--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-mail&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 二、配置文件： QQ邮箱需要先开通好邮箱SMTP服务。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 spring: # 邮件服务 mail: password: xxxxxx username: xxx@qq.com host: smtp.QQ.com properties: mail: smtp: auth: true starttls: enable: true required: true default-encoding: UTF-8 三、编写邮件服务 sendSimpleMailMessage()实现只含普通文本信息的邮件发送 sendMimeMessage()可以发送带附件的邮件 MailService.java
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @Service public class MailService { private final JavaMailSender mailSender; @Value(&amp;#34;${spring.</description>
    </item>
    
    <item>
      <title>Quartz实现定时任务</title>
      <link>/posts/2022/06/quartz-implements-timed-tasks/</link>
      <pubDate>Wed, 15 Jun 2022 21:11:27 +0800</pubDate>
      
      <guid>/posts/2022/06/quartz-implements-timed-tasks/</guid>
      <description>一、添加注解 主启动类添加@EnableScheduling注解；
二、添加依赖： 1 2 3 4 5 &amp;lt;!--定时任务 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-quartz&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 三、创建任务 /TestTask1.java
1 2 3 4 5 6 7 public class TestTask1 extends QuartzJobBean { @Override protected void executeInternal(JobExecutionContext context) { SimpleDateFormat sdf = new SimpleDateFormat(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;); System.out.println(&amp;#34;Test1---&amp;#34; + sdf.format(new Date())); } } /TestTask2.java
1 2 3 4 5 6 7 public class TestTask2 extends QuartzJobBean { @Override protected void executeInternal(JobExecutionContext context) { SimpleDateFormat sdf = new SimpleDateFormat(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;); System.</description>
    </item>
    
    <item>
      <title>使用x86_64汇编写一个自旋锁</title>
      <link>/posts/2022/06/use-x86-64-assemble-and-write-a-spin-lock/</link>
      <pubDate>Thu, 09 Jun 2022 23:37:51 +0800</pubDate>
      
      <guid>/posts/2022/06/use-x86-64-assemble-and-write-a-spin-lock/</guid>
      <description>一、理论分析 自旋锁，顾名思义，即自己不断旋转重复进行的锁，当多个线程访问同一资源时，为实现互斥访问，必须给目标资源加锁，此时只允许一个线程访问，此时其他线程无法访问，并且一直重复请求访问，直到该锁被释放。访问完资源的线程及时释放锁以供其他资源访问。
自旋锁可以通过比较替换算法实现：设锁为1时被占用，为0时空闲。当一个线程请求锁时，即进入请求锁循环“spinlock”，设预期值为0，修改值为1，让锁值与预期值比较，若锁值等于预期值，则锁空闲，将锁值置为修改值，退出spinlock循环；若锁值不等于预期值，则证明锁被占用，继续spinlock循环。
为验证是否成功实现自旋，开启一个释放锁线程，请求锁线程自旋一段时间后，释放锁线程进行锁的释放，即把锁值置为预期值0。此时，请求锁线程成功获得锁并退出spinlock循环。
二、设计与实现 使用x86_64汇编实现自旋锁：
Intel语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 尝试获取锁 void lock(long *p) { long a = 0, c = 1; printf(&amp;#34;try to get lock...\n&amp;#34;); __asm__( &amp;#34;push rax \n\t&amp;#34; &amp;#34;push rcx \n\t&amp;#34; &amp;#34;spin_lock: \n\t&amp;#34; &amp;#34;mov rcx, %[c] \n\t&amp;#34; &amp;#34;mov rax, %[a] \n\t&amp;#34; // 比较并替换算法，若p==rax==0则获得锁并使p=rcx(==1)，若p(==1)!=rax则进入自旋。 &amp;#34;lock cmpxchg %[p], rcx \n\t&amp;#34; &amp;#34;jne spin_lock \n\t&amp;#34; &amp;#34;pop rcx \n\t&amp;#34; &amp;#34;pop rax \n\t&amp;#34; : [p]&amp;#34;+m&amp;#34;(*p) : [a]&amp;#34;r&amp;#34;(a), [c]&amp;#34;r&amp;#34;(c) : &amp;#34;rcx&amp;#34;, &amp;#34;rax&amp;#34; ); } // 释放锁 void unlock(long *p) { __asm__( &amp;#34;mov %[p], 0; \n\t&amp;#34; : [p]&amp;#34;+m&amp;#34;(*p) ); } AT&amp;amp;T语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void lock(long *p) { long a = 0, c = 1; printf(&amp;#34;try to get lock.</description>
    </item>
    
    <item>
      <title>通过Wireshark分析TCP原理</title>
      <link>/posts/2022/06/analyze-tcp-principle-through-wireshark/</link>
      <pubDate>Thu, 09 Jun 2022 23:18:55 +0800</pubDate>
      
      <guid>/posts/2022/06/analyze-tcp-principle-through-wireshark/</guid>
      <description>使用Wireshark作为抓包工具，通过ftp文件上传过程分析tcp原理，主要分析过程包括三次握手建立连接的过程，文件传输的过程，四次挥手断开连接的过程。
设备信息 主机：安装了ftp的window11（ip:172.23.224.1） 虚拟机：安装了vsftpd的wsl2（ubuntu18）(ip:172.23.234.65) 操作与分析过程 打开Wireshark进行捕获 选择**vEthernet(WSL)**连接进行捕获。 使用过滤表达式ip.addr==172.23.234.65&amp;amp;&amp;amp;tcp进行捕获。 通过ftp上传文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PS C:\Users\akyna&amp;gt; ftp 172.23.234.65 连接到 172.23.234.65。 220 (vsFTPd 3.0.3) 200 Always in UTF8 mode. 用户(172.23.234.65:(none)): akyna 331 Please specify the password. 密码: 230 Login successful. ftp&amp;gt; put a.txt 200 PORT command successful. Consider using PASV. 150 Ok to send data. 226 Transfer complete. ftp: 发送 42 字节，用时 0.</description>
    </item>
    
    <item>
      <title>乙一短篇摘录</title>
      <link>/posts/2022/06/yi-short-excerpt/</link>
      <pubDate>Mon, 06 Jun 2022 22:00:13 +0800</pubDate>
      
      <guid>/posts/2022/06/yi-short-excerpt/</guid>
      <description>七个房间 ——黑乙一
“我小的时候，常在老家旁边的小溪玩耍。”
据她说那是一条连溪底的石头都看得到的清澈溪流。我听着她的话，想象着犹如梦幻世界一般的那条小溪。摇摇晃晃的水面反射着太阳光，细碎的光芒闪耀着，那是一个非常明亮的世界，头顶万里无云，晴空没有尽头，仿佛自己的身体违反了重力，不断地往上再往上被吸进去似的，无边无际。
我好像开始习惯被关进的这个阴郁狭窄的水泥房间、从水沟中飘来的腐臭，以及被灯泡一照反而突显的黑暗。我开始忘记进来这里之前所待过的普通世界了。想起外面吹拂着风的世界，我不禁难过起来。
我想看天空。之前我从未有过如此强烈的渴望，被关进来之前，为什么没有多花些时间好好地眺望云朵呢？
走过地下走廊，我们看见了一道往上的楼梯。爬到楼梯顶就是阳光灿烂的外面世界了。我们终于逃离了那个昏暗忧郁、被寂寞支配的房间。
我的眼泪掉个不停。我的脖子上挂着十字架项链，手拿着那本写着向父母道歉文章的记事本。我的手腕上挂着姐姐的遗物——那只手表。因为不是防水的表，大概在我躲进水里的时候坏掉了吧，指针恰好指着傍晚六点，停止了走动。
向阳之诗 ——白乙一
我呜咽着继续说道：“……我恨你。”
为什么要把我制造出来呢？如果我不曾诞生到这个世界喜欢上任何事物，也就不会恐惧“死亡”所带来的别离了。
虽然我已经几乎泣不成声，躺在工作台上，我还是挤出了这些话：
“我……很喜欢你，但我却必须埋葬你的遗体，这太痛苦了。如果非得这么痛苦，那我宁可不要心这种东西。我恨你，我恨你在制造我的时候，帮我装了心……”
窗外传来了鸟鸣。我闭上眼睛，想象着数只鸟儿飞翔在蓝天的画面。合上眼帘，一直在眼眶打转的泪水便落了下来。
“但现在，我对你只有满满的感谢。如果不曾诞生到这个世界，我就无法看见小丘上辽阔的草原；如果当初你没有为我装上心，我就无法体会望向鸟巢时的愉悦，也不会因为咖啡的苦涩而皱眉了。能够这样一一地去碰触世界的光辉，是多么宝贵的事情啊！一想到这里，即使内心深处因为悲伤而淌着血，我都能够把那视为证明我活着的最最珍贵的证据……”
同时抱着感谢和憎恨的感情，或许很奇怪吧？然而，我就是这么想的。我相信大家一定都是如此。在很久以前便灭绝的人类的孩子们，对自己的父母一定也是同样怀抱着类似的矛盾情绪活下去的，不是吗？
我们都是一边学习着爱与死亡，往来于世界的向阳处与阴暗处活下去的，不是吗？
于是孩子们逐渐成长。这次，将轮到自己背负在这个世界创造出新生命的宿命，不是吗？
我会在那座小丘上伯父长眠地的旁边掘坑；我会让你睡在里面，像是替你盖上棉被一般为你覆上泥土；我会替你立上木制的十字架，将水井边盛开的花草种在墓前；每天早上我都会去跟你道早安，到了傍晚再去向你报告这一天发生了什么。
长椅上，时间静静地流逝，正午将近。我耳中听着他体内的马达声逐渐减弱，终至再也听不见。好好安息吧。我在心中轻轻地对他说。</description>
    </item>
    
    <item>
      <title>海子的诗</title>
      <link>/posts/2022/05/haizis-poems/</link>
      <pubDate>Mon, 30 May 2022 20:11:37 +0800</pubDate>
      
      <guid>/posts/2022/05/haizis-poems/</guid>
      <description>九月 目击众神死亡的草原上野花一片
远在远方的风比远方更远
我的琴声呜咽 泪水全无
我把这远方的远归还草原
一个叫马头 一个叫马尾
我的琴声呜咽 泪水全无 远方只有在死亡中凝聚野花一片
明月如镜高悬草原映照千年岁月
我的琴声呜咽 泪水全无
只身打马过草原
晨雨时光 小马在草坡上一跳一跳
这青色麦地晚风吹拂
在这个时刻 我没有想到
五盏灯竟会同时亮起
青麦地像马的仪态 随风吹拂
五盏灯竟会一盏一盏地熄灭
往后 雨会下到深夜 下到清晨
天色微明
山梁上定会空无一人
不能携上路程
当众人齐集河畔 空声歌唱生活
我定会孤独返回空无一人的山峦
西藏 西藏，一块孤独的石头坐满整个天空
没有任何夜晚能使我沉睡
没有任何黎明能使我醒来
一块孤独的石头坐满整个天空
他说：在这一千年里我只热爱我自己
一块孤独的石头坐满整个天空
没有任何泪水使我变成花朵
没有任何国王使我变成王座
面朝大海，春暖花开 从明天起，做一个幸福的人
喂马，劈柴，周游世界
从明天起，关心粮食和蔬菜
我有一所房子，面朝大海，春暖花开
从明天起，和每一个亲人通信
告诉他们我的幸福
那幸福的闪电告诉我的
我将告诉每一个人 给每一条河每一座山取一个温暖的名字
陌生人，我也为你祝福
愿你有一个灿烂的前程
愿你有情人终成眷属
愿你在尘世获得幸福
我只愿面朝大海，春暖花开</description>
    </item>
    
    <item>
      <title>《1984》文摘</title>
      <link>/posts/2022/05/1984-abstracts/</link>
      <pubDate>Thu, 19 May 2022 20:22:22 +0800</pubDate>
      
      <guid>/posts/2022/05/1984-abstracts/</guid>
      <description>作者：乔治·奥威尔
第6章 温斯顿把手垂到身边，缓慢地将肺部又吸满空气，他的大脑滑向一个双重思想的迷宫世界。知道又不知道；明白全部事实，却说着精心编造的谎言；
同时拥有两种针锋相对的意见，一方面知道两者之间的矛盾，一方面又两者都相信；
利用逻辑来反逻辑；
一方面批判道德，一方面又自认为有道德；
相信不可能有民主，另一方面又相信党是民主的保卫者；
忘掉一切需要忘记的，然后随时在需要记起时再回想起来，接着马上再忘掉——最重要的是，对这个过程本身，也要照此处理。
最奥妙之处在于：要清醒地诱导自己进入不清醒状态，然后再次意识不到刚刚对自己实行的催眠行为。
甚至理解“双重思想”这个词，也要用到双重思想。
第10章 除非他们觉醒，否则永远不会反抗；但除非他们反抗，否则不会觉醒。
第12章 一定要捍卫显而易见、质朴和真实的一切，不言而喻的就是真实的，在这一点上不可动摇！
实体世界是存在的，其定律不可改变。石头是硬的，水是湿的，缺少支撑的物体会向地心方向坠落。
怀着这种感觉，他是在向奥布兰说话，同时也在提出一条重要的公理。
他写道：自由就是说二加二等于四的自由。若此成立，其他同理。
第19章 温斯顿在床上又待了几分钟。房间内正在变暗，他往光亮处挪了一点，盯着看那块玻璃镇纸。它让人百看不厌之处，不是珊瑚，而是玻璃内部。它很厚，但又几乎像空气一样透明。那块玻璃的表面像天空的穹顶，包容了一个小小的世界，各种特点无不具备。他感觉能够进入其中，而实际上他已经身处其中，跟那张红木床、折叠桌还有钢雕版画及镇纸本身一起都在其中。镇纸就是他所在的房间，珊瑚是茱莉娅和他自己的生命，被固定在清澈透明的玻璃中心，并成为一种永恒之物。
第28章 “双重思想”意味着在一个人的脑子里，同时拥有两种相互矛盾的信念，而且两种都接受。党的知识分子明白他的记忆必须往哪个方向改变，因此他知道自己在玩弄现实，然而通过实行“双重思想”，也能让他心安理得地认为现实不曾被改变。
这个过程一定要有意识地进行，否则过程中精确度就不够；而且它也一定要无意识地进行，否则会带来一种做伪的感觉，因而会有罪过感。
“双重思想”是英社的核心，因为党最基本的行为，是进行有意识的欺骗，同时又保持目的的坚定性，那需要绝对诚实。讲着别有用心的谎言，同时又真心实意相信这些谎言；忘掉一切变得有碍的行为，然后一旦再次需要，又从遗忘中拣回来；否认客观现实的存在，同时又考虑到被否认的现实——这些都缺一不可。甚至在使用“双重思想”这个词时，也需要进行“双重思想”。因为使用这个词时，是承认在篡改现实，通过再来一次“双重思想”，就会清除这种认识，如此循环不已，谎言总跨在真实的前面。
最终以“双重思想”为手段，党就能够——我们都明白，可能在几千年内仍然能够——左右历史进程。
作为少数派，即使是一个人的少数派，也并不能说明你疯了。世界上存在着真理和非真理，如果你坚守的是真理，即使要跟整个世界对抗，你也不会是疯的。正在下沉的夕阳把一缕黄色光线从窗户斜射进来，照在枕头上。他闭上眼睛，照在脸上的阳光和挨着他的那个女孩的光滑躯体给了他一种强烈的、催人欲睡的、自信的感觉。他是安全的，一切正常。他嘴里咕哝着“理智不是个统计学概念”就睡着了，他觉得这句话蕴藏了深刻的智慧。
第29章 每个人来说，天空都是同样的天空，无论在欧亚国或者东亚国或者这里。天空下的人们也几乎完全一样——在所有地方，包括全世界，有着上亿跟这里一样的人们，他们对彼此的存在一无所知，被仇恨和谎言之墙所隔，但仍然几乎完全一样。他们从未学会思考，但正是在他们的心里、肚子里和肌肉里，储备着某一天将推翻这个世界的力量。如果有希望，它就在群众身上！</description>
    </item>
    
    <item>
      <title>Java复习记录（一）</title>
      <link>/posts/2022/05/java-review-1/</link>
      <pubDate>Sun, 15 May 2022 15:15:51 +0800</pubDate>
      
      <guid>/posts/2022/05/java-review-1/</guid>
      <description>JDK JRE JVM 关系 为什么说 Java 语言“编译与解释并存”？ 高级编程语言按照程序的执行方式分为编译型和解释型两种。
编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码，不能跨平台。
解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行，一次编写，到处执行。
Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤。
由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须再经过 JVM，解释成操作系统能识别的机器码，在由操作系统执行。
因此，我们可以认为 Java 语言编译与解释并存。
重载（overload）和重写（override）的区别？ 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。
重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；
重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。
方法重载的规则：
方法名一致，参数列表中参数的顺序，类型，个数不同。 重载与方法的返回值无关，存在于父类和子类，同类中。 可以抛出不同的异常，可以有不同修饰符。 抽象类(abstract class)和接口(interface)有什么区别？ 接口的方法默认是public，所有方法在接口中不能有实现(Java8开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
接口中除了static、final变量，不能有其他变量，而抽象类中则不⼀定。
⼀个类可以实现多个接口，但只能实现⼀个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰）。
从设计层面来说，抽象是对类的抽象，是⼀种模板设计，而接口是对行为的抽象，是⼀种行为的规范。
注意jdk7~jdk9中接口的变化：
在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。 jdk 8 的时候接口可以有默认方法和静态方法功能。 jdk 9 在接口中引⼊了私有方法和私有静态方法 try和finally中的return 若try中有return，而finally中无return，会先将值暂存，无论finally语句中对该值做什么处理，最终返回的都是try语句中的暂存值。另外，finally语句中执行的语句先于try的return之前执行。
当try与finally语句中均有return语句，会忽略try中return，执行finally的return。注意如果try的return语句是return ++x，则++x是会执行的。
验证如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class TryReturnTest { public int test1(int x) { try { x += 1; return ++x; } catch (Exception e) { e.</description>
    </item>
    
    <item>
      <title>《挪威的森林》中的披头士</title>
      <link>/posts/2022/05/the-beatles-in-norwegian-forest/</link>
      <pubDate>Sat, 14 May 2022 11:47:43 +0800</pubDate>
      
      <guid>/posts/2022/05/the-beatles-in-norwegian-forest/</guid>
      <description>“飞机一着陆，禁烟显示牌倏然消失，天花板扩音器中低声流出背景音乐，那是一个管弦乐队自鸣得意地演奏的甲壳虫乐队的《挪威的森林》。那旋律一如往日地使我难以自已，不，比往日还要强烈地摇撼着我的身心。
《挪威的森林》—— Norwegian Wood “她一边这样说着，一边弹起《米歇尔》，弹得极其精彩。“好曲子，我，无比喜欢！”说完，玲子喝了一口葡萄酒，吸了口烟，“简直就像霏霏细雨轻轻洒在无边无际的草原。”
《米歇尔》—— Michelle “接着，她弹了《没有归宿的人》，弹了《朱丽娅》。有时边弹边闭上眼摇着头，然后又呷口酒吸口烟。
《没有归宿的人》—— Nowhere Man 《朱丽娅》—— Julia “店里的女孩说，如果肯弹甲壳虫乐队的《太阳从这里升起》，冷藏牛奶可算店里请客。玲子伸出拇指，做出OK的表示，随即边哼歌词边弹《太阳从这里升起》。音量并不大，而且大概由于过度吸烟的关系，嗓音有些沙哑，但很有厚度，娓娓动人。我喝着啤酒，望着远山，耳听她的歌声，恍惚觉得太阳会再次从那里探出脸来，那心境实在太温馨、太平和了。
《太阳从这里升起》—— Here Comes The Sun ““我也喜爱，非常委婉感人。”她又轻轻弹了几小节《宝贝儿》的旋律，呷了口葡萄酒。“喝醉之前能弹上几首呢。嗯，这样的葬礼不凄凉，还可以吧？”玲子转向甲壳虫。弹了《挪威的森林》，弹了《昨日》，弹了《米歇尔》，弹了《有一件事》，边唱边弹了《太阳从这里升起》，弹了《山峰上的傻子》。我排出了七根火柴。
《昨日》—— Yesterday 《有一件事》—— Something 《山峰上的傻子》—— The Fool On The Hill ““七首，”玲子说着，呷口酒，吸口烟。“这几个人对人生的伤感和温情确实深有体会啊。”这几个人当然是Ｊ．列农、Ｐ．麦卡特尼，加上Ｇ．哈里森。她换了口气，熄掉烟，又抱起吉他。弹了《细雨》，弹了《黑鸟》，弹了《朱莉娅》，弹了《年届六十四》，弹了《没有归宿的人》，弹了《而且我爱她》，弹了《喂，乔德》。
《细雨》—— Penny Lane 《黑鸟》—— Black Bird 《年届六十四》—— When I&amp;rsquo;m Sixty Four 《而且我爱她》—— And I Love Her 《喂，乔德》—— Hey, Jude “我放上唱片，第一张听完便把唱针移到第二张。全部听完之后，又从头听起。唱片只有六张。第一张是《佩珀军士寂寞的心俱乐部乐队》，最后是比尔·埃文斯的《献给黛比的华尔兹》。窗外雨下个不停，时间缓缓流逝，直子一个人絮絮不止。
《佩珀军士寂寞的心俱乐部乐队》—— Sgt. Pepper&amp;rsquo;s Lonely Hearts Club Band </description>
    </item>
    
    <item>
      <title>《杀死一只知更鸟》文摘二</title>
      <link>/posts/2022/05/kill-a-mockingbird-digest-ii/</link>
      <pubDate>Mon, 09 May 2022 11:34:32 +0800</pubDate>
      
      <guid>/posts/2022/05/kill-a-mockingbird-digest-ii/</guid>
      <description>作者：哈珀·李
第十一章 “勇敢就是，在你还没开始的时候就知道自己注定会输，但依然义无反顾地去做，并且不管发生什么都坚持到底。一个人很少能赢，但也总会有赢的时候。杜博斯太太赢了，全凭她那九十八磅重的身躯。用她的话来说，她死得无牵无挂，不亏欠任何人，也不依赖任何东西。她是我见过的最勇敢的人。”
第二十章 “我们都知道，某些人灌输给我们的‘人人生而平等’，实际上是个谬论——事实上，有些人就是比别人聪明睿智，有些人就是比别人享有更多的机会，因为他们生来如此，有些男人比别的男人挣钱多，有些女士做的蛋糕比别的女士更胜一筹——总而言之，有些人天生就比大多数普通人具有更高的天赋和才华。”
“但是，在这个国家里，从某种意义上来说，一切人是生来平等的——有一种人类社会机构，可以让乞丐和洛克菲勒家族的成员平起平坐，让愚人和爱因斯坦不分尊卑，让粗陋无知的人和大学校长分庭抗礼。先生们，这种机构，就是法庭——可以是美国联邦政府的最高法庭，可以是最基层的地方治安法庭，也可以是你们眼下服务的这个尊贵而神圣的法庭。我们的法庭也有缺陷，任何社会机构都不例外，但是，在这个国家里，我们的法庭是伟大的平等主义者。在我们的法庭里，人人生而平等。”
第三十一章 我心想，如果是在日光下，从这儿能一眼望到邮局所在的街角。在明亮的日光下……夜晚被我的想象驱散了，现在是大白天，整个街区的人都在忙忙碌碌。斯蒂芬妮小姐正穿过街道，把最新消息告诉雷切尔小姐。莫迪小姐正弯着腰伺弄她心爱的杜鹃花。这是夏天，两个孩子在人行道上连蹦带跳，上前去迎接从远处走来的一个男人。那个男人挥了挥手，于是两个孩子你追我赶，互不相让，朝他一路跑去。
时间依然是夏天，孩子们走近了。男孩踯躇不前，身后拖着一根鱼竿。男人两手叉腰，站在那里等他。
还是在夏天，他的孩子们在前院里和朋友一起玩耍，自编自演着一出莫名其妙的小话剧。
秋天，他的两个孩子在杜博斯太太家门前的人行道上打架。男孩把妹妹从地上扶起来，两人一起走回家去。
那个秋天，他的两个孩子一路小跑，来来回回经过那个街角，一天的烦恼和欣喜都写在脸上。他们在一棵大橡树跟前停下脚步，脸上闪过惊喜，困惑，还有点儿惶恐不安。
冬天，他的两个孩子在院门前冻得哆里哆嗦，一座房子在熊熊燃烧，火光映照出他们小小的侧影。
依然是在冬天，那个男人走上街道，扔下自己的眼镜，开枪射死了一条疯狗。
又是一个夏天，他眼看着孩子们心碎欲裂。
又到了秋天，怪人的小伙伴需要他挺身相助。
阿迪克斯说的没错。有一回他告诉我，你永远也不可能真正了解一个人，除非你穿上他的鞋子走来走去，站在他的角度考虑问题。对我来说，站在拉德利家的前廊上就足够了。</description>
    </item>
    
    <item>
      <title>《杀死一只知更鸟》文摘一</title>
      <link>/posts/2022/05/kill-a-mockingbird-digest-1/</link>
      <pubDate>Mon, 09 May 2022 11:25:47 +0800</pubDate>
      
      <guid>/posts/2022/05/kill-a-mockingbird-digest-1/</guid>
      <description>作者：哈珀·李
第九章 “杰克！看在老天的分上，当一个孩子问你问题的时候，你要正儿八经地回答，不要东拉西扯，顾左右而言他。虽说孩子毕竟只是孩子，但他们会比成人更敏锐地察觉到你在回避问题，回避只会让他们糊里糊涂。”
父亲沉吟着说道，“今天下午你的回应是对的，但你的理由有偏差。说脏话是所有孩子都会经历的一个阶段，随着他们一天天长大，他们会发现满口脏话并不能让他们成为众人瞩目的明星，他们就会改掉这个毛病。但是脾气暴躁可不好改。斯库特必须学会保持冷静，接下来的几个月里她还会经历很多事情，所以她必须尽快学会冷静面对。当然，她也在成长。杰姆长大了，她现在也能跟着学学样子。她只是在某些时候需要有人推一把。”
第十章 阿迪克斯送给我们两杆气枪之后，却不肯教我们如何射击。还是杰克叔叔教给了我们基本要领，他说阿迪克斯对枪压根儿就不感兴趣。有一天，阿迪克斯对杰姆说：“我宁愿让你们在后院射易拉罐，不过我知道，你们肯定会去打鸟。你们射多少冠蓝鸦都没关系，只要你们能打得着，但要记住一点，杀死一只知更鸟便是犯罪。”
杰姆说：“我觉得，如果他想让我们知道，早就告诉我们了。如果他以此为豪，早就跟我们说了。”
“也许他只是没想起来。”
“不是，斯库特。这个你不懂。阿迪克斯确实老了，不过，即使他什么也做不来我也不在乎———他一件事儿都做不来我也不在乎。” 杰姆捡起一块石头朝车库扔去，一副喜不自胜的样子。他欢跳着追了过去，又回头冲我喊道：“阿迪克斯是个绅士，跟我一样！”
第十一章 “哦，大多数人好像都认为他们是对的，你是错的……”
“他们当然有权利那样想，他们的看法也有权得到充分的尊重，” 阿迪克斯说，“但是，我在接受他人之前，首先要接受自己。有一种东西不能遵循从众原则，那就是人的良心。”
“斯库特，”阿迪克斯说，“‘同情黑鬼的人’只是一种毫无意义的称呼，跟‘鼻涕虫’一样。这很难解释清楚——有些愚昧无知的人认为有人关爱黑人胜过关爱他们，就用这个词来称呼。这个词不知不觉也成了和我们一样的普通人的日常用语，用来给人打上卑贱、丑陋的标签。”
“那你并不真的是‘同情黑鬼的人’，对吗？”
“我当然同情黑人。我尽自己所能去爱每一个人……有时候我也很为难——宝贝儿，如果别人把那当成一个侮辱性的字眼来骂你，并不能贬损你的人格。那只能让你看到，骂你的人有多可悲，他的谩骂并不能伤害到你。所以别让杜博斯太太影响你的情绪。她自己的麻烦事儿已经够多的了。”</description>
    </item>
    
    <item>
      <title>《论持久战》文摘</title>
      <link>/posts/2022/04/abstract-of-on-protracted-war/</link>
      <pubDate>Thu, 28 Apr 2022 20:27:08 +0800</pubDate>
      
      <guid>/posts/2022/04/abstract-of-on-protracted-war/</guid>
      <description>作者：毛泽东
战争问题中的唯心论和机械论的倾向，是一切错误观点的认识论上的根源。他们看问题的方法是主观的和片面的。或者是毫无根据地纯主观地说一顿；或者是只根据问题的一侧面、一时候的表现，也同样主观地把它夸大起来，当作全体看。
革命战争是一种抗毒素，它不但将排除敌人的毒焰，也将清洗自己的污浊。凡属正义的革命的战争，其力量是很大的，它能改造很多事物，或为改造事物开辟道路。
中日战争将改造中日两国；只要中国坚持抗战和坚持统一战线，就一定能把旧日本化为新日本，把旧中国化为新中国，中日两国的人和物都将在这次战争中和战争后获得改造。我们把抗战和建国联系起来看，是正当的。说日本也能获得改造，是说日本统治者的侵略战争将走到失败，有引起日本人民革命之可能。日本人民革命胜利之日，就是日本改造之时。这和中国的抗战密切地联系着，这一个前途是应该看到的。
这就是所谓“唯武器论”，是战争问题中的机械论，是主观地和片面地看问题的意见。我们的意见与此相反，不但看到武器，而且看到人力。武器是战争的重要的因素，但不是决定的因素，决定的因素是人不是物。力量对比不但是军力和经济力的对比，而且是人力和人心的对比。军力和经济力是要人去掌握的。
政治是不流血的战争，战争是流血的政治。
错觉和不意，可以丧失优势和主动。因而有计划地造成敌人的错觉，给以不意的攻击，是造成优势和夺取主动的方法，而且是重要的方法。错觉是什么呢？ “八公山上，草木皆兵”，是错觉之一例。“声东击西”，是造成敌人错觉之一法。
在优越的民众条件具备，足以封锁消息时，采用各种欺骗敌人的方法，常能有效地陷敌于判断错误和行动错误的苦境，因而丧失其优势和主动。“兵不厌诈”，就是指的这件事情。什么是不意？就是无准备。优势而无准备，不是真正的优势，也没有主动。懂得这一点，劣势而有准备之军，常可对敌举行不意的攻势，把优势者打败。
我们说运动之敌好打，就是因为敌在不意即无准备中。这两件事——造成敌人的错觉和出以不意的攻击，即是以战争的不确实性给予敌人，而给自己以尽可能大的确实性，用以争取我之优势和主动，争取我之胜利。</description>
    </item>
    
    <item>
      <title>《挪威的森林》文摘四</title>
      <link>/posts/2022/04/norwegian-forest-digest-4/</link>
      <pubDate>Mon, 25 Apr 2022 20:39:14 +0800</pubDate>
      
      <guid>/posts/2022/04/norwegian-forest-digest-4/</guid>
      <description>第十一章 在辗转反侧的不眠之夜，我想起直子的种种音容笑貌，不容我不想起。因为我心里关于直子的记忆堆积如山，只要稍稍开启一点缝隙，它们便争先恐后，鼓涌而出，而我根本无法遏止其突发的攻势。
就是这样，直子的形象如同汹涌而来的潮水向我联翩袭来，将我的身体冲往奇妙的地带。在这奇妙地带里，我同死者共同生活。直子也在这里活着，同我交谈，同我拥抱。在这个地方，所谓死，并非是使生完结的决定性因素，而仅仅是构成生的众多因素之一。直子在这里仍在含有死的前提下继续生存，并且对我这样说：“不要紧，渡边君，那不过是一死罢了，别介意。”
木月死时，我从他的死中学到一个道理，并将其作为大彻大悟的人生真谛铭刻或力图铭刻在心。那便是：“死并非生的对立面，死潜伏在我们的生之中。”
实际也是如此。我们通过生而同时培育了死，但这仅仅是我们必须懂得的哲理的一小部分。而直子的死还使我明白：无论谙熟怎样的哲理，也无以消除所爱之人的死带来的悲哀。无论怎样的哲理，怎样的真诚，怎样的坚韧，怎样的柔情，也无以排遣这种悲哀。
我们惟一能做到的，就是从这片悲哀中挣脱出来，并从中领悟某种哲理。而领悟后的任何哲理，在继之而来的意外悲哀面前，又是那样软弱无力——我形影相吊地倾听这暗夜的涛声和风鸣，日复一日地此冥思苦索。我喝光了几瓶威士忌，啃着面包，喝着水筒里的水，满头沙子，背负旅行背囊，踏着初秋的海岸不断西行、西行。
这是初秋一个天朗气清的午后——同恰好一年前我去京都探望直子时一模一样。云如枯骨，细细白白，长空寥廓，似无任何遮拦。又是一个秋天，我想。风的气息，光的色调，草丛中点缀的小花，一个音节留下的回响，无不告知我秋天的到来。四季更迭，我与死者之间的距离亦随之渐渐拉开。木月照旧十七，直子依然二十一，永远地。
“假如你对直子的死怀有一种类似创痛之感，那么就把这种创痛留给以后的人生，在整个后半生中去体会。如若可以学习到什么，那就要从中学习。不过绿子另当别论，你要和她去寻求幸福。你的创痛与绿子无关。如果你还要伤她的心，势必导致无可挽回的后果。因此，尽管你可能心里难受，也还是要坚强起来，要再成熟一些，成为大人。我就是为了对你说这番话，才特意从疗养院跑来这里——大老远地坐着那棺材样的电车。”
我给绿子打去电话，告诉她：自己无论如何都想跟她说话，有满肚子话要说，有满肚子非说不可的话。整个世界上除了她别无他求。想见她想同她说话，两人一切从头开始。 绿子在电话的另一头久久默然不语，如同全世界所有的细雨落在全世界所有的草坪上一般的沉默在持续。这时间里，我一直合着双眼，把额头顶在电话亭玻璃上。
良久，绿子用沉静的声音开口道：“你现在哪里？”
我现在哪里？
我拿着听筒扬起脸，飞快地环视电话亭四周。我现在哪里？我不知道这里是哪里，全然摸不着头脑。这里究竟是哪里？目力所及，无不是不知走去哪里的无数男男女女。我在哪里也不是的场所的正中央，不断地呼唤着绿子。</description>
    </item>
    
    <item>
      <title>Window实用命令记录之进程与网络控制</title>
      <link>/posts/2022/04/process-and-network-control-of-window-practical-command-recording/</link>
      <pubDate>Mon, 18 Apr 2022 23:10:39 +0800</pubDate>
      
      <guid>/posts/2022/04/process-and-network-control-of-window-practical-command-recording/</guid>
      <description>进程相关 tasklist tasklist用于查看运行的进程 findstr相当于linux的grep 1 2 3 4 PS C:\Users\akyna&amp;gt; Tasklist | findstr Code Code.exe 19184 Console 1 94,012 K Code.exe 19300 Console 1 26,324 K ...... taskkill 使用该工具按照进程 ID (PID) 或映像名称终止任务。
参数列表:
/PID processid 指定要终止的进程的 PID。 /IM imagename 指定要终止的进程的映像名称。 /T 终止指定的进程和由它启用的子进程。 /F 指定强制终止进程。 /? 显示帮助消息。 e.g.
1 2 3 TASKKILL /IM notepad.exe TASKKILL /PID 1230 /PID 1241 /PID 1253 /T TASKKILL /F /IM cmd.exe /T 网络相关 ipconfig 执行网卡相关操作
1 2 3 4 5 $ ipconfig # 查看网卡信息，如ip地址 $ ipconfig /all # 查看mac地址 $ ipconfig /displaydns # 查看dns缓存内容 $ ipconfig /flushdns # 清除dns缓存 ping 测试本机与指定机器是否联通</description>
    </item>
    
    <item>
      <title>《挪威的森林》文摘三</title>
      <link>/posts/2022/04/norwegian-forest-digest-iii/</link>
      <pubDate>Mon, 18 Apr 2022 20:31:46 +0800</pubDate>
      
      <guid>/posts/2022/04/norwegian-forest-digest-iii/</guid>
      <description>第十章 一九六九年这一年，总是令我想起进退两难的泥沼——每迈一步都几乎把整只鞋陷掉那般的滞重而深沉的泥沼。而我就在这片泥沼中气喘吁吁地挪动脚步，前方一无所见，后面渺无来者，只有昏暗的泥沼无边无际地延展开去。甚至时光都随着我的步调而流淌得十分吃力。身边的人早已经遥遥领先，惟独我和我的时间在泥沼中艰难地往来爬行。
我四周的世界则面临一切沧桑巨变。约翰·科尔特兰死了，还有很多人死了。人们在呼喊变革，仿佛变革正在席卷每个角落。然而这些无一不是虚构的毫无意义的背景画面而已。我则几乎没有抬头，日复一日地打发时光。在我眼里，只有漫无边际的泥沼。往前落下右脚，拔起左脚，再拔起右脚。我判断不出我位于何处，也不具有自己是在朝正确方向前进的信心。我之所以一步步挪动步履，只是因为我必须挪动，而无论去哪里。
下午过去，黄昏来临，继而隐隐泛青的夜色笼罩了院落。“海鸥”早已不见踪影。我又开始观看樱花。在我眼里，春夜里的樱花，宛如从开裂的皮肤中鼓胀出来的烂肉，整个院子都充满烂肉那甜腻而沉闷的腐臭气味。我转而想起直子的裸体。直子娇美的裸体横陈在夜色之中，无数植物的嫩芽从其肌肤中争相萌出，在天外来风的吹拂下，鲜绿的幼芽轻轻摇颤不止。我想，那般巧夺天工的肢体为什么非生病不可呢？他们为什么不肯放直子一条生路呢？
“我倒想拿出精神来。”
“你把人生当做饼干罐就可以了。”
我摇了几下头，看着绿子的脸说：“可能是我脑筋迟钝的关系，有时捉摸不透你说的什么。”
“饼干罐不是装有各种各样的饼干，喜欢的和不大喜欢的都在里面吗？如果先一个劲儿挑你喜欢的吃，那么剩下的就全是不大喜欢的。每次遇到麻烦我就总这样想：先把这个应付过去，往下就好办了。人生就是饼干罐。”
“倒也是一种哲理。”
对于只身独处的人来说，四月实在是不胜凄寂的时节。四月里，周围的人无不显得满面春风。人们脱去外套，在明媚的阳光下或聊天，或练习棒球，或卿卿我我。我却孑然一身，形影相吊。直子也好，绿子也好，永泽也好，所有的人都远远离我而去。现在的我，连问一声“早安”或“你好”的人都没有。甚至对敢死队我都有些怀念。我就这样在无可排遣的孤独中送走了四月。
我爱过直子，如今仍同样爱她。但我同绿子之间存在的东西带有某种决定性，在她面前我感到一股难以抗拒的力量，并且恍惚觉得自己势必随波逐流，被迅速冲往遥远的前方。在直子身上，我感到的是娴静典雅而澄澈莹洁的爱，而绿子方面则载然相反——它是立体的，在行走在呼吸在跳动，在摇撼我的身心。
就我个人感情而言，绿子倒像是个非常可贵的女孩。你为她倾心这点，从信上也看得一清二楚；而你对直子的一片痴情，我也了然于心。这并非什么罪过，只不过是大千世界里司空见惯之事。在风和日丽的天气里荡舟于美丽的湖面，我们会既觉得蓝天迷人，又深感湖水多娇——二者同一道理。不必那么苦恼。纵令听其自然，世事的长河也还是要流往其应流的方向，而即使再竭尽人力，该受伤害的人也无由幸免。所谓人生便是如此。这样说未免大言不惭——你也差不多到了学习这种人生方式的年龄。有时候你太急于将人生纳入自己的轨道。假如你不想进精神病院，就要心胸豁达地委身于生活的河流。就连我这样孱弱而不健全的女人，有时都觉得人生是多么美好。真的！所以，你也务必加倍追求幸福，为追求幸福而努力。</description>
    </item>
    
    <item>
      <title>《斜阳》文摘</title>
      <link>/posts/2022/04/setting-sun-abstract/</link>
      <pubDate>Sun, 17 Apr 2022 23:13:28 +0800</pubDate>
      
      <guid>/posts/2022/04/setting-sun-abstract/</guid>
      <description>作者：太宰治
第三章 心里没着没落，感觉好像无所凭依，似乎怎么也活不下去了——这就是所谓的不安心情吧。胸口仿佛一阵阵痛苦的浪潮在拍打、涌来，就好像黄昏时分骤雨初歇，而后天空匆匆掠过一片片白云似的，使我心脏忽而收紧，忽而松弛，脉搏失常无规律，呼吸也变得困难，眼前发黑，全身的力气仿佛从十指尖上溜掉了一样，毛线都打不下去。
第四章 我在第一封信里曾经提到过我心中飘过的彩虹，这道彩虹并不像萤光或者星光那样高尚和美丽，假如是那样淡淡而幽远的话，我就不会这样痛苦，甚至能够逐渐将您忘掉了。我心中的彩虹是一座火焰之桥，我的思念几乎要将我的心都烧焦了。
第五章 这人世仿佛与我所想象的人世完全不同，是一个不可言喻的奇怪世界，我似乎被人孤零零地弃之旷野，任凭我呐喊呼叫，四下却听不见任何回应。这就是所谓的失恋？</description>
    </item>
    
    <item>
      <title>《挪威的森林》文摘二</title>
      <link>/posts/2022/04/norwegian-forest-digest-ii/</link>
      <pubDate>Sat, 16 Apr 2022 18:03:53 +0800</pubDate>
      
      <guid>/posts/2022/04/norwegian-forest-digest-ii/</guid>
      <description>作者：村上春树
第七章 “见不到你固然是痛苦的，但倘若没有你，我在东京的生活将更不堪忍受。正因为一清早我就在床上想你，我才下决心拧紧发条，自强不息地生活下去。如同你在那边自强不息一样，我在这里也必须自强不息。”
嘈杂的周日街头使我的心头舒展开来。我在通勤电车一般拥挤不堪的纪伊国屋书店里买了一本福克纳的《八月之光》，然后挑一家听起来声音开到尽可能大的爵士酒吧走进去，一边听奥内特·科尔曼和巴顿·帕维尔洛的唱片，一边喝又热又不好喝的咖啡，翻看刚买的书。五点半时，合上书，出门吃了简单的晚饭。我不由心想：这样的星期日以后将重复几十次、几百次吧？“安静的、平和的、孤独的星期日”——我出声说道。星期日我是不上发条的。
第八章 打桌球时居然未想起木月，这使我感到似乎做了一件对不起他的事。当时我觉得自己巳将他彻底忘在脑后，然而夜里返回宿舍，我开始这样想道：那以后已经过去了两年半，而他依然十七岁。但这并不意味他在我的记忆中已渐趋淡薄，他的死带来的东西依然鲜明地留在我的脑海里，有的反而比当时还要鲜明。我即将满二十岁，我同木月在十六岁和十七岁那两年里所共有的东西的某部分早已消失得无影无踪，无论怎样长吁短叹，都已无法挽回——我无法表达得更为确切，但我觉得对于我的感受、我想要表达的，你是会充分理解的，而且能理解此事的恐怕也只有你一个人。
我比以前任何时候都更仔细地思考你的问题。今天在下雨，下雨的星期天多少使我有些惶惶然。因为下雨不能洗衣服，自然也不能熨衣服。既不能散步，又不能在天台上东倒西歪。只好坐在桌前，一边用自动反复唱机周而复始地听《温柔的蓝》，一边百无聊赖地观望院子的雨中景致。以前我也写过，星期天我是不上发条的，因此信也就写得很长很长。不再写了，这就去食堂吃午饭。再见。
第九章 “最最喜欢你，绿子。”
“什么程度？”
“像喜欢春天的熊一样。”
“春天的熊？”绿子再次扬起脸，“什么春天的熊？”
“春天的原野里，你一个人正走着，对面走来一只可爱的小熊，浑身的毛活像天鹅绒，眼睛圆鼓鼓的。它这么对你说道：‘你好，小姐，和我一块儿打滚玩好么？’接着，你就和小熊抱在一起，顺着长满三叶草的山坡咕噜咕噜滚下去，整整玩了一大天。你说棒不棒？”
“太棒了。”
“我就这么喜欢你。”</description>
    </item>
    
    <item>
      <title>《消失的十三级台阶》摘录</title>
      <link>/posts/2022/04/excerpt-from-the-lost-thirteen-steps/</link>
      <pubDate>Fri, 15 Apr 2022 13:02:21 +0800</pubDate>
      
      <guid>/posts/2022/04/excerpt-from-the-lost-thirteen-steps/</guid>
      <description>作者：高野和明
第三章 调查 人在正义的名义下审判另一个人的时候，所谓的正义并不存在普遍的标准。
犯罪所破坏的并不仅仅是眼睛看得到的东西，而是深深地侵入人们心中，破坏了人们心中最根本的东西。 而且，人们将被这个根本性的伤害长久地困扰。
第四章 过去 但是，如果这个社会认可私刑，社会就会陷于无秩序状态。因此，必须由第三者，也就是国家机器行使刑罚权，来代替被害人亲属做他们想做的事。是人都有复仇心，所谓复仇心，就是对失去的人的爱。只要法律是为了人类而存在的，包括死刑在内的报应刑思想就应该被认可。
第六章 处以被告人死刑 法律这个东西，常常有被权力一方恣意滥用的危险。</description>
    </item>
    
    <item>
      <title>《挪威的森林》文摘一</title>
      <link>/posts/2022/04/norwegian-forest-digest-1/</link>
      <pubDate>Thu, 14 Apr 2022 23:11:22 +0800</pubDate>
      
      <guid>/posts/2022/04/norwegian-forest-digest-1/</guid>
      <description>作者：村上春树
第一章 即使在经历过十八度春秋的今天，我仍可真切地记起那片草地的风景。连日温馨的霏霏细雨，将夏日的尘埃冲洗无余。片片山坡叠青泻翠，抽穗的芒草在十月金风的吹拂下蜿蜒起伏，逶迤的薄云紧贴着仿佛冻僵的湛蓝的天穹。凝眸望去，长空寥廓，但觉双目隐隐作痛。清风抚过草地，微微拂动她满头秀发，旋即向杂木林吹去。树梢上的叶片簌簌低语，狗的吠声由远而近，若有若无，细微得如同从另一世界的入口处传来。此外便万籁俱寂了。耳畔不闻任何声响，身边没有任何人擦过。只见两只火团样的小鸟，受惊似的从草丛中腾起，朝杂木林方向飞去。
当然，只要有时间，我总会忆起她的面容。那冷冰冰的小手，那流线型泻下的手感爽适的秀发，那圆圆的软软的耳垂以及紧靠其底端的小小黑痣，那冬日常穿的格调高雅的驼绒大衣，那总是定定地注视对方眼睛发问的惯常动作，那不时奇妙地发出的微微颤抖的语声（就像在强风中的山冈上说话一样）随着这些印象的叠涌，她的面庞突然而自然地浮现出来。最先现出的是她的侧脸。大概因为我总是同她并肩走路的缘故，最先想起来的每每是她的侧影。随之，她朝我转过脸，甜甜地一笑，微微地歪头，轻轻地启齿，定定地看着我的双眼，仿佛在一泓清澈的泉水里寻觅稍纵即逝的小鱼的行踪。
第二章 到得东京，住进寄宿舍开始新生活时，我要做的仅有一件事，那就是对任何事物都不想得过于深刻，对任何事物都保持一定距离。什么敷有绿绒垫的桌球台呀，红色的N360车呀，课桌上的白花呀，我决定一古脑儿把它们丢到脑后。还有火葬场高大烟囱中腾起的烟，警察署询问室中呆头呆脑的镇纸，也统统一扫而光。起始几天，进行得似乎还算顺利。但不管我怎么努力忘却，仍有一团恍若薄雾状的东西残留不走，并且随着时间的推移，雾状的东西开始以清楚而简洁的轮廓呈现出来。那轮廓我可以诉诸语言，那就是： 死并非生的对立面，而作为生的一部分永存。
第四章 我看看绿子的眼睛，绿子也看看我的眼睛。我搂过她的肩，吻住她的嘴。绿子只是肩头稍微抖动了一下，旋即软绵绵地闭上眼睛。约有五六秒，我们悄无声息地对着嘴唇，初秋的阳光把她的眼睫毛映在脸颊上，看上去在微微发颤。
那是一个温柔而安稳的吻，一个不知其归宿的吻。假如我们不在午后的阳光中坐在晾衣台上喝着啤酒观看火灾的话，那天我恐怕不至于吻绿子，而这一心情恐怕绿子也是相同的。我们从晾衣台上久久地望着光闪闪的房脊、烟和红脑袋蜻蜓，心情不由变得温煦、亲密起来，在无意中想以某种形式将其存留下来，于是我们接了吻，就是这种类型的吻。当然，正像所有的接吻一样，我们的接吻也不是说不包含某种危险。
第六章 之后，玲子弹了几支勃萨诺瓦舞曲。这时间里，我端详着直子。如她自己信上写的那样，她显得比以前健康，晒黑了不少，由于锻炼和野外作业，体型紧绷绷的。那湖水一般深邃澄澈的眸子和羞涩似的嗫嚅着的小嘴唇倒是和以前一样，但整个看来，她的娇美已开始带有成熟女性的风韵。往日她那娇美中时隐时现的某种锐气—— 使人为之颤栗的刀刃般的锐气—— 已经远远遁去，转而荡漾着一种给人以亲切抚慰之感的独特的娴静。我为这样的娇美而怦然心动，同时又有些感到惊愕：不过半年时间，一个女人居然会有如此明显的变化。直子这富有新意的娇美确实一如往日或甚于往日，使我为之倾心，为之痴迷。尽管如此，一想到她所失却的东西，我还是不无遗憾。那思春期少女所特有的，或者不妨称之为独往独来、我行我素的潇洒，在她身上已经一去不复返了。
沐浴着柔和月光的直子身体，宛似刚刚降生不久的崭新肉体，柔光熠熠，令人不胜怜爱。每当她稍微动一下身子—— 虽然是瞬间微动 ——月光照射的部位便微妙地滑行开来，遍布身体的阴影亦随之变形。浑圆鼓起的乳房，小小的乳头，小坑般的肚脐，构成腰骨和阴毛的粗粒子阴影，这些都恰似静静的湖面上荡漾开来的水纹一样改变着形状。这是何等完美的肉体啊 ——我想。直子是何时开始拥有如此完美的肉体的呢？那个春夜我所拥抱的她的肉体何处去了呢？</description>
    </item>
    
    <item>
      <title>《强风吹拂》文摘</title>
      <link>/posts/2022/04/strong-wind-blowing-abstract/</link>
      <pubDate>Sun, 03 Apr 2022 23:44:25 +0800</pubDate>
      
      <guid>/posts/2022/04/strong-wind-blowing-abstract/</guid>
      <description>作者：三浦紫苑
第四章. 纪录赛登场 “看了你这三个月来的表现，我越来越相信自己没看错人，”
清濑接着说，“你很有天分，也很有潜力。所以呢，阿走，你一定要更相信自己，不要急着想一飞冲天。变强需要时间，也可以说它永远没有终点。长跑是值得一生投入的竞赛，有些人即使老了，仍然没有放弃慢跑或马拉松运动。”
阿走体内那股跑步的热情，就像一团无以名状的强烈情绪，经常在他心中掀起纷扰的涟漪。但清濑的一席话，却无比炙热地烙进他朦胧幽暗、彷徨无措的内心世界，宛如曙光乍现，照亮阿走心中每一个角落。
第九章. 奔向彼方 清濑曾经说过的“强”，或许就是这个意思。
不论个人赛或驿传，跑步需要具备的强韧，在本质上是永远不会改变的。　那是再怎么痛苦也要向前进的一种力量，以及持续与自己战斗的勇气，也是不只着眼于眼睛看得到的纪录、更要一次又一次超越自我极限的毅力。
第十章. 流星 就物理观点来看，大家都跑在同一条赛道上。
然而，每个人到达的境界却各有不同，借由跑步找到属于自己的终点。
跑者们总是不断在思考、迷惘、犯错，然后再重新来过。
尾声 ——阿走，你喜欢跑步吗？　四年前春天的夜里，清濑这样问阿走。就像一脸纯真的孩子在问，人为什么要活在这世上。　——我很想知道，跑步的真谛究竟是什么。　我也是，灰二哥，我也想知道，虽然我一直在跑，但现在我还是不知道这个问题的答案。直到现在，我跑步时都仍会思考这个问题，今后也会不停问自己。　我真的很想知道。　所以，让我们一起跑吧，跑到天涯海角。　信念发出的光芒，永远存在我们心里。在黑暗中照亮延伸向前的道路，清楚地为我们指引方向。</description>
    </item>
    
    <item>
      <title>《解忧杂货店》文摘</title>
      <link>/posts/2022/04/jieyou-grocery-store-abstract/</link>
      <pubDate>Sun, 03 Apr 2022 23:41:50 +0800</pubDate>
      
      <guid>/posts/2022/04/jieyou-grocery-store-abstract/</guid>
      <description>作者：东野圭吾
第四章. 听着披头士默祷 人与人之间的关系往往不是因为某些具体的原因而断绝。 不，即使表面上有种原因，其实是因为彼此的心已经不在一起，事后才牵强附会地找这些借口。 因为，如果彼此的心没有分开，当发生可能会导致彼此关系断绝的事态时，某一方就会主动修复。 之所以没有人主动修复，就是因为彼此的心已经不在一起了。
第五章. 来自天上的祈祷 你的地图是一张白纸，所以，即使想决定目的地，也不知道路在哪里。 地图是白纸当然很伤脑筋，任何人都会不知所措。 但是，不妨换一个角度思考，正因为是白纸，所以可以画任何地图，一切都掌握在你自己手上。你很自由，充满了无限可能。这是很棒的事。 我衷心祈祷你可以相信自己，无悔地燃烧自己的人生。 这可能是我最后一次针对烦恼谘商进行回答，谢谢你在最后提供了我这么出色的难题。</description>
    </item>
    
    <item>
      <title>山脉游览录（一）</title>
      <link>/posts/2022/03/mountain-tour-1/</link>
      <pubDate>Mon, 21 Mar 2022 18:02:04 +0800</pubDate>
      
      <guid>/posts/2022/03/mountain-tour-1/</guid>
      <description>山的记忆 每一座山都有独特的感觉，每一座山都有自己的故事。
我和踏过的每一座山都有一段故事。
我的山脉游览录，记录那些年那些山。
南五台 南五台位于西安南长安区境内约30公里的秦岭北麓，海拔1688米，为秦岭终南山中段的一个支脉。
因山上有清凉、文殊、舍身、灵应、观音五个台，也就是山上的五个小峰（即五个山峰），故名五台山；且与西安北部耀县的五台山（药王山）以南而得名。
登山的体验感相当不错，较为轻松，当天也是蓝天白云，清风拂面，一切都很好。
百二邱田 景区地处“生态公益林保护区”和“三坑水资源保护区”之间，背靠崎岭头，面对铁山峰，龙盘虎距，狮象朝拱，钟山鼓山对峙，巨石天然，石洞幽深；清泉涓涓，曲径幽幽，山松谷竹，桃红李素，四时山花烂漫，处处佳果硕累。
依稀记得这是一个清晨时的山顶：
景区内的藏莲寺历史悠久，创建于明朝隆庆4年（公元1571年），距今已有430多年，建有慈悲娘殿、三圣殿、地藏阁、珍秀阁、半天娘殿、南天门伯公庙等宗教建筑。
白云密密麻麻的：
华山 华山，古称“西岳”，雅称“太华山”，为五岳之一，位于陕西省渭南市华阴市，在省会西安以东120千米处。南接秦岭山脉，北瞰黄渭，自古以来就有“奇险天下第一山”的说法。
悬崖绝壁，崎岖嶙峋。
当时去的时候，天气不是很好，不是很好的登山时间。不过幸运的是我在山雨来临之前就下山了，赶上了一班缆车，之后不久缆车好像就停运了。
对弈亭，颇具仙外境之感。
铁山 铁山 ，又名铁尖山、铁嶂；清乾隆十年（公元1745年）《普宁县志》载：铁山，以崖石俱作铁色，故名”。
铁山属孤立山脉，东、西、南三面是练江流域平原，北面绵延与广太镇大坪山紧接，方圆62平方公里，是广东省普宁市中部平原地区的一座小山脉。
这是家乡的一座高山，记得当时好像在山上迷路了。
翠华山 翠华山，位于陕西省西安市长安区太乙宫镇，系终南山的一个支峰，位于秦岭北麓，距西安市区20千米，主峰终南山海拔2604米，总面积32平方千米。
因汉武帝曾在这里祭祀过太乙神，故又名太乙山。山腰有翠华庙，内供翠华姑娘塑像。民间传说翠华姑娘为争取自由婚姻，逃奔这里，后来成仙而去，此山便得名翠华山。
寒假时前去游览，这也是我第一次爬雪山。
一只孤独的鸟飞了过去。
这是天池附近的山，优雅的池子和静谧的山。</description>
    </item>
    
    <item>
      <title>配置网络以实现主机和虚拟机系统互通</title>
      <link>/posts/2022/02/configure-the-network-to-realize-the-interworking-between-host-and-virtual-machine-system/</link>
      <pubDate>Sun, 13 Feb 2022 21:20:01 +0800</pubDate>
      
      <guid>/posts/2022/02/configure-the-network-to-realize-the-interworking-between-host-and-virtual-machine-system/</guid>
      <description>主机配置防火墙入站规则 主机如果没开启防火墙则可以跳过这一步。
进入防火墙管理界面，新建入站规则放通目标虚拟机系统IP即可。
选择桥接模式 默认好像是NAT模式，改为桥接模式，指定网卡为当前主机网络的网卡，我的是“Realtek PCIe.GBE Family Controller”。
我的主机网络网关是 192.168.1.1，子网掩码为 255.255.255.0，IP为 192.168.1.126，我想配置虚拟机网络IP为 192.168.1.127 或者 192.168.1.128。
Ubuntu配置静态IP 通过netplan的方法进行，编辑 /etc/netplan/00-installer-config.yaml如下：
1 2 3 4 5 6 7 8 9 10 network: ethernets: enp0s3: dhcp4: no optional: no nameservers: addresses: [114.114.114.114, 8.8.8.8] gateway4: 192.168.1.1 addresses: [192.168.1.128/24] version: 2 然后执行 sudo netplan apply即可。
CentOS配置静态IP 找到当前网络下网卡名，然后编辑/etc/sysconfig/network-scripts下的ifcfg-{网卡名}文件如下：
1 2 3 4 5 6 7 BOOTPROTO=&amp;#34;static&amp;#34; # 静态IP IPADDR=192.168.1.127 # IP NETMASK=255.255.255.0 # 子网掩码 GATEWAY=192.168.1.1 # 网关 DNS1=114.</description>
    </item>
    
    <item>
      <title>在前后端不分离的情况下进行交互性数据展示的实现方法</title>
      <link>/posts/2022/02/implementation-method-of-interactive-data-display-without-separation-of-front-and-back-ends/</link>
      <pubDate>Fri, 11 Feb 2022 00:05:25 +0800</pubDate>
      
      <guid>/posts/2022/02/implementation-method-of-interactive-data-display-without-separation-of-front-and-back-ends/</guid>
      <description>前言 开发web项目时，常常需要在前端展示一些交互性的数据，比如表单填写错误的提示，操作成功与否的提示等。
本文主要讲述在使用Thymeleaf作为模板引擎开发前端时，即在前后端不分离的情况下，前后端进行交互性数据展示的实现方法。
使用cookie传递数据：不推荐 一、步骤 后端通过addCookie方法设置值 前端在页面加载时读取cookie值并进行展示 前端删除该cookie值 二、缺陷 这个方法我使用过，但是效果并不好，原因如下：
用户可能禁止cookie 后端如果有重定向操作将导致cookie添加失败 前端每次都要删除cookie，有时可能会失效 使用session传递数据：值得借鉴 一、步骤 后端往session中存入数据 前端通过${session}进行获取数据并展示 前端将该数据删除或修改为指定默认值 这里注意正常情况下js是无法操作或者访问session值的，我们可以通过thymeleaf内置脚本进行操作：
1 2 3 &amp;lt;script th:inline=&amp;#34;javascript&amp;#34;&amp;gt; // 这里可以通过session访问值 &amp;lt;/script&amp;gt; 二、缺陷 这个方法不好的地方显而易见，我们每次都要删除session值，而且只能通过内置脚本的方式操作，很不方便。
但是这种方法的思想值得借鉴，请看如下方法。
通过RedirectAttributesModelMap传递数据 注意这里后端采用SpringMVC。
一、步骤 通过RedirectAttributesModelMap往model中存值 返回视图对象，在视图对象中通过thymeleaf内置脚本进行数据展示 二、示例：提醒用户首先进行登录 1、后端代码： 1 2 3 4 5 @GetMapping(&amp;#34;/loginFirst&amp;#34;) public String loginFirst(RedirectAttributesModelMap model) { model.addFlashAttribute(&amp;#34;msg&amp;#34;, &amp;#34;请先进行登录&amp;#34;); return &amp;#34;redirect:/&amp;#34;; } RedirectAttributesModelMap可以确保redirect后保存在model中数据不丢失
addFlashAttribute是把数据临时放在session中并在刷新页面后自动删除的方法，配合RedirectAttributesModelMap进行使用
2、前端代码： 必须注意，这里外部js无法通过$(&amp;rsquo;#msg&amp;rsquo;).val()获取th:value设置的值的，所以必须通过thymeleaf提供的内联js代码操作交互的数据。
1 2 3 4 5 6 &amp;lt;div class=&amp;#34;alert&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;input id=&amp;#34;msg&amp;#34; value=&amp;#34;&amp;#34; style=&amp;#34;display: none&amp;#34;/&amp;gt; &amp;lt;script th:inline=&amp;#34;javascript&amp;#34;&amp;gt; let msg = [[${msg}]]; document.</description>
    </item>
    
    <item>
      <title>简洁之美</title>
      <link>/posts/2022/02/the-beauty-of-simplicity/</link>
      <pubDate>Sun, 06 Feb 2022 21:42:50 +0800</pubDate>
      
      <guid>/posts/2022/02/the-beauty-of-simplicity/</guid>
      <description>身处繁杂的社会生活 现代社会，是一个信息爆炸的时代，是一个充满无尽焦虑的时代，是一个繁杂的时代。
在离不开网络的世界里，我们难以摆脱网络上各种信息的侵扰，参差不齐的信息爬满了我们的心房。
在竞争相当激烈的当代社会，我们变得更加焦虑，思绪更加杂乱。
在难以融入的群体中，我们常常迷失了方向而变得无所适从。
想摆脱这一切，然而生活不给我们机会。
想要生活下去，必须适应这一切。
我想从这里面找到一种优美的平衡。
我想要在复杂里面寻找简洁，在焦虑中寻求冷静，在内卷中寻求内心的平衡，在群体中找到自我的位置。
我眼中的简洁美 事物的简洁不是简单的整洁，不等同于简单。
简洁，是让丰富而复杂的东西妥协，一步步削减繁琐的次要的东西，经过仔细的权衡之后留下最为重要的东西。
不能是单纯为了简洁而简化一个事物，而同时要为体验感负责，如果为了简洁削减了更重要的东西，那么就不能称得上是简洁，而是单纯沦为简单。
简洁的事物是能够让自己长久地认同的，简洁是一种趋近于内心深处的东西。
我热衷于寻求属于自己的简洁，在不断地追求这种简洁的过程中，我发现只有真正遵循于自己内心深处认同感的那种简洁，才会较为长久地留下。
也就是说，必须努力让自己冷静地，真正沉下心去寻求自己的简洁。
寻求自己的简洁 孤独 孤独的生活无需在意太多眼光与言语，尽可能地遵循自己内心的需求。
孤独的感觉是自由的感觉，没有太多的约束感。
孤独的时间让我们安静，让我们思考，而不是被无意义的言语和噪音淹没。
而身处群体中，我们无法时刻保持孤独，人类始终是摆脱不了群体。
所以，需要寻求平衡，在必须融入团体的时候应该自然地融入，去学习，去发挥作用。
生活中，要懂得去探寻属于自己的独处时间，以寻求内心的安静，去反思生活，思考人生。
合适 世界上不存在两片完全相同的叶子，每个人都是独一无二的。
适合自己的，让内心的繁杂感减轻，让自己自然地接受那种节奏，简洁的味道就出现了。
我们需要思考什么样的生活是适合自己的，什么样的生活节奏是自己可以自然地接受的。
身处竞争激烈的大环境，我认为内卷不是必须的，但努力是必要的，把握好生活的节奏是很重要的。
需要摆脱无尽的焦虑感，但也不是完全摆脱，需要保留一定的焦虑感以换取前进的动力。
如果改变不了社会，就改变自己吧，但绝不是单纯地依旧社会的要求去要求自己。
持续寻找与思考简洁 简洁的思想，启发我去寻找答案。
所有让人觉得不舒服的地方，都可以算是不简洁的，因为没有从中剔除掉多余的东西并保留下对自己有价值的东西。
我应该遵循自己的内心去面对这一切，在日常生活中寻求自己的简洁美。</description>
    </item>
    
    <item>
      <title>IDEA配置使用记录</title>
      <link>/posts/2022/01/idea-configuration-usage-record/</link>
      <pubDate>Thu, 13 Jan 2022 21:46:42 +0800</pubDate>
      
      <guid>/posts/2022/01/idea-configuration-usage-record/</guid>
      <description>控制台中文乱码解决 菜单栏HELP-&amp;gt;Edit Custom VM OPtions中加 -Dfile.encoding=utf-8 重启idea IDEA开启RunDashboard 1 2 3 4 5 6 7 8 9 # .idea/workspace.xml &amp;lt;component name=&amp;#34;RunDashboard&amp;#34;&amp;gt; &amp;lt;option name=&amp;#34;configurationTypes&amp;#34;&amp;gt; &amp;lt;set&amp;gt; &amp;lt;option value=&amp;#34;SpringBootApplicationConfigurationType&amp;#34; /&amp;gt; &amp;lt;/set&amp;gt; &amp;lt;/option&amp;gt; &amp;lt;/component&amp;gt; IDEA关闭拼写 1 Settings -&amp;gt; Editor -&amp;gt; Inspection -&amp;gt; Proofreading -&amp;gt; 关闭Typo IDEA配置快捷输入 1 editor -&amp;gt; live template IDEA常用快捷键 1 2 3 4 5 6 7 8 9 10 11 12 13 alt + ctrl + L : 格式化 ctrl + shift + r : 替换字符 ctrl + r : 在当前文件中替换字符 ctrl + shift + n : 搜索项目文件 ctrl + f : 在当前文件下搜索字符 ctrl + shift + t : 进行快捷抛异常 alt + 上下键 : 光标移到下或上一层 禁用 double shift 对于2021.</description>
    </item>
    
    <item>
      <title>Java开发中遇到的bug记录</title>
      <link>/posts/2022/01/record-of-bugs-encountered-in-java-development/</link>
      <pubDate>Thu, 06 Jan 2022 17:23:00 +0800</pubDate>
      
      <guid>/posts/2022/01/record-of-bugs-encountered-in-java-development/</guid>
      <description>持续更新中。
BufferedWriter无法正确写出问题 这是一段客户端代码，向服务器端发送消息，然后接收服务器端的回复：
1 2 3 4 5 6 7 8 9 10 11 12 13 try ( BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())) ) { String message; while((message = stdIn.readLine()) != null) { out.write(message); out.flush(); System.out.println(&amp;#34;Receive from server: &amp;#34; + in.readLine()); } } catch (Exception e) { System.out.println(e.getMessage()); } 这是服务端代码的一部分，接收客户端消息，并向客户端回复：
1 2 3 4 5 6 7 8 9 10 11 12 13 try ( BufferedReader in = new BufferedReader(new InputStreamReader(socket.</description>
    </item>
    
    <item>
      <title>Linux实用操作之权限管理</title>
      <link>/posts/2021/12/permission-management-of-linux-practical-operation/</link>
      <pubDate>Mon, 20 Dec 2021 10:15:34 +0800</pubDate>
      
      <guid>/posts/2021/12/permission-management-of-linux-practical-operation/</guid>
      <description>添加用户 1 2 3 4 5 6 7 8 9 [root@VM-0-11-centos ~]# useradd jzh [root@VM-0-11-centos /]# id jzh uid=1000(jzh) gid=1000(jzh) groups=1000(jzh) [root@VM-0-11-centos /]# grep jzh /etc/passwd /etc/shadow /etc/group /etc/passwd:jzh:x:1000:1000::/home/jzh:/bin/bash /etc/shadow:jzh:!!:18980:0:99999:7::: /etc/group:jzh:x:1000: x指代密码，对应到shadow中，未设定即为“!!”
设置密码 在进行useradd后密码还未设定。
1 2 3 4 5 6 [root@VM-0-11-centos /]# passwd jzh Changing password for user jzh. New password: BAD PASSWORD: The password is shorter than 8 characters Retype new password: passwd: all authentication tokens updated successfully. 若要让用户第一次能通过默认密码登录得上，并提示用户必须修改密码：</description>
    </item>
    
    <item>
      <title>Redis学习记录二</title>
      <link>/posts/2021/12/redis-learning-record-ii/</link>
      <pubDate>Mon, 20 Dec 2021 10:15:05 +0800</pubDate>
      
      <guid>/posts/2021/12/redis-learning-record-ii/</guid>
      <description>事务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 127.0.0.1:6379&amp;gt; multi # 开启事务 OK 127.0.0.1:6379&amp;gt; set book java QUEUED 127.0.0.1:6379&amp;gt; get book QUEUED 127.0.0.1:6379&amp;gt; exec # 执行事务 1) OK 2) &amp;#34;java&amp;#34; 127.0.0.1:6379&amp;gt; get book &amp;#34;java&amp;#34; 127.0.0.1:6379&amp;gt; multi OK 127.0.0.1:6379&amp;gt; set name peter QUEUED 127.0.0.1:6379&amp;gt; discard # 取消事务 OK 127.0.0.1:6379&amp;gt; exec (error) ERR EXEC without MULTI 127.0.0.1:6379&amp;gt; get name (nil) 获取key 获取指定key 1 keys * # 获取所有key 1 keys pattern # 根据pattern获取key 1 2 3 4 - * 代表匹配任意字符 - ?</description>
    </item>
    
    <item>
      <title>Redis学习记录一</title>
      <link>/posts/2021/12/redis-learning-record-i/</link>
      <pubDate>Tue, 14 Dec 2021 23:40:44 +0800</pubDate>
      
      <guid>/posts/2021/12/redis-learning-record-i/</guid>
      <description>Open, Connect And Config open redis: 1 redis-server connect to redis: 1 redis-cli disconnect: 1 redis-cli shutdown show chinese: 1 redis-cli --raw connect to remote redis: 1 redis-cli -h host -p port -a password get redis config: 1 config get {config_name} Data Type list:
1 2 3 lpush clist redis lpush clist mysql lrange clist 0 100 key:
1 2 3 4 5 6 7 8 127.0.0.1:6379&amp;gt; set mkey sos OK 127.</description>
    </item>
    
    <item>
      <title>Git快速初始化操作</title>
      <link>/posts/2021/12/git-quick-initialization-operation/</link>
      <pubDate>Fri, 10 Dec 2021 18:10:07 +0800</pubDate>
      
      <guid>/posts/2021/12/git-quick-initialization-operation/</guid>
      <description>git初次拉取远程仓库 首先从github建立一个仓库，获取仓库地址url，然后进入项目所在文件夹，运行以下代码：
1 2 3 4 5 6 7 8 9 &amp;gt; git init # 初始化仓库，生成.git文件 &amp;gt; git add . # 将项目文件的修改信息添加到.git内的一个暂存区（index） &amp;gt; git commit -m “init” # 将暂存区的修改信息提交到分支 &amp;gt; git remote add origin ${url} # 添加远程仓库 &amp;gt; git push origin master # 将本地分支推送到远程仓库 这里执行完 git commit -m &amp;quot;init&amp;quot; 后，我们查看一下本地分支信息：
1 2 &amp;gt; git branch * master 可见git自动为我们本地创建了一个master分支。
执行完 git push origin master 后，我们查看一下本地分支与远程分支的映射关系：
1 2 3 4 5 6 &amp;gt; git branch -a * master remotes/origin/master &amp;gt; git branch -vv * master 3a31f4c init 可见并没有产生映射。</description>
    </item>
    
    <item>
      <title>关于char*, char[], string的理解</title>
      <link>/posts/2021/12/understanding-of-char-char-string/</link>
      <pubDate>Sun, 05 Dec 2021 12:37:32 +0800</pubDate>
      
      <guid>/posts/2021/12/understanding-of-char-char-string/</guid>
      <description>关于char[]与char*的区别 1 2 3 4 char s1[] = &amp;#34;abc&amp;#34;; cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl; // abc s1[1] = &amp;#39;d&amp;#39;; // 改变值 cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl; // adc &amp;ldquo;abc&amp;quot;为字符串常量，s1为指针常量，即指针是一个常量，所以指向地址不能改变，指向地址的值可变
1 2 3 4 const char* s2 = &amp;#34;abc&amp;#34;; // const是默认存在的 cout &amp;lt;&amp;lt; s2 &amp;lt;&amp;lt; endl; // abc s2 = &amp;#34;dfs&amp;#34;; // 改变地址 cout &amp;lt;&amp;lt; s2 &amp;lt;&amp;lt; endl; // dfs &amp;ldquo;abc&amp;quot;为字符串常量，s2为常量指针，指向地址可变，但指向的地址的值不能变
以上两者皆可用于函数传值
1 2 3 4 5 6 void print_str(const char * str) { printf(&amp;#34;%s\n&amp;#34;, str); } print_str(s1); // adc print_str(s2); // dfs 关于string和char[],char*的关系 string是类，string是对一个字符串的引用值 1 2 3 4 5 6 7 const char* s1 = &amp;#34;abc&amp;#34;; string s = s1; cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl; // abc s += &amp;#34;a&amp;#34;; cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl; // abca cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl; // abc 证明string只是引用了s1 string引用字符串示例 1 2 3 4 5 6 7 const char *s1 = &amp;#34;123&amp;#34;; string str1 = s1; // 若要这样赋值s1必须加const cout &amp;lt;&amp;lt; str1 &amp;lt;&amp;lt; endl; // 123 char s2[] = &amp;#34;234&amp;#34;; string str2 = s2; cout &amp;lt;&amp;lt; str2 &amp;lt;&amp;lt; endl; // 234 string转char* 1 2 3 const char* s1_1 = str1.</description>
    </item>
    
    <item>
      <title>Linux实用操作之文本操作</title>
      <link>/posts/2021/12/text-operation-of-linux-practical-operation/</link>
      <pubDate>Sun, 05 Dec 2021 00:20:09 +0800</pubDate>
      
      <guid>/posts/2021/12/text-operation-of-linux-practical-operation/</guid>
      <description>使用grep抓取期望的结果 在过去登录主机的人中截取登录信息含root的行信息
1 last | grep &amp;#39;root&amp;#39; 比较重要，记忆：
grep [-acinv] [&amp;ndash;color=auto] &amp;lsquo;搜寻字串&amp;rsquo; filename
选项与参数：
-a ：将 binary 文件以 text 文件的方式搜寻数据
-c ：计算找到 &amp;lsquo;搜寻字串&amp;rsquo; 的次数
-i ：忽略大小写的不同，所以大小写视为相同
-n ：顺便输出行号
-v ：反向选择，亦即显示出没有 &amp;lsquo;搜寻字串&amp;rsquo; 内容的那一行
&amp;ndash;color=auto ：可以将找到的关键字部分加上颜色的显示喔
awk命令操作文本 格式化输出：以tab隔开打印前五行中每行的第一和第三个字符 awk &amp;lsquo;{[pattern] action}&amp;rsquo; {filenames}
1 last -n 5 | awk &amp;#39;{print $1 &amp;#34;\t&amp;#34; $3}&amp;#39; 注意必须是内双引号外单引号的形式。
分隔字符 awk -F #-F指定所操作文件中的目标分割字符
使用&amp;quot;,&amp;ldquo;分隔
1 awk -F, &amp;#39;{print $1 &amp;#34; - &amp;#34; $2}&amp;#39; log.txt 设置变量 awk -v # 设置变量</description>
    </item>
    
    <item>
      <title>Java重写equals方法的同时为什么要重写hashcode方法</title>
      <link>/posts/2021/11/why-should-java-rewrite-the-hashcode-method-when-rewriting-the-equals-method/</link>
      <pubDate>Fri, 26 Nov 2021 09:23:27 +0800</pubDate>
      
      <guid>/posts/2021/11/why-should-java-rewrite-the-hashcode-method-when-rewriting-the-equals-method/</guid>
      <description>提出问题 先看一个例子：
当两个人年龄相同时，我们认为这两个对象相同：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Person { private int age; private String name; public Person(int age, String name) { this.age = age; this.name = name; } @Override public String toString() { return &amp;#34;Person{&amp;#34; + &amp;#34;age=&amp;#34; + age + &amp;#34;, name=&amp;#39;&amp;#34; + name + &amp;#39;\&amp;#39;&amp;#39; + &amp;#39;}&amp;#39;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() !</description>
    </item>
    
    <item>
      <title>跑步记忆</title>
      <link>/posts/2021/11/running-memory/</link>
      <pubDate>Tue, 23 Nov 2021 18:20:39 +0800</pubDate>
      
      <guid>/posts/2021/11/running-memory/</guid>
      <description>跑步的记忆，旧日的时光，思念的味道，生活的无常。
一. 跑步的挚友 念起中学生活，就会想起那位挚友。
一同骑行，跑步的挚友。
相约跑步，无话不谈。
欢快，笑颜，脚下轻快的风。
渐渐习惯了跑步。
我俩都喜欢跑步，也更喜欢骑行。
休息日，相约骑行。
去探索，去流汗，去呼吸，去感受脚下的风。
二. 离开那个地方 结束了吗，那段日子，那段纯真，自在的日子。
升学，分别，时间悄然流逝&amp;hellip;&amp;hellip;
和他的联系，不知觉地，越来越少。
跑步的日子，似乎渐渐离我而去。
跑步，对我来说意味着什么？
那段一去不返的时光，那段珍贵无比的岁月。
人走，茶凉。
三. 迷恋的感觉 高中，莫名迷上了跑步。
跑步，带给我的是不一样的感觉。
是解脱的感觉。
是在焦虑，迷茫，孤独的生活中，跑步带给我的解脱感。
跑步呵，跑步，这个孤独，奇妙的运动。
那清爽的风，那轻快的步。
那孤独的感觉，那平静的心。
我在日记记录下了那种感觉。
四. 跑步时的思考 跑步的时候，有时我也许什么都不想。
在放空心绪的状态下，感受跑步，感受风的味道。
也可能我会思考问题。
孤独的时候，常常会思考一个又一个问题。
人生，道理，题目，或是一些无意义的事情。
跑步，这项本质孤独的运动，在我看来，是免不了思考的。
思考，无疑给跑步带来了更多的乐趣。
五. 大学的风 敲着键盘，想着往事。
不知，旧日的朋友现在近况如何？
大学，还是免不了跑步。
跑步，又多了许多味道。
是思念的味道，是怀旧的味道，是寂寞的味道。
大学的风，来自西北的风，不同于南方的风，有点干燥。
感觉，一切都变了呢。
六. 伤痛的感觉 生活并不总是如你所愿。
力所不能及之处，如果非要强求，可能将落下遗憾与后悔。
山外有山，曾经有过的挑战也让我更加认清自己。
什么是最适合自己的？
自己是否努力到了足以对抗强敌的程度？
血，酒精，痛觉&amp;hellip;&amp;hellip;
一切都让我更加清醒与冷静。
反省，沉静下去反省。
愿伤痛带来的不只是伤痛。</description>
    </item>
    
    <item>
      <title>Window增加右键打开选项</title>
      <link>/posts/2021/11/add-right-click-open-option-in-window/</link>
      <pubDate>Sat, 20 Nov 2021 18:10:30 +0800</pubDate>
      
      <guid>/posts/2021/11/add-right-click-open-option-in-window/</guid>
      <description>加入注册表界面 win+R
regedit
增加右键操作文件选项 以vscode作为编辑文件实例 注册表页面下进入：
计算机\HKEY_CLASSES_ROOT*\shell
新建项 Vscode
右键Vscode并新建项command
编辑command默认选项值为： ${vscodepath}\Code.exe %1 %1是可选的参数，这里必须要加，表示作用于该文件。
编辑Vscode值
编辑右键显示名称：默认值改为Open with vscode （不编辑则为新建项的名称）
编辑右键显示图标：新建字符串值icon 添加：${vscodepath}\Code.exe (有些可以这样，但一般为ico文件)
增加目录下右键打开选项 以window terminal作为实例 注册表页面下进入：
计算机\HKEY_CLASSES_ROOT\Directory\Background\shell
新建项 Terminal
右键Terminal 新建项command
编辑command默认选项值为：${terminalpath}\wt.exe 编辑Terminal值
编辑右键显示名称：默认值改为Open in terminal （不编辑则为新建项的名称）
编辑右键显示图标：新建字符串值icon 添加：${terminalicon}
编辑window terminal的json配置文件
对应位置修改如下，&amp;quot;.&amp;ldquo;即表示当前目录。 1 2 3 4 5 6 7 8 &amp;#34;profiles&amp;#34;: { &amp;#34;defaults&amp;#34;: { &amp;#34;startingDirectory&amp;#34; : &amp;#34;.&amp;#34; }, ... } over</description>
    </item>
    
    <item>
      <title>Linux上部署JAR包项目后的文件上传问题</title>
      <link>/posts/2021/11/file-upload-problem-after-deploying-jar-package-project-on-linux/</link>
      <pubDate>Wed, 03 Nov 2021 00:38:12 +0800</pubDate>
      
      <guid>/posts/2021/11/file-upload-problem-after-deploying-jar-package-project-on-linux/</guid>
      <description>在进行上传文件时，一般会先获取项目类路径：
1 2 File relativePathFile = new File(URLDecoder.decode(ResourceUtils.getURL(&amp;#34;classpath:&amp;#34;).getPath(), &amp;#34;utf-8&amp;#34;)); String absolutePath = relativePathFile.getAbsoluteFile().getPath(); 首先取得相对路径，再进一步取得绝对路径，结果如下：
如果单纯运行一个java项目： 获得路径为：
${project}/target/classes
如果是运行jar包，且是在Linux系统上，则获得路径大致为： .../${jar包名}!/BOOT-INF/classes! [centos7.9下]
所以如果是jar包启动并上传文件，则无法正确放到类路径下。
所以需指定新的上传路径。
在如下路径中：
1 2 [root@VM-0-11-centos app]# ls application.yaml LonersHub-0.0.1-SNAPSHOT.jar static 假设我要把文件上传到和jar包同一路径下的static内, 可以在jar包同一路径下新建并编辑application.yaml文件如下：
1 2 3 4 5 spring: resources: static-locations: - classpath:static/ - file:/app/static/ 然后在文件上传是指定上传路径即可。
这里编写一个工具类如下：
关注getUploadPath方法，它用于获取上传路径。
首先，为了方便后期维护和部署使用，我们先判断项目运行所在的操作系统，如果是生产环境linux则上传到上面指定的目录，而如果是本地测试项目，则将其上传到类路径下的默认位置即可。
比如，要上传一个头像：
linux下： 返回/app/static/${uploadType}/${fileName}
e.g. /app/static/avatar/test.jpg
window下： 返回 ${project}/target/classes/static/${uploadType}/${fileName}
e.g. ${project}/target/classes/static/avatar/test.jpg
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public class FileUtils { /** * @description: 获取上传路径 * @author Jiang Zhihang * @date 2022/1/2 23:32 * @param type 上传类型，如avatar，video * @param fileName 上传文件的名称 */ public static String getUploadPath(String type, String fileName) throws FileNotFoundException, UnsupportedEncodingException { String osName = System.</description>
    </item>
    
    <item>
      <title>Linux主机部署springboot项目全过程</title>
      <link>/posts/2021/11/the-whole-process-of-linux-host-deployment-springboot-project/</link>
      <pubDate>Wed, 03 Nov 2021 00:30:25 +0800</pubDate>
      
      <guid>/posts/2021/11/the-whole-process-of-linux-host-deployment-springboot-project/</guid>
      <description>注：部署环境为centos7.9版本
配置环境 配好mysql，redis，java开发环境。
上传JAR包项目 1 2 mvn clean mvn package 即可把项目打包为JAR包，再通过WINSP上传到服务器。
先新建一个app文件夹，放置项目所有内容：
1 2 mkdir /app chmod 777 /app 新建并编辑application配置文件 由于主机上的mysql密码与本地mysql密码不同，所以在JAR包同一个文件目录下新建application配置文件并指定新的密码，允许JAR项目时该application配置文件优先级是更高的。这里我还指定了用于linux下文件读取上传的目录路径。
1 2 3 4 5 6 7 spring: datasource: password: ...... resources: static-locations: - classpath:static/ - file:/app/static/ 1 2 3 [root@VM-0-11-centos app]# chmod -R 777 * [root@VM-0-11-centos app]# ls application.yaml LonersHub-0.0.1-SNAPSHOT.jar static 运行项目 首先确保防火墙配置正确，放通需要的端口。
1 2 [root@VM-0-11-centos app]# nohup java -jar LonersHub-0.0.1-SNAPSHOT.jar &amp;amp; [1] 27108 更新项目 首先终止原本进程，删除原来的jar包并上传新的jar包，然后运行新的jar包：
1 2 3 4 5 6 7 [root@VM-0-11-centos app]# ps -ef | grep java root 13415 1 1 00:02 ?</description>
    </item>
    
    <item>
      <title>春物文摘四</title>
      <link>/posts/2021/06/spring-abstracts-iv/</link>
      <pubDate>Wed, 23 Jun 2021 23:27:20 +0800</pubDate>
      
      <guid>/posts/2021/06/spring-abstracts-iv/</guid>
      <description>作者：渡航
卷十三 第八章. 祈祷至少不要再出错。 「我过得很愉快。这还是第一次。觉得跟别人一起度过的时间是自在舒适的，我很高兴……」
她带着泫然欲泣的表情，看起来真的很幸福。我再也无法否定，制止她。
我无力地放下手，雪之下道谢似地点一下头，接着说：
「我从来没有像这样跟别人争执，吵架……在别人面前哭过。两个人一起出去的时候，也非常紧张。一堆事都不懂，从来没有体验过……连可以依赖别人都不知道。所以，才会在哪里搞错了……」
我抬头看着天花板，倾听她用颤抖的声音自言自语。
远方的夕阳刺痛双眼，即使如此，我依然无法闭上眼，只是忧郁地吐出一口气。
「这种像赝品的关系是错误的。和你追求的事物肯定不一样。」
卷十四 序章1 季节轮转，春日再临。
即便重复着一成不变的日常，今日也总是崭新的。
即便困于烦恼，难觅答案，重复着错误，也只能不厌其烦地重新问过——为了知晓新的答案。
不付诸言语便无法传达，可就算说出口也仍不足够。
无论何时得出的答案都是错误的，扭曲得几近无法挽回的关系，是令人无可奈何的伪物。
———所以，至少，要在这个仿造品上留下足以毁坏的伤痕，变成那仅仅只有一个的真物。
我故意犯错的青春，要让它结束掉———
已然逝去的季节，与将要来临的崭新季节。
持续着错误的故事结束……之后青春一定还将继续。
第七章. 触碰到的温度，切实地传达着那份情感 在她走了几步之后，我跟了上去。
看着远去的背影，我伸出了手，却又不由地犹豫起来。
我明白，如果要继续谈话的话，只要叫住她就行了。
即使继续像那样走下去，交谈也并不困难。
再说了，根本不可能没有特别的理由就去触碰她的手。
但是，理由确实存在。唯一的，不容退让的理由。
「……放手了的话，就再也抓不住了啊」
脱口而出的话语，就像是在说给自己听一样。
不对，是为了说给自己听才会说出那样的话。接着，我伸出了手。
单手推着自行车我的样子有些狼狈，而且手里还出了很多汗，也不清楚该用多大的力道。
即便如此，我还是抓住了雪之下的袖口。
把那纤细到令我惊讶的手腕紧紧地收入掌中。
「…………」
开始说话之后，由于强烈的自我厌恶手中的力气不断地减弱。
说出这种话的自己简直恶心得令人作呕。
抓着雪之下的手腕的手一点点下滑，松开，然后无力地垂落下去。
但是，雪之下并没有逃走，而是停在了那里。
在摸了摸袖口稍作整理的时候，用自己的手紧握住方才被我抓住的地方。
虽然没有看向我这边，但是至少看上去有继续听下去的意思。
对此感到安心之后，我不紧不慢地开口道。
「可能你并不期望……但是我想把关系维持下去。不是义务，而是意愿的问题。……所以，给我扭曲你人生的权利」
「我没有足以改变人生的影响力啊，大概，我和你也都会像其他人一样升学，不情愿地就职，就那样认真地活着。但是，互相关联之后，会莫名其妙地做出绕远路啊，原地踏步啊之类的各种各样的事情吧……所以，人生会稍微扭曲一些」
「我也是这么想的，相遇，相谈，相知，相离……每次，都会感到扭曲」
想必，太过别扭的我，太过直率的她，在他人眼中都是扭曲的形状吧。
虽然完全没有相同之处，在扭曲这一点上恐怕是一样的。
不知不觉间，每一次的相触，每次一次的碰撞，都在稍稍改变了我们的形状。
这样的改变不断累积，已经到了无法还原的地步了。
如果有让传达变得更简单的话语就好了。
如果是更加单纯的感情就好了。
如果只是恋慕、思慕的话一定不会这么向往。『再也抓不住』什么的，不会这么想。
「应该不足以支付扭曲人生的代价吧，不过嘛，全都会去做的。不需要的话就扔掉吧。嫌麻烦的话忘掉也无所谓。是我这边擅自做出的决定你不用勉强自己回复」
雪之下轻哼了一声，点了点头。
「我要好好说了哦」
然后，轻轻地把额头抵在我的肩口。
「你的人生，请交给我吧」
「……好沉重」
不经意间，气息漏出了我的嘴角。仿佛是在抗议一般，雪之下的额头再一次轻轻地撞了过来。
「真的不知道其他的说法了，所以这也是没办法的啊……」
她像猫一样把额头靠了过来，仿佛小猫轻咬一般抓着我的胸膛。
触碰到的温热，一定在确切地传达着用千言万语也说不清的心意。
第八章. 那扇门再次打开。 我默默地把手递了过去。
雪之下好像不明白那只手的意义，微微地歪头，紧接着露出了浅浅的苦笑。
「我一个人也能站起来的……」
「我知道」</description>
    </item>
    
    <item>
      <title>Docker简单使用记录</title>
      <link>/posts/2021/05/docker-simple-use-process-record/</link>
      <pubDate>Wed, 19 May 2021 22:52:52 +0800</pubDate>
      
      <guid>/posts/2021/05/docker-simple-use-process-record/</guid>
      <description>下载并运行ubuntu镜像 1 2 [root@VM-0-11-centos ~]# docker run ubuntu:15.10 /bin/echo &amp;#34;crazy thursday&amp;#34; crazy thursday 运行ubuntu并开启bash交互 1 2 3 4 5 6 7 8 9 10 [root@VM-0-11-centos ~]# docker run -i -t ubuntu:15.10 /bin/bash root@fda3220ed59f:/# echo hello hello root@fda3220ed59f:/# cat /proc/version Linux version 3.10.0-1160.45.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) ) #1 SMP Wed Oct 13 17:20:51 UTC 2021 root@fda3220ed59f:/# ls bin dev home lib64 mnt proc run srv tmp var boot etc lib media opt root sbin sys usr root@fda3220ed59f:/# exit exit 运行进程并观察 1 2 3 4 5 [root@VM-0-11-centos ~]# docker run -d ubuntu:15.</description>
    </item>
    
    <item>
      <title>Synchronized到底锁了谁</title>
      <link>/posts/2021/05/who-the-hell-is-synchronized-locking/</link>
      <pubDate>Wed, 19 May 2021 22:43:45 +0800</pubDate>
      
      <guid>/posts/2021/05/who-the-hell-is-synchronized-locking/</guid>
      <description>Synchronized方法 静态方法上的锁
静态方法是属于“类”，不属于某个实例，是所有对象实例所共享的方法。也就是说如果在静态方法上加入synchronized，那么它获取的就是这个类的锁，锁住的就是这个类。
普通方法上的锁
实例方法并不是类所独有的，每个对象实例独立拥有它，它并不被对象实例所共享。在实例方法上加入synchronized，那么它获取的就是这个类的锁，锁住的就是这个对象实例。
Synchronized代码块 synchronized(this){...} this关键字所代表的意思是该对象实例，这种用法synchronized锁住的是对象实例。
synchronized(Demo.class){...} 锁的是该类。
synchronized(obj){...} synchronized同步代码块对对象内部的实例加锁。
假设demo1与demo2方法不相关，此时两个线程对同一个对象实例分别调用demo1与demo2，均能获取各自的锁。
代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Demo { private Object lock1 = new Object(); private Object lock2 = new Object(); public void demo1() { synchronized (lock1) { while (true) { //死循环目的是为了让线程一直持有该锁 System.out.println(Thread.currentThread()); } } } public void demo2() { synchronized (lock2) { while (true) { System.</description>
    </item>
    
    <item>
      <title>春物文摘三</title>
      <link>/posts/2021/05/spring-article-excerpt-3/</link>
      <pubDate>Thu, 13 May 2021 23:19:00 +0800</pubDate>
      
      <guid>/posts/2021/05/spring-article-excerpt-3/</guid>
      <description>作者：渡航
卷十 第七章. 不论何时，叶山隼人总是迎合众人期待 她满意地舒一口气，把脸抬起。我们之间的距离，瞬间拉近到脸颊快碰在一起。
「……」
两个人就这么僵住。
雪之下的肌肤宛如冬天的白雪，乌黑的双眼仿佛在荡漾，每眨一下，修长的睫毛跟着轻柔摇曳。往底下走，是姣好尖挺的鼻梁，以及绽放笑容、呼出热气的嘴唇。
她削瘦的的肩膀微微一颤，瀑布般的长发随之晃动。
我赶紧往后仰，跟她拉开距离。结果不知动到什么地方，某处的伤口突然痛了一下。
「嗯……谢谢你帮忙消毒。」
「……没什么，不是什么大不了的事。」
卷十二 第五章. 果然，一色彩羽是最强的后辈。 舞会上的雪之下
倒不如说合身过头了。单色调的燕尾服，更彰显了雪之下白皙明净的肌肤之美；
伸长的衣摆和长裤也令她修长俏丽的美腿更为凸显；
举手投足间，她那扎为一束的秀发如波浪般律动，又为她添了几分虚幻朦胧之意；
再与她纤瘦的身材相映成趣后，「薄幸的美少年」一词仿佛呼之欲出。
光是她那工整标致的五官，便使她散发着一种倒错美的气息，我甚至感到了危险。
舞会上的结衣
近乎于白的淡粉、带着透明感的布料，此般色调搭配，又或者说是因为这种款式，给人一种分外的成熟感。
衣襟张得很开，腰部那块也束了一圈，而这又更勾勒出她傲人的身体曲线。
裙摆本身很长，不过因为开衩开的很深，所以看上去丝毫不笨重；倒不如说若是她转动身体，这礼服就好似随风起舞般的轻盈。
她一向缠成团子头的头发，如今编的好似花冠，让我不禁想起某位王子大人提过的称呼。
第七章. 就算，知道会后悔这个选择。 最终只剩下我们的事了。因为相互依赖，所有没有比我们更好理解的了。
说来容易，正因被人依靠，我才能够弄清自己的存在价值。
我自己也很容易地信服。
然而，这并不是答案。相互依赖是形式，但非人的感情所在。即便可以用作借口，也无法成为理由。
抽丝剥茧，尽心竭力，声嘶力竭，最终心里只剩下了恋恋不舍。
可是，我唯独不想说出这话。因为这个理由太逊了。然而，不说出来，这位老师就不会让我前行。我很清楚，因为如此，她才对我道歉。
所以，我疲惫地、重重地叹了一口气，迫不得已，小声地开口说道。
「……因为我承诺过，总有一天会对她伸出援手。」
因为她拜托过我，这理由十分平常而又极为理所当然，这话语不带感情而又毫无逻辑可言，这措辞实在无聊而又陈词滥调透顶，我对向她出手相助，真的是厌恶至极。</description>
    </item>
    
    <item>
      <title>春物文摘二</title>
      <link>/posts/2021/05/spring-abstracts-ii/</link>
      <pubDate>Tue, 11 May 2021 16:44:36 +0800</pubDate>
      
      <guid>/posts/2021/05/spring-abstracts-ii/</guid>
      <description>作者：渡航
卷八 第一章. 不用说也知道，这正是比企谷小町的逆鳞所在 我们终将失去拥有的一切。此乃不变的真理。
尽管如此——
因为终将失去，才显现其美丽。
因为有结束的一刻，才显得有意义。不论是停滞还是闭塞，乃至于一时的安宁，都绝非我们所能忽视或甘愿忍受的事。
万物皆有失去的一刻。千万谨记这一点。
在不经意间想起失去的事物，如同对待宝物般小心呵护，将回忆连同杯中的酒一起饮尽，想必也是一种幸福。
第七章. 不用说也知道，这正是比企谷小町的温柔所在 谁也不会受到伤害的世界根本不存在。
真正存在的，是大家平等受到伤害的世界。
没有人受到伤害，这个世界便无法成立。如果明白这一点，依然不愿任何人受伤，那只好另外产生一个代罪羔羊。
这个代罪羔羊不是从任何人之中推派，它只负责出来扛下所有的憎恨与伤害。
第八章. 时机成熟，比企谷八幡终于开口 我真的不知道答案如何。
雪之下的那句话依旧在耳边回荡。
认为对方了解自己只是一种幻想，如同让人忘却自我的温柔乡，一旦深陷进去便难以脱身。抛下一切委身于其中，真不知道会有多舒服。
「相互了解」是一种错觉，一场残酷的幻术。
从幻术中回过神时，那股失落感想必相当强烈。
任何一点微小的不自然感与疑心会成为荆棘与隔阂，在某个时刻将一切摧毁殆尽。
我应该早一点有所察觉。
我渴望的不是什么亲近的关系。
我渴望的事物更加纯粹。
无需话语即可心意相通，无需行为即可了解对方，无论发生什么都能永保完整——我真正渴望的是这种超脱现实，到达可笑地步的美丽幻想。
这是我跟她一直在追求的事物。
卷九 第五章. 平冢静祈祷着他们迎向的结局 雪之下摇摇头，肩上的包包无力地滑落。
「在那之后，你便一直很在意……所以……」
我好不容易听出气若游丝的话语，等待她的下一句话。她却转向别的话题。
「其实，你不需要继续勉强自己。要是这样就被破坏，代表程度也不过如此……难道不是？」
这次我真的说不出话。
雪之下所说的，是我曾经相信过，却没有坚信到底的事物。
毕业旅行之后，我便不再相信的事物，雪之下至今仍深信着。
街灯将平冢老师的脸映照成橘红色，川流的车灯不时刷上白光。她带着略显落寞的神情，用温暖又柔和的声音低语：
「可是啊，比企谷，这是不可能实现的。人类只要存在这个世界，便难免在不自觉中伤害到其他人。不只是活着，连死去以后，伤害都持续发生着。与人产生关系，伤害便连带出现；即使刻意避免产生关系，也难保对方不会受伤……」
平冢老师抽出一根香烟，看着那根烟继续说：
「说是这么说，假如对方一点都不重要，我们也不会注意到自己造成的伤害。重要的在于『自觉』。正是因为珍惜对方，我们才意识到伤害了对方。」
老师总算把烟含入口中，用打火机点燃时，脸庞微微亮了一下。她闭着双眼，面容相当安详，「呼——」地吐出长长的烟雾，低语：
「珍惜一个人，意味着做好伤害对方的觉悟。」
她抬头看向夜空。
第六章. 即使如此，比企谷八幡—— 我渴望的不是话语。但我的确渴望着什么。
那肯定不是相互理解、好好相处、无话不谈、待在一起之类的愿望。我知道自己不被人理解，也不期望别人理解自己。
我追求的是更苛刻、更残酷的事物。
未知的事物是何等恐怖，所以我希望「了解」。我想了解、想知道，借此感到安心，得到心灵上的安适。
「想要完全理解」这种愿望太过自私、太过独裁、太过傲慢，既肤浅又教人厌恶。一想到自己抱持这种愿望，便觉得浑身快要受不了。
话虽如此，如果、如果彼此都能这么想——
如果存在那么一个对象，能互相将丑陋的自我满足加在彼此身上，并且建立容忍彼此傲慢的关系——
这种情况绝对不可能发生，我心里清楚得很；这样的愿望，只存在我无法企及之处。
再怎么跳也够不到的葡萄，一定酸得要命。
不过，我也不需要甜到失去实感的果实。虚假的认知和欺瞒的关系，不是我渴望的事物。
我渴求的，其实是酸得要命的葡萄。
哪怕那串葡萄再酸、再苦涩、再难吃、甚至有毒，或根本不存在、不可能得到、连「想要」的想法都不被允许——
「即使如此……」
等察觉时，话语已经脱口而出。我听得出自己的声音在颤抖。
「我还是……」
我用尽全力避免自己哽咽，牙根发出咯吱声响。尽管想把声音跟话语通通吞回去，它们却一而再地突破我的齿缝。
「我还是，想得到『真物』。」
第八章. 于是，雪之下雪乃—— 雪之下望着下方的景色，发出一阵轻叹。
「比企谷同学。」
「嗯？」</description>
    </item>
    
    <item>
      <title>Java与C&#43;&#43;中的值传递和引用传递解析</title>
      <link>/posts/2021/05/value-passing-and-reference-passing-parsing-in-java-and-c/</link>
      <pubDate>Sat, 01 May 2021 20:16:39 +0800</pubDate>
      
      <guid>/posts/2021/05/value-passing-and-reference-passing-parsing-in-java-and-c/</guid>
      <description>先说结论：Java只有值传递，而C++既有值传递又有引用传递。
Java的参数传递 先定义3个方法如下：
1 2 3 4 5 6 7 8 9 10 11 public static void change1(String str, int num) { str = &amp;#34;world&amp;#34;; // 这里就相当与新new了一个对象! num = 100; } public static void change2(User user) { user.age = 1; user.name = &amp;#34;mary&amp;#34;; } public static void change3(User user) { user = new User(1, &amp;#34;mary&amp;#34;); } 进行测试：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static void main(String[] args) { String str = &amp;#34;hello&amp;#34;; int num = 1; System.</description>
    </item>
    
    <item>
      <title>Window实用命令记录之文件操作</title>
      <link>/posts/2021/04/file-operation-recorded-by-window-utility-command/</link>
      <pubDate>Mon, 19 Apr 2021 13:48:19 +0800</pubDate>
      
      <guid>/posts/2021/04/file-operation-recorded-by-window-utility-command/</guid>
      <description>创建文件或文件夹 cmd下创建文件 1 type nul &amp;gt; test.jpg powershell下创建文件 1 new-item test.jpg 创建文件夹 1 mkdir test 重命名文件 注意不能指定到新的路径。
1 PS D:\a\tmp\test&amp;gt; ren test.txt my.txt 移动文件 该命令也可用于重命名。
1 PS D:\a\tmp\test&amp;gt; move test.jpg mydir 复制文件和文件夹 copy无法递归复制，而xcopy可以。
1 PS D:\a\tmp\test\mydir&amp;gt; copy test.jpg test1.jpg 1 2 3 4 5 6 7 8 9 10 11 12 # mydir not empty PS D:\a\tmp\test&amp;gt; copy mydir mydir1 PS D:\a\tmp\test&amp;gt; ls mydir1 # empty PS D:\a\tmp\test&amp;gt; xcopy mydir mydir2 目标 mydir2 是文件名 还是目录名 (F = 文件，D = 目录)?</description>
    </item>
    
    <item>
      <title>《人间失格》文摘</title>
      <link>/posts/2021/04/human-disqualification-abstract/</link>
      <pubDate>Sun, 11 Apr 2021 23:13:01 +0800</pubDate>
      
      <guid>/posts/2021/04/human-disqualification-abstract/</guid>
      <description>作者：太宰治
手记之二 新学年伊始，山樱树在强韧的褐色嫩叶烘托和蔚蓝的大海映衬下，绽放绚烂的花朵，待到落英缤纷时节，如飞雪般坠下的樱花飘飘洒洒散向大海，装点着海面，随波荡漾，被浪花复又拍打回岸边。
真孤单……比起她冗长的身世来，仅就这一句叹息便足以唤起我的共鸣。我一直期待着，可是，我从未从这世上的女人口中听到过这句话，这使我感到奇怪和难以理解。不过，虽然她没有用语言说出“孤单”两字，但似乎她身上就散发着这般无言的孤寂，好似有股一寸来宽的气流带包裹着她，在她身旁，我好像也被那股气流包裹，与我特有的带刺的阴郁气流相互交融，犹如落入水底附着在岩石上的枯叶，使我得以从恐惧和不安中抽离。
手记之三 他面容下潜藏着某种狡诈嗤笑的那一刻，令我永远难以忘怀。那东西似轻蔑，却又有所不同，倘若将人世间比作大海，在那千丈深的海底就漂摆曳动着那种诡异的面容，仿佛故意露出隙孔，让人一窥成年人生活的深层奥趣似的——就是那种笑。</description>
    </item>
    
    <item>
      <title>春物文摘一</title>
      <link>/posts/2021/04/spring-abstracts-i/</link>
      <pubDate>Sun, 11 Apr 2021 11:51:03 +0800</pubDate>
      
      <guid>/posts/2021/04/spring-abstracts-i/</guid>
      <description>作者：渡航
卷二 第五章. 比企谷八幡再一次回归原来的道路 「才不是那样子……根本不是那样……」
她说得很小声。由比滨总是那么温柔，所以直到最后仍旧温柔。
如果说真相是残酷的，那么谎言想必很温柔。所以，温柔只是一种谎言。
卷四 第五章. 雪之下雪乃独自仰望星空 每个人都会为过去所困，不论我们自以为已经往前走多远，只要在不经意间抬起头，往事便像星光一样缓缓降下。
我们无法一笑置之，也无法把它们变不见。
那些事情永远会待在我们心中的一角，与某个时刻突然苏醒。
卷六 第十章. 他跟她终于找出正确的答案 「比企谷，帮助其他人不能当做伤害自己的理由。」
鼻腔内是淡淡的香烟味，脸上是难以想像为同一个人的温柔指尖。她潮湿的双眼，有如看透我的内心。
「不，这种程度不至于让我受伤……」
「……就算你已经习惯那种痛也一样。过了这么久，你总该明白有些人看到你受伤，一样会觉得心痛。」
卷七 第六章. 雪之下雪乃安静地走在夜晚的街道 但是，我没有见过这样的雪之下。
她不断注意周遭，同时看着我的脚边，以免找不到回去的路。
她难为情地垂下双眼，发现我走太快时，还伸出犹豫不决的手，想要我放慢速度，接着又惊觉似地把手缩回——我从来没见过这些举动。
我被她生硬的举动感染，不知不觉间变得同手同脚，也因为如此，尽管旅馆离这里很近，我却觉得远得要命。
我们两人始终若即若离，怎样都不会并肩走在一起。</description>
    </item>
    
    <item>
      <title>实现SSH免IP免密登录</title>
      <link>/posts/2021/01/realize-ssh-ipfree-and-secret-free-login/</link>
      <pubDate>Wed, 13 Jan 2021 21:53:43 +0800</pubDate>
      
      <guid>/posts/2021/01/realize-ssh-ipfree-and-secret-free-login/</guid>
      <description>编辑 ~/.ssh/config 1 2 3 4 5 6 7 8 9 Host 输入代替名 HostName 输入IP Port 输入端口号 User 输入用户名 # ProxyCommand &amp;#34;C:\Program Files\Git\mingw64\bin\connect.exe&amp;#34; -S 127.0.0.1:7890 -a none %h %p # 定时发送心跳确保不断开连接 ServerAliveInterval 30 # 每隔30秒发送一次 ServerAliveCountMax 60 # 连续60次服务端无响应断开连接 生成并发送密钥 1 ssh-keygen -t rsa 然后将公钥 ~/.ssh/id_rsa.pub 复制到目标主机 ~/.ssh/authorized_keys 文件中。
可能出现的问题：密钥算法不匹配 如果出现以下错误：
no matching key exchange method found. Their offer: diffie-hellman-group1-sha1
则是本地密钥算法与远程主机密钥算法不匹配造成的！
可以在ssh_config或config文件中添加密钥算法配置：
1 2 3 4 5 Host 输入代替名 HostName 输入IP Port 输入端口号 User 输入用户 KexAlgorithms +diffie-hellman-group1-sha1 From my blog: akynazh.</description>
    </item>
    
    <item>
      <title>Linux实用操作之网络管理</title>
      <link>/posts/2021/01/network-management-of-linux-practical-operation/</link>
      <pubDate>Sun, 03 Jan 2021 00:27:58 +0800</pubDate>
      
      <guid>/posts/2021/01/network-management-of-linux-practical-operation/</guid>
      <description>查看内网IP grep抓取inet行，sed删除inet字串和netmask.*字串
1 alias myip=&amp;#34; ifconfig eth0 | grep &amp;#39;inet &amp;#39; | sed &amp;#39;s/inet//g&amp;#39; | sed &amp;#39;s/netmask.*$//g&amp;#39;&amp;#34; test:
1 2 [root@VM-0-11-centos ~]# myip 172.17.0.11 查看外网IP 1 curl cip.cc show:
IP : ${my_ip} 地址 : 中国 中国
数据二 : 上海市 | 腾讯云
数据三 : 中国北京北京 | 腾讯
URL : http://www.cip.cc/${my_ip}
查看IP端口状况 1 2 3 4 5 6 [root@VM-0-11-centos ~]# netstat -ntlp Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.</description>
    </item>
    
    <item>
      <title>图的着色问题汇总</title>
      <link>/posts/2020/12/summary-of-coloring-problems-of-graphs/</link>
      <pubDate>Sat, 05 Dec 2020 12:34:05 +0800</pubDate>
      
      <guid>/posts/2020/12/summary-of-coloring-problems-of-graphs/</guid>
      <description>二分图问题 能否只用2种颜色对一个图上色，并且使得共边顶点不同色？
代码解决：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 vector&amp;lt;int&amp;gt; G[MAX_V]; int vertexes; int edges; int color[MAX_V]; //二分图，颜色为1或-1 bool dfs(int v, int c) { color[v] = c; for (int i = 0; i &amp;lt; G[v].size(); i++) { if (color[G[v][i]] == c) return false; if (color[G[v][i]] == 0 &amp;amp;&amp;amp; !dfs(G[v][i], -c)) return false; } return true; } void solve() { for (int i = 0; i &amp;lt; vertexes; i++) { if (color[i] == 0) { if (!</description>
    </item>
    
    <item>
      <title>求解有向图和无向图中是否存在环的方法</title>
      <link>/posts/2020/12/a-method-to-solve-whether-there-are-rings-in-directed-graphs-and-undirected-graphs/</link>
      <pubDate>Wed, 02 Dec 2020 23:50:44 +0800</pubDate>
      
      <guid>/posts/2020/12/a-method-to-solve-whether-there-are-rings-in-directed-graphs-and-undirected-graphs/</guid>
      <description>求解无向图中是否存在环 无向图中是否存在环，可以通过DFS来实现。
由于他是无向图，所以每次开始一次新的递归即进入一个新的连通子图，在该次dfs中可以通过判断新纳入的结点是否与所在连通子图中其他已经访问过的结点存在边，如果存在则证明存在环。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int mat[maxn][maxn], vis[maxn]; int dfs(int v) { vis[v] = 1; for (int i = 0; i &amp;lt; num; i++) if (mat[v][i]) { if (vis[i] || dfs(i)) return 1; // 该连通子图新纳入的结点与原连通子图中的某一结点有边，即产生了环 } return 0; } memset(vis, 0, sizeof(vis)); int flag = 0; // 无环标志 for (int j = 0; j &amp;lt; num; j++) { if (!</description>
    </item>
    
    <item>
      <title>二次元随想</title>
      <link>/posts/2020/11/two-dimensional-capriccio/</link>
      <pubDate>Sat, 28 Nov 2020 18:24:12 +0800</pubDate>
      
      <guid>/posts/2020/11/two-dimensional-capriccio/</guid>
      <description>之前看完冰菓之后，内心有一丝莫名的伤感。最近终于也把春物小说读完了，同样的感觉又涌上心头，这是一种难以言说的情愫。
也许是对一段故事谢幕的不舍。欣赏一部优秀的作品，走进另一个世界，见证一段故事。在故事尾声，我总希望剧情能不断延长下去。可就像一段青春时光，一段故事总要落幕。结束了的就只能成为回忆&amp;hellip;&amp;hellip;虚拟世界里的东西，往往是现实中难以企及的。
也许是对二次元世界的那种向往。 二次元世界有着独特的美感，每一个画面都扣人心弦，那种干净的，美好的画面，都是现实中难以遇见的。尤其是京阿尼的冰菓，每一帧画面都是精品。所以在经历了一段时间的美感洗礼之后又回到现实，我也许因此莫名的迷惘，失落吧。
也许是对故事中那种青春的向往。 想体验那种玫瑰色的青春，体验青春中真挚的，纯真的感情。随着时间流逝，我也许已经不再有机会。
不管如何，二次元，再扩展到所有的文学艺术作品，与现实都是有一定的距离的。但就算是如此，我们一样可以在现实中找寻生活的美与希望。尽管我们难以企及故事中的那般美好，生活有时总是那么不如意，但是我觉得只要自然地生活下去，用心生活下去，总能在不经意间体会到现实生活中的，不一样的美，与快乐。
另外，阅览一个故事，也可以算是经历了一段故事吧，尽管不是故事的主人公，但也已经在自己的人生中体验到了另一种生活的感觉，尽管那种体验不那么真实，但它也给你带来了一笔无比珍贵的宝物。
每个人都会过完自己独特的一生吧，把握住当下，去做自己喜欢做的事，对，这一点就是我觉得的，很重要的东西。不要浮躁，不要回到曾经的那种焦虑与迷惘。切实地理解自己，品味生活，偶尔让身心慢下来，不要逼自己去做太多不必要的事情。“不必要的事情不管，必要的事情尽快完成”，这种节能思想我觉得还是很值得借鉴的。毕竟我觉得懂得偷闲的人，也许都过的更快乐一点吧。</description>
    </item>
    
    <item>
      <title>equals方法和==运算符的作用区别</title>
      <link>/posts/2020/11/the-difference-between-the-equals-method-and-the---operator/</link>
      <pubDate>Wed, 25 Nov 2020 00:21:05 +0800</pubDate>
      
      <guid>/posts/2020/11/the-difference-between-the-equals-method-and-the---operator/</guid>
      <description>equals方法与&amp;quot;==&amp;ldquo;的比较与分析 首先提出一个重要的点:
== 比较时进行地址的比较
equals 比较时进行值的比较
1 2 3 4 5 6 7 8 9 String a = &amp;#34;123&amp;#34;; String b = &amp;#34;123&amp;#34;; System.out.println(a.equals(b)); // true System.out.println(a == b); // true String a1 = new String(&amp;#34;123&amp;#34;); String b1 = new String(&amp;#34;123&amp;#34;); System.out.println(a1.equals(b1)); // true System.out.println(a1 == b1); // false 好像没问题。
然而阅读源码Object类，可以发现对象中默认equals方法进行的是地址的比较
1 2 3 public boolean equals(Object obj) { return (this == obj); } 再阅读源码String类，可以发现String类中重写了equals方法，覆盖掉了Object的equals方法，所以String的equals是值比较！
1 2 3 4 5 6 7 8 9 10 11 12 13 public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String aString = (String)anObject; if (coder() == aString.</description>
    </item>
    
    <item>
      <title>Cmd重要且实用的一些命令</title>
      <link>/posts/2020/11/cmd-some-important-and-practical-commands/</link>
      <pubDate>Fri, 20 Nov 2020 18:17:33 +0800</pubDate>
      
      <guid>/posts/2020/11/cmd-some-important-and-practical-commands/</guid>
      <description>写入文件 写入hello字符串（同时新建了a.txt） 1 echo hello &amp;gt; a.txt 追加写入hello字符串 1 echo hello &amp;gt;&amp;gt; a.txt 将a.txt内容追加写入b.txt 1 type a.txt &amp;gt;&amp;gt; b.txt 新建文件 新建空文件a.txt 1 type null &amp;gt; a.txt 换行（分号换行输出） 1 echo hello; echo peter 关于程序编译 test.cpp: 一个含cin输入的程序
编译cpp
1 g++ test.cpp -o test 以1.in作为标准输入，2.out作为标准输出执行test
1 test &amp;lt; 1.in &amp;gt; 2.out test_err.cpp: 一个会导致编译错误的程序
把编译后出现的错误输入log.txt，命令行不会报错
1 g++ test_err.cpp -o terr 2&amp;gt; log.txt 打开并编辑文件 cmd下没有bash下好用的vim=_=
使用记事本打开编辑 1.py
1 notepad 1.py 记事本不好用呀，还是vscode香，如下~
使用vscode打开编辑1.py，首先需配置环境变量
(${vscodepath}\bin)
1 code 1.</description>
    </item>
    
    <item>
      <title>矩阵快速幂的介绍及其应用</title>
      <link>/posts/2020/11/introduction-and-application-of-matrix-fast-power/</link>
      <pubDate>Wed, 18 Nov 2020 23:47:15 +0800</pubDate>
      
      <guid>/posts/2020/11/introduction-and-application-of-matrix-fast-power/</guid>
      <description>矩阵快速幂介绍 题目描述
给定n×n的矩阵A，求 A^k。
输入格式
第一行两个整数 n,k 接下来n行，每行n个整数，第i行的第j个数表示Aij。
输出格式
输出 A^k
共n行，每行n个数，第i行第j个数表示Aij, 每个元素对 10^9+7取模。
1 &amp;lt;= n &amp;lt;= 100
0 &amp;lt;= k &amp;lt;= 10 ^ 12
|Aij| &amp;lt;= 1000
分析：
本质上就是快速幂运算，只是底数变成了一个矩阵。
快速幂运算板子： 1 2 3 4 5 6 7 8 9 10 typedef long long ll; ll mod_pow(ll x, ll n, ll mod){ ll res = 1; while(n &amp;gt; 0){ if(n &amp;amp; 1 == 1) res = res * x % mod; // 如果指数是奇数则乘上底数 x = x * x % mod; // 底数平方 n &amp;gt;&amp;gt;= 1; // 指数除二 }	return res; } 由此易得：</description>
    </item>
    
    <item>
      <title>最短路问题汇总</title>
      <link>/posts/2020/11/summary-of-shortest-path-problems/</link>
      <pubDate>Tue, 17 Nov 2020 17:55:32 +0800</pubDate>
      
      <guid>/posts/2020/11/summary-of-shortest-path-problems/</guid>
      <description>注意，这里为了方便描述算法，所以都用了最易理解的邻接矩阵来写，比赛中为了追求效率，一般将邻接矩阵改为链式前向星或者邻接表。
迪杰斯特拉算法 O(V^2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 const int MAXN = 100; const int INF = 0x3f3f3f3f; // 有向无环图 DAG int V, E; // 顶点数和边数 int graph[MAXN][MAXN]; // DAG邻接矩阵，初始值为INF，不可达为INF，否则为cost值 int d[MAXN]; // 从某点s出发到其它任意结点的最短路径长度，初始值为INF int visited[MAXN]; // 某点是否访问过，访问过则为1否则为0 // 初始化图 void init() { memset(graph, 0x3f, sizeof(graph)); cin &amp;gt;&amp;gt; V &amp;gt;&amp;gt; E; int from, to, cost; for (int i = 0 ; i &amp;lt; E; i++) { cin &amp;gt;&amp;gt; from &amp;gt;&amp;gt; to &amp;gt;&amp;gt; cost; graph[from][to] = cost; } } // 迪杰斯特拉算法求解最短路，针对点展开 void Dijkstra(int s) { memset(d, 0x3f, sizeof(d)); memset(visited, 0, sizeof(visited)); visited[s] = 1; for(int i = 0; i &amp;lt; V; i++) d[i] = graph[s][i]; d[s] = 0; int k, min_cost; // 无负边时最多更新n-1(其他结点数)次 for(int i = 0; i &amp;lt; V - 1; i++){ min_cost = INF; // 寻找最未被访问的且权值最小的路径，需要优化的地方 for(int j = 0; j &amp;lt; V; j++){ if(!</description>
    </item>
    
    <item>
      <title>关于辗转相除法和扩展欧几里得算法</title>
      <link>/posts/2020/07/on-rolling-division-and-extended-euclidean-algorithm/</link>
      <pubDate>Tue, 21 Jul 2020 20:48:53 +0800</pubDate>
      
      <guid>/posts/2020/07/on-rolling-division-and-extended-euclidean-algorithm/</guid>
      <description>gcd辗转相除法求最大公约数 思路：反复交换取余，直到小的数为0。
1 2 3 4 int gcd(int a, int b){ if(b == 0) return a; return gcd(b, a % b); } exgcd扩展欧几里得算法 先介绍贝祖定理：
若a,b为整数，则一定存在整数x,y，使得$ax + by = gcd(a,b)$。
即若$ax + by = m$有解，则m一定为gcd(a,b)的若干倍。
下面是一道题：
有a, -a, b, -b四个整数，各用几次可以使得$ax + by = 1$?
由上述思想则可知gcd(a,b)等于1，可编写一个返回值为gcd(a,b)同时递归计算x和y的函数。
关于求出x和y推导过程：
由$ax + by = gcd(a,b)$ (1)
通过辗转相除法的思想得：$bx_1 + (a \mod b) y_1 = gcd(a,b)$
由$a \mod b = a - (a \div b) \times b$带入得:</description>
    </item>
    
    <item>
      <title>有关素数的一些算法</title>
      <link>/posts/2020/07/some-algorithms-about-prime-numbers/</link>
      <pubDate>Tue, 21 Jul 2020 20:43:04 +0800</pubDate>
      
      <guid>/posts/2020/07/some-algorithms-about-prime-numbers/</guid>
      <description>埃氏筛法 问1000000000000以内有多少个素数？
运用朴素算法必TLE，这时考虑埃氏筛法。
算法思路：
建立is_prime[]数组，初始化为true； 从2开始筛取，(注意从2开始很重要，因为2为素数，否则需要改变相应后续操作)，若为true，则继续判断是否为素数，若为素数，则将所有该素数的倍数置为false。 相应代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 bool is_prime[MAXN]; //返回n以内的素数个数 int sieve(int n) { int c = 0; for (int i = 2; i &amp;lt;= n; ++i) is_prime[i] = true; for (int i = 2; i &amp;lt;= n; ++i) if (is_prime[i]) { c++; for (int j = 2 * i; j &amp;lt;= n; j += i) is_prime[j] = false; } return c; } 区间筛法 问[21479862, 21499877)之间有多少个素数？</description>
    </item>
    
    <item>
      <title>Python自动爬取花瓣网任意面板中所有图片</title>
      <link>/posts/2020/02/python-automatically-crawls-all-pictures-in-any-panel-of-petal-net/</link>
      <pubDate>Thu, 13 Feb 2020 00:14:23 +0800</pubDate>
      
      <guid>/posts/2020/02/python-automatically-crawls-all-pictures-in-any-panel-of-petal-net/</guid>
      <description>注：该项目只适用于旧版花瓣，但其中的思路值得领会。对于新版花瓣编写的代码，逻辑差别不大。
需要安装的库 urllib easygui selenium webdriver_manager 获取过程 进入面板内 复制当前面板url 启动该脚本按提示进行即可 代码编写流程 分析pin图特点 查看面板源码，可以在对应的script中找到面板中图片的json数据。
在app.page[&amp;ldquo;board&amp;rdquo;]下可以找到&amp;quot;pins&amp;quot;:[{&amp;hellip;}]，主要图片ID(pin)位于这里面。
获取到图片的ID(pin)之后可以对应访问点击图片后进入的地址http://huaban.com/pins/pinId/，并获取页面源码：
显然可见主要图片的源码特征，书写对应正则表达式可以获取图片真实地址。
分析滚动特点 通过滚动页面我们可以发现加载规律：
原来的图片对应的代码：
经过滚动，原来的代码逐渐被一些新的代码取代：
而不难发现他们都有对应的data-id!而data-id就是图片地址中对应的pin。
所以我们可以通过webdriver滚动加载页面，每滚动一次就进行一次data-id的读取，并利用集合进行去重即可。
具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 # 花瓣用户任意面板图片爬取 import urllib.</description>
    </item>
    
    <item>
      <title>Matlab基本用法整理</title>
      <link>/posts/2020/02/basic-usage-sorting-of-matlab/</link>
      <pubDate>Thu, 06 Feb 2020 20:41:12 +0800</pubDate>
      
      <guid>/posts/2020/02/basic-usage-sorting-of-matlab/</guid>
      <description>基本语法方面 提取矩阵某行或某列 1 A(:, [2 3]) 返回第2和第3列 获取随机数 1 randi(100); % 1 到 100 之间的随机整数 初始化数组 1 zeros(1, 30); % 1行30列的全0数组 控制语句 1 2 3 4 5 6 7 8 9 10 for i = 0 : 100 for j = 1 : 10 if (...) ... else ... end end ... end 格式化输出 1 fprintf(&amp;#34;若选手选择改变，则成功次数为：%d, 成功率为：%f\n&amp;#34;, count, count / SUM); 初等数学方面 求解方程组 注：solve已经改版，不可传入字符串
实例：求解二元一次方程
1 2 3 4 syms x y; s = x - 6 * y == 2; t = 5 * x + 4 * y == 3; result = solve(s, t); 求平均值，中值与标准差 1 2 3 4 5 A = [12 13 7 18 16 21 9 10 2 18]; A = sort(A); ave = mean(A); md = median(A); sigma = std(A); 解一阶导数方程 1 2 3 4 5 syms x y; y = -0.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>And when I awoke I was alone
This bird had flown
So I lit a fire
Isn&amp;rsquo;t it good Norwegian wood</description>
    </item>
    
  </channel>
</rss>
