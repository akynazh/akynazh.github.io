[{"categories":["Tool"],"contents":"安装 1 2 3 4 wget https://github.com/Dreamacro/clash/releases/download/v1.11.8/clash-linux-amd64-v1.11.8.gz gzip -d clash-linux-amd64-v1.11.8.gz sudo mv clash-linux-amd64-v1.11.8 /usr/bin/clash chmod +x /usr/bin/clash 获取订阅链接并配置 在自己使用的机场中获取clash订阅链接，然后下载配置文件到 ~/.config/clash/config.yaml:\n1 2 3 4 5 6 7 8 9 10 11 12 mkdir -p ~/.config/clash cd ~/.config/clash wget -O config.yaml {link} vim config.yaml # 不允许局域网中其它电脑使用该代理 allow-lan: false # 设置 clash 管理界面密码 secret: your password # 允许从外部访问 clash 管理界面，其中端口 9090 可自行配置 external-controller: \u0026#39;0.0.0.0:9090\u0026#39; 运行代理并选择节点 1 2 3 4 # 第一次需要下载Country.mmdb，可考虑先运行以下命令 # clash -f ~/.config/clash/config.yaml nohup clash -f ~/.config/clash/config.yaml \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; 登录clash管理界面进行网速的测试和节点的切换：\n访问clash.razord.top，设置Host为主机IP，端口默认为9090，密钥为刚刚配置的密码。\n最后设置proxy环境变量，可通过alias进行配置以方便使用。\n实现开机自启动 vim /etc/systemd/system/clash.service\n1 2 3 4 5 6 7 8 9 10 11 [Unit] Description=Clash Proxy [Service] WorkingDirectory=/root ExecStart=/usr/bin/clash -f .config/clash/config.yaml \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 Type=simple RemainAfterExit=yes [Install] WantedBy=multi-user.target 1 2 3 4 5 systemctl daemon-reload systemctl start clash systemctl status clash systemctl enable clash From my blog: akynazh.\nOver.\n","permalink":"/posts/2023/01/clash-linux-configuration-usage-record/","tags":["proxy"],"title":"Clash-Linux 配置使用记录"},{"categories":["Life"],"contents":"八度 我们可以用唱名Do[1] Re[2] Mi[3] Fa[4] Sol[5] La[6] Ti[7] Do[8]唱出歌曲的旋律，“[]”中的数字就是 音级（Degree ）。\n我们以Do[1]到Do[1]为一度，Do[1]到Re[2]为二度，以此类推。于是从Do[1]到上面Do[8]之间音高上的距离(音程，Interval)就叫做 八度（Octave），因此说Do[8]比Do[1]高了一个八度。\n音名和唱名 音名：用C，D，E，F，G，A，B来标记基本音级的，叫做音名，它们表示一定的音高。\n唱名：与C，D，E，F，G，A，B对应的唱名用do、re、mi、fa、so、la、si来作为 音级 名称。\n在吉他中，从六弦到一弦，音名依次为E，B，G，D，A，E。\n半音与十二平均律 在乐音体系中，音高关系最小的计量单位叫 半音（Semitone），两个半音就是一个全音。\n在C，D，E，F，G，A，B，C中，EF和BC 之间相差一个半音，其它相邻音相差一个全音。\n在吉他中，相邻两个品格之间相差半音。\n十二平均律（Equal temperament），或平均律, 是将八度的二倍音程等比例地划分为十二份的定律方式。它让每一个临近的音在音程上都是同样的倍数关系。这每一个音和主音Do[1]组成的音程的倍数关系分别是 $2^{n/12}$，n=0到12。\n当 n=12，倍数正好是 二倍 即纯八度，它对应的音名和当 n=0 时纯一度上的音是一样的。所以去掉12，从0数到11正好产生十二个不一样的音名。\n对于C大调，如果是以国际标准音 A-la-440HZ 为准，通过十二平均律可以计算出各个音的频率（单位：HZ）为：\nC C#/Db D D#/Eb E F F#/Gb G G#/Ab A A#/Bb B 261.6 277.2 293.7 311.1 329.6 349.2 370.0 392.0 415.3 440.0 466.2 493.9 可以看出，根据十二平均律分出了12个音，每个音之间相差的频率大小就是一个半音的大小。\n音组 不同八度的音名如果都长一样会造成误解，因此有必要用不同的标记以示区分。\n音高的标记国际上通用两套体系：科学音高记号法 与 亥姆霍兹音高记号法。\n科学音高记号法 我们把从C开始的一个八度设定为一个音组，音组中的音名用大写英文字母CDEFGAB和升降符号标记。每个音组都把C作为音组的第一个音，B作为音组的最后一个音。\n人耳的听力极限在 20Hz - 20,000Hz 左右，随年龄稍有衰减。这个频率区间跨度大约在十个八度，所以使用十一个音组就能完全将人耳听力范围涵盖在内。\n于是，我们可以用数字0-10来标记这十一个音组。最低一个的音组对应数字0，最高一个对应数字10。\n在标记音高时，音名的大写字母在前，数字在后。\n中央C标记为 C4，标准音高A440记为A4，这两个音都落在4号音组中。\n最低一个0号音组中的C是16.35Hz，标记为C0。这个音组的最后一个音是B0，由B0升高一个半音可以得到下一个音组中的第一个音C1。\n最高的一个10号音组中，B的频率在31608Hz，标记为B10。\n亥姆霍兹音高记号法 在钢琴正中央的一组音级（包括基本音级和变化音级的十二个音级\u0026ndash;从C到B）叫做“小字一组”。用小写字母c、d、e、f、g、a、b来表示，并在其右上方标记出阿拉伯数字1。如：c1、d1、e1、f1、g1、a1、b1。\n比小字一组高的音组由低到高分别定名为“小字二组” \u0026hellip;\u0026hellip; “小字六组”等等。并在其右下方用阿拉伯数字1或2、3、4。如小字三组的D就标记为d3。\n比小字一组低的音组由高到低分别定名为“小字组”，“大字组”、“大字一组”、“大字二组”、“大字三组”、“大字四组”等等。\n其中大字组的音用大写字母C、D、E、F、G、A、B来表示，并在其右下方用阿拉伯数字1或2、3、4。如大字二组的D就标记为D2。\n音阶和调式 音阶（Scale） 在音乐理论中，一个音阶是按照 泛音列或音高 排列，并因其规律形成循环的一系列音符。八度中选取任意一组音，它们的音高由低到高依次排列就能组成一条音阶。\n音阶的 类型 叫做 调式(mode)。从主音出发，特定的音程组合形成特定的调式类型，如大调，小调。\n像钢琴键盘白键这样，一个双全音群和一个三个全音的群，两个群由半音衔接在一起，这样组成的音阶就叫做 自然音阶（Diatonic scale）。\n自然音阶有七个不同的音，因此属于七声音阶。自然音阶有七种调式，各自拥有独特的气质。其中大小调是最常用的2种。\nIonian调式，音阶的音程向上以 全全半全全全半 排列，调性音乐中称它为“大调”。用大调写的音乐一般给人的感觉或轻松舒缓或积极阳光。\nAeolian调式，音程向上以 全半全全半全全 排列，调性音乐中称“小调”。小调音乐带有忧郁哀伤的气质。\n对于“C大调”，就是以C为主音，以大调作为调式。\n音调，响度，音长和音色 音调（音高，Pitch） 的高低决定于发声体振动的频率，声源1秒钟内振动的次数叫频率，它反映振动的快慢，频率高，物体振动快。频率高，音调高。\n空气柱越短，音调越高，反之越低 琴弦越紧，音调越高，反之越低 琴弦越细，音调越高，反之越低 在吉他中，六弦最粗，所以音调最低，而一弦最细，所以音调最高。通过调弦，即转动吉他上方六个旋钮，可以调节琴弦的松紧程度。\n响度（音强，loudness） 反映声音的大小，响度的大小与振幅有关，还与离声源距离有关，越远声音越弱。\n弹琴所用的力度越大，响度就越大。\n音长（时值，Note value），是指声音的长短，它决定于发音体振动时间的久暂。\n音色（音品，Timbre），是发声体的不同而造成的，我们可以根据音色不同，从而区别不同的声音。\n吉他跟钢琴都能发出同一个音高，但它们的听感是不一样的。吉他有吉他的音色，各种乐器都有自己的音色，每个人嗓音也是一个独一无二的音色。\n乐器演奏出的音符并非只有一个音高频率，而是有一组频率。基频是这组音音高最低的频率，通常把基频定义为 音符的音高。而其他的高频则遵循一个规律，它们的频率都是基频的 正整数倍，这些高频叫做 泛音。基频和其他高频之间的关系决定着乐器的音色。\n噪音和乐音 对于振动有规律，具有明显基频和泛音，能分辨出音高的声音叫做 乐音（Musical tone）。\n对于振动没有规律无法清晰分辨基频泛音的声音则叫做 噪音（Noise）。\n音乐三要素 音乐的三要素是 节奏（Rhythm）、和声（Harmony）、旋律（Melody）。\n三要素之间的结合方式叫做 织体（Texture）。\n这是几种常见的音乐织体：\n单调音乐：由一根旋律线单独进行的音乐织体。 复调音乐：由多个独立的旋律线并行构成的织体。 支音音乐：所有乐器声部都在演奏和模仿同一个旋律构成的织体。 主调音乐：由一条旋律线配以和声进行来构成的织体。 音符与旋律 音乐中的单词就叫做 音符（Note），而 旋律就是由音符的组织出来的。\n旋律从音符、乐句、段落一直延伸还可以构建出乐章、乃至全曲。像这样在音乐中篇章的结构安排就叫做曲式。\n和弦与和声 现代音乐概念里面，由 多个不同的音高 同时发声就形成 和声。\n三个或三个音以上 的和声就叫做 和弦（Chord）。\n节奏、节拍与小节 节奏，即有规则有循环的律动。\n对于 节拍（Beat），就像音高可以用半音作为刻度划分，时间也可以用节拍（拍子）作为单位刻度来划分。音乐的速度快慢可以用每分钟节拍的数量来测算。\n对于 小节（Bar/Measure），我们把每一个周期的循环设定为一个小节。\n全音符 音符时值的全长单位叫做 全音符（Whole note），一个全音符二等分得半音符，再二等分成得四分音符，继续切割可以得到八分音符，十六分音符，和三十二分音符。\n实践中，我们常常把 四分音符或者八分音符 的时值设定为一个节拍。\n我们如何确定全音符的时值呢？\n假设拍速是120，也就是说每分钟120拍，则一拍有半秒，那么那全音符的时值就是两秒。\n实际应用中，拍速可以自己定，觉得合适即可。\n拍号 谱子中出现的类似“4/4”这样的标记就是 拍号（Time signiture / Meter signiture）。\n拍号的分子对应小节的拍型，这里的4就是指每小节有四拍。\n而分母则是对应节拍和时值的关系，这里的4就是指以四分音符为一拍。\n休止符 不发声的音符叫做 休止符（Rest ）。\n全休止符就是休止一个全音符长度，而四分休止符就是休止全音符长度的四分之一。\n参考：\noh music theory 维基百科 From my blog: akynazh.\nOver.\n","permalink":"/posts/2023/01/record-of-basic-music-theory-knowledge/","tags":["music"],"title":"基本乐理知识记录"},{"categories":["Language"],"contents":"关于pipenv pipenv集成了pip，virtualenv两者的功能，且完善了两者的一些缺陷。\n安装pipenv 1 pip install pipenv -U 创建虚拟环境 初次创建环境可以使用以下类似命令：\n1 pipenv install --python C:/Users/akyna/AppData/Local/Programs/Python/Python37/python.exe --pypi-mirror https://pypi.tuna.tsinghua.edu.cn/simple --python 是可选的，可以指定python版本，参数为python解释器的绝对路径，如果不指定，默认使用当前系统的python。\n--pypi-mirror 是可选的，可以指定镜像，加速下载。\n创建好后，在当前目录下将会生成 Pipfile 文件，在 ~\\.virtualenvs 下生成虚拟环境目录（存放python解释器和依赖）。\n如果目录中已经存在 Pipfile 或者 requirements.txt，pipenv会自动检测这两个文件并将对应依赖进行安装。\n查看虚拟环境目录位置：\n1 pipenv --venv 激活虚拟环境 1 2 3 pipenv shell # 激活虚拟环境 python -V 如果激活了虚拟环境，在当前shell下，使用的python或者pip都是虚拟环境中的python和pip。\n配置Pip并安装依赖 配置镜像源为清华源：\n1 2 3 4 vim Pipfile [[source]] url = \u0026#34;https://pypi.tuna.tsinghua.edu.cn/simple\u0026#34; 以后所有依赖的安装都不需要指定 --pypi-mirror 了。\n安装依赖：（建议关闭代理，如果有的话）\n1 2 pipenv install {pkg} # 如果激活了虚拟环境，可以使用pip # pipenv install -r requirements.txt 安装完依赖后，将会生成 Pipfile.lock 文件，以后初始化虚拟环境都只需要运行 pipenv install 即可完成所有依赖的安装。\n当然，也可以通过生成 requirements.txt 的方式进行，下次初始化虚拟环境时，pipenv也会自动识别目录下的 requirements.txt：\n1 pipenv requirements \u0026gt; requirements.txt 通过 pipenv graph 可以查看目前安装的库及其依赖。\n以后新安装任何依赖，如果处在虚拟环境下，都可以直接运行 pip install {pkg} 完成包的安装，但是如果这样安装，新的依赖信息并不会被添加到 pipfile 中，也就不利于之后重新初始化环境和生成正确的 requirements.txt 。因此，建议每次安装新的依赖包时都使用 pipenv install {pkg} ，这样新的依赖信息会被写入 pipfile 和 pipfile.lock 中。\n关于Pipfile和Pipfile.lock 这两个文件是相互补充的关系。\n首先，对于pipfile, 里面一般记录了以下类似内容：\nSource: 记录包的下载地址源 Dev-packages : 记录当我们开发时所需要使用的包的相关信息 Packages: 用于记录我们程序运行所依赖的包 Requires: 指定了使用的python的版本 然后，对于Pipfile.lock文件，\n这是一个json类型的文件，在这个文件里面，它记录了：\n开发所用的包和其详细的版本 记录了源代码的包的下载地址，其中的hash值用于包的验证 使用 pipenv lock 可以更新Pipfile.lock文件，lock操作将让安装依赖的时间变长，可以通过 --skip-lock 来跳过lock操作。\n对于 Dev-packages 字段，使用 pipenv install 创建虚拟环境时需要添加 --dev 才会安装它对应的包（默认只安装Packages下的包）。\n安装依赖时，添加 --dev 将会把包依赖记录到 Dev-packages 下而不是 Packages 下。\n更新包 pipenv update 想当于运行 pipenv lock \u0026amp;\u0026amp; pipenv sync:\nlock: Generates Pipfile.lock. sync: Installs all packages specified in Pipfile.lock. 1 2 3 pipenv update --outdated # 查看所有需要更新的依赖项 pipenv update # 更新所有包的依赖项 pipenv update \u0026lt;包名\u0026gt; # 更新指定的包的依赖项 卸载包 1 2 3 pipenv uninstall XXX # 卸载XXX模块并从Pipfile中移除 pipenv uninstall --all # 卸载全部包并从Pipfile中移除 pipenv uninstall --all-dev # 卸载全部开发包并从Pipfile中移除 退出虚拟环境 1 2 3 exit # 退出当前虚拟环境 python -V # 将变为系统的python版本 删除虚拟环境 1 pipenv --rm # 删除虚拟环境 在~/.virtualenvs中的虚拟环境将被删除。\n运行文件 方式一：\n1 pipenv run python xxx.py 方式二：在激活环境中运行\n1 2 3 4 # 进入激活环境 pipenv shell # 运行文件 python xxx.py From my blog: akynazh.\nOver.\n","permalink":"/posts/2023/01/simple-use-record-of-pipenv/","tags":["python"],"title":"pipenv 简单使用记录"},{"categories":["Life"],"contents":"大三上半学期有个有趣的实验，要求学生设计电路并制作一个面包板。\n刚听到这个实验时，我倒是不怎么在意，感觉应该就是一个普通的硬件实验，应该挺快能完成水过去。\n到了实验室上手时才发现，确实还是太天真，很多事情并不是想象中那么容易的。\n第一次去做时，没做好充足准备。图没画好，几个元件的作用也没怎么搞懂。当时课程和其他实验也比较多，实验室和教室来回跑，没去成几次实验室，又觉得时间应该够，没和其他同学一起去实验室通宵，结果没能顺利做完，但基本搞懂了面包板的原理，申请到下一次实验。\n这一次算是可以心无旁骛地开始做面包板了，通过询问老师，理解了一些之前实验中尚不明白的点（特别是构建电源那一块，很感谢王老师的指导），然后便着手开始连线了。\n这次连线一开始是非常顺利的，我先搜集好了大部分要用到的原件，然后根据电路图，一个一个模块地连接好，每连完一个模块，就对该模块进行测试，确认仿真波形无误后便开始连接下一个模块。\n花了一个下午和晚上，已经完成3到4个模块的连接了，晚上8:30准时返回宿舍洗洗睡！\n第二天睡了懒觉，10点左右到达实验室，开始连线。连接 74LS153 那部分时，电路图较为复杂，连完之后，波形总是不正确，重新连又要话不少时间，所以我一直debug，debug，测试各个部分的电压，反复检查各个位置的连线\u0026hellip;\u0026hellip;\n不幸的是，还是没有发现问题所在，这很大一部分要归咎于我连得实在是太乱了，很难debug。中午到点了，肚子罢工了，只能去吃饭了！\n下午回宿舍困觉，到了3点多精神饱满，返回实验室。我下定决心，把那个模块的连线都拆了重新开始连！\n这次我吸取上次的教训，将该模块所有的连线都尽可能整洁有序地连好了，功夫不负有心人，连完后测试顺利通过了。\n到了下午6点左右，所有模块基本连完，想找老师验收，可惜到饭点了，老师不在，我也吃饭去咯。\n晚上找老师验收，图像看了，老师说没啥问题了。可惜老师说所有人要统一到明天验收，不能提前走。。真是令人费解的操作，遂返回宿舍摸鱼了。\n第二天前往验收，竟然在画图这部分出了点问题，第一次验收没通过，把图改了改，第二次顺利通过验收。如下是我的丑陋的面包板：\n实验结束了，要求拆掉板子。拆板子时，真是感慨万千，真正感受到“世上无难事，只怕有心人”这个哲理。\n我觉得真要想办成什么事，首先要做完充足的准备，不要轻敌，不能自大。\n要认真地去对待每一件事，不要在关键的时候还不知轻重，懒懒散散的。\n不懂的地方，经过思考后仍得不出解决方法的，要虚心请教老师或同学。\n要敢于去改变，就像当时debug许久无果，要敢于重新开始，不要害怕失败。\n最后就是，在接近于成功的边缘时，不要以为自己已经成功了，永远要沉得住气，不到最后一刻不要掉以轻心。\n2022-12-11：面包板日。\n感谢自己，以及给予我许多帮助的老师。\nFrom my blog: akynazh.\nOver.\n","permalink":"/posts/2022/12/some-insights-from-making-bread-boards/","tags":["circuit"],"title":"从面包板的制作中得到的一些感悟"},{"categories":["Web"],"contents":"REST，全称 Representational State Transfer，即表现层状态转移。\n符合REST规范的写法：\n1 2 3 4 POST http://www.test.com/lemon // 创建 Get http://www.test.com/lemon // 查询 PUT http://www.test.com/lemon // 修改 DELETE http://www.test.com/lemon //删除 不符合REST规范的写法：\n1 2 3 4 POST http://www.test.com/Createlemon // 创建 POST http://www.test.com/Querylemon // 查询 POST http://www.test.com/Modifylemon // 修改 POST http://www.test.com/Deletelemon //删除 也就是用 URL 定位资源，用 HTTP 描述操作。\n实际操作：\n对于前端，在 js 中可以指定请求类型，以通过 ajax 发送请求为例，可以通过 type 属性进行指定，假如我要进行一条插入操作，则 type 值应为 \u0026ldquo;PUT\u0026rdquo;:\n1 2 3 4 5 6 7 $.ajax({ type: \u0026#34;PUT\u0026#34;, url: \u0026#34;http://www.test.com/lemon\u0026#34;, contentType: \u0026#39;application/json\u0026#39;, data: JSON.stringify({ ID: \u0026#34;1\u0026#34; }), success: function (data, status) {} }); 对于后端，以 java 为例，对于 PUT 操作，即可对应采用 @PutMapping 进行指定。\n此外，对于前后端数据的交互，数据需要是 json 格式的，后端中可采用 @RestController 进行自动的转换，对象将会自动转换为 json 格式数据返回给前端。\nFrom my blog: akynazh.\nOver.\n","permalink":"/posts/2022/12/understanding-of-rest-style/","tags":["web"],"title":"对于 Rest 风格的理解"},{"categories":["Language"],"contents":"后端中与数据库交互时 数据库一般采用下划线命名，而对于 java 而言，实体类的命名应当是驼峰式的命名，所以在与数据库交互时需要注意进行转换。\n对于采用了 Mybatis-plus 框架的应用，无需考虑此问题，因为它已经帮我们做好转换了，对应的配置如下：\n1 2 3 mybatis-plus: configuration: map-underscore-to-camel-case: true 如果你数据库命名已经采用了驼峰式命名，需要将该配置置为 false。（默认为 true）\n对于没采用该框架的应用，需要注意在编写的 sql 语句中进行转换。\n关于后端返回的 json 数据 首先注意，json 采用驼峰命名法。\n一般对于前后端分离的项目，后端都是返回 json 格式数据，比如使用 @RestController 进行自动的转换。\n对于一个采用驼峰命名法命名的变量，比如 userId，转换后返回前端的 json 属性名是 userId，没有问题。\n但是当变量名为 uId时，转换后则变为 uid，这就产生了问题。我还测试了其它一些变量，如下：\n1 2 3 4 5 6 7 8 # userId {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;ok\u0026#34;,\u0026#34;obj\u0026#34;:{\u0026#34;userId\u0026#34;:\u0026#34;hello\u0026#34;}} # uId {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;ok\u0026#34;,\u0026#34;obj\u0026#34;:{\u0026#34;uid\u0026#34;:\u0026#34;hello\u0026#34;}} # Id {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;ok\u0026#34;,\u0026#34;obj\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;hello\u0026#34;}} # uuId {\u0026#34;code\u0026#34;:200,\u0026#34;msg\u0026#34;:\u0026#34;ok\u0026#34;,\u0026#34;obj\u0026#34;:{\u0026#34;uuId\u0026#34;:\u0026#34;hello\u0026#34;}} 可见当为 uId 和 Id 时，都会出现问题。\n一般可以考虑在后端变量命名时，不让第二个字符大写，或者采用 @JsonProperty(\u0026quot;uId\u0026quot;) 进行解决。\n关于前端的命名问题 css 采用串式命名法（kebab-case）。\n在串式命名法中，各个单词之间通过下划线“-”连接，比如：\n1 2 hello-world first-project js 采用驼峰命名法。\n关于 url 变量的命名问题 注意域名是不区分大小写的：\nhTTps://aKYnazh.site 和 https://akynazh.site 是一回事。\n但对于路径名称和变量则是区分大小写的，对于这些部分名称的命名，则需要视情况而定。\n但一般是字母全部小写和使用连词符（-）分割。\nFrom my blog: akynazh.\nOver.\n","permalink":"/posts/2022/12/naming-standard-problems-encountered-in-development/","tags":["naming"],"title":"开发中遇到的命名规范问题"},{"categories":["Tool"],"contents":"关于HEAD HEAD 代表当前分支的最新提交名称，它可以由一些修饰符进行修饰进而产生不同的含义。\n关于 HEAD~{n}\n~ 是用来在当前提交路径上回溯的修饰符。\nHEAD~{n} 表示当前所在的提交路径上的前 n 个提交（n \u0026gt;= 0）：\nHEAD = HEAD~0 （即当前最新的一次commit） HEAD~ = HEAD~1 HEAD~~ = HEAD~2 关于 HEAD^{n}\n^ 是用来切换父级提交路径的修饰符。\n当我们始终在一个分支比如 dev 开发/提交代码时，每个 commit 都只会有一个父级提交，就是上一次提交。此时 HEAD~1 等价于 HEAD^。\n当并行多个分支开发，feat1, feat2, feat3，完成后 merge feat1 feat2 feat3 回 dev 分支后，此次的 merge commit 就会有多个父级提交。\nHEAD^ = HEAD^1 第一个父级提交 HEAD^2~1 第二个父级提交的上一次提交 强行覆盖本地分支（不关心本地修改） 若在其它分支上进行了修改，而本地也有了一定的修改，但本地的修改是可以忽略的（或者你不小心放入了一些无关文件），那么，这时你很需要用强行覆盖这个操作。\n1 2 3 git fetch git reset --hard HEAD git merge origin/$CURRENT_BRANCH # 若已做映射：git merge 修改提交过的版本 修改上次提交 这里对提交的信息和作者进行修改，注意邮箱两侧由\u0026lt;\u0026gt;包括住\n1 2 git commit --amend --message=\u0026#34;modify\u0026#34; --author=\u0026#34;your_name \u0026lt;your_email\u0026gt;\u0026#34; git push -f 修改多次提交 进行 git rebase 之前，先将本地修改提交完毕。\n1 2 # 列出最近3次提交 git rebase -i HEAD~3 得到大致如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 pick 8ae7972 update pick 1a22dfd update pick 00433e4 update # Rebase 368e5c8..00433e4 onto 368e5c8 (3 commands) # # Commands: # p, pick \u0026lt;commit\u0026gt; = use commit # r, reword \u0026lt;commit\u0026gt; = use commit, but edit the commit message # e, edit \u0026lt;commit\u0026gt; = use commit, but stop for amending # s, squash \u0026lt;commit\u0026gt; = use commit, but meld into previous commit # f, fixup [-C | -c] \u0026lt;commit\u0026gt; = like \u0026#34;squash\u0026#34; but keep only the previous ...... 可见确实列出了前面3次的修改记录。\n将需要修改的 commit-id 前面对应 “pick” 改为 “edit”，即可在后续操作中对该分支进行修改。\n之后，x次修改就进行x次下面两条命令：\n1 2 git commit --amend --message=\u0026#34;modify\u0026#34; --author=\u0026#34;your_name \u0026lt;your_email\u0026gt;\u0026#34; git rebase --continue 经过x次以上命令，不出什么问题的话，将会有大致如下的提示出现：\n1 Successfully rebased and updated refs/heads/master. 现在，强制推送即可：\n1 git push --force 取消或删除提交 当你在某一次提交中不小心忘记了把一些敏感信息进行ignore，那么你很可能需要删除那一次提交。\n可以使用 git reset 删除提交，记录将被真正删除，是将 HEAD 指向某个 commit-id， 该操作需要谨慎使用。\n如果使用 git revert 则只是取消上一次修改，上一次的提交记录还在，并且多生成了一次提交记录。也就是说对于敏感信息的处理是无效的。同时，该操作如果想重做多次修改，需要按如下规则进行操作：\n1 2 git revert [倒数第一个提交] [倒数第二个提交] # 如 git revert HEAD HEAD~1 取消上一次提交 1 2 git revert HEAD git push origin master 删除上一次提交 删除上一次提交，也就是把 HEAD 指向 HEAD^， --hard 使得工作区里面的文件也回到以前的状态。\n1 git reset --hard HEAD^ 取消某次提交：\n1 git reset --hard commit_id 接着进行提交即可：\n1 git push origin master -f # origin为之前指定的远程分支 From my blog: akynazh.\nOver.\n","permalink":"/posts/2022/12/git-version-and-submission-management/","tags":["git"],"title":"Git 版本与提交管理"},{"categories":["Tool"],"contents":"BASE 1 2 3 4 5 6 7 8 9 apt update -y apt install curl wget vim net-tools git nginx -y # apt install openssh* -------------------------------------------- yum update -y yum install curl wget vim net-tools git nginx -y yum install openssh* yum镜像 1 2 3 4 5 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo # centos7 yum makecache yum -y update apt镜像 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 cp /etc/apt/sources.list /etc/apt/sources.list.bak vim /etc/apt/sources.list lsb_release -c 查看版本代码 如要用于其他版本，把 focal 换成其他版本代号即可: 22.04：jammy；20.04：focal；18.04：bionic；16.04：xenial；14.04：trusty。 # 默认注释了源码仓库，如有需要可自行取消注释 deb https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse # deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse # deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse # deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse # deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse # deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse python3 安装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 yum update yum install openssl-devel bzip2-devel libffi-devel -y yum groupinstall \u0026#34;Development Tools\u0026#34; -y wget https://www.python.org/ftp/python/3.10.2/Python-3.10.2.tgz tar -zxvf Python-3.10.2.tgz cd Python-3.10.2 ./configure --enable-optimizations make altinstall ln -sf /usr/local/bin/python3.10 /usr/bin/python3 ln -sf /usr/local/bin/python3.10 /bin/python3 ln -sf /usr/local/bin/pip3.10 /usr/bin/pip ------------------------------------------------------ apt update apt install software-properties-common -y add-apt-repository ppa:deadsnakes/ppa \u0026amp;\u0026amp; apt update apt install python3.10 -y ln -sf /usr/bin/python3.10 /usr/bin/python3 curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py \u0026amp;\u0026amp; python3 get-pip.py ln -sf /usr/local/bin/pip3.10 /usr/bin/pip Pip 镜像配置 1 2 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple pip config set install.trusted-host https://pypi.tuna.tsinghua.edu.cn 遇到的问题 No module named \u0026lsquo;distutils.cmd\u0026rsquo; 1 apt install python3-distutils -y setup python setup.py egg_info did not run successfully.\n1 pip install setuptools -U lzma ModuleNotFoundError: No module named \u0026lsquo;_lzma\u0026rsquo; 解決方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 yum install xz-devel yum install python-backports-lzma pip install backports.lzma 找到lzma.py，如日誌提示的/usr/local/lib/python3.7/lzma.py，修改zma.py文件中的導入部份如下： 修改前： from _lzma import * from _lzma import _encode_filter_properties, _decode_filter_properties 修改後： try: from _lzma import * from _lzma import _encode_filter_properties, _decode_filter_properties except ImportError: from backports.lzma import * from backports.lzma import _encode_filter_properties, _decode_filter_properties verysync 1 2 3 curl http://www.verysync.com/shell/verysync-linux-installer/go-installer.sh \u0026gt; go-installer.sh chmod +x go-installer.sh ./go-installer.sh java 安装 1 2 3 4 wget https://repo.huaweicloud.com/java/jdk/8u151-b12/jdk-8u151-linux-x64.tar.gz tar -zxvf jdk-8u151-linux-x64.tar.gz sudo mkdir /usr/local/java sudo mv jdk1.8.0_151 /usr/local/java/jdk1.8 环境变量 1 2 3 4 # java env export JAVA_HOME=/usr/local/java/jdk1.8 export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib export PATH=$PATH:$JAVA_HOME/bin maven 安装 1 2 3 4 wget https://dlcdn.apache.org/maven/maven-3/3.8.6/binaries/apache-maven-3.8.6-bin.tar.gz sudo mkdir /usr/local/maven tar -zxvf apach* sudo mv apache-maven-3.8.6 /usr/local/maven/3.8.6 环境变量 1 2 3 # maven env MAVEN_HOME=/usr/local/maven/3.8.6 export PATH=$PATH:$MAVEN_HOME/bin 镜像 sudo vim /usr/local/maven/3.8.6/conf/settings.xml\n1 2 3 4 5 6 \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; node npm 安装 1 2 3 4 5 6 curl --silent --location https://rpm.nodesource.com/setup_16.x | bash - yum -y install nodejs -------------------------------------------- apt install nodejs npm 镜像 设置成淘宝源\n1 npm config set registry https://registry.npm.taobao.org mysql 安装 1 2 3 4 wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm rpm -Uvh mysql80-community-release-el7-3.noarch.rpm rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022 yum install mysql-community-server -y 配置root密码 vim /etc/my.cnf\n1 + skip-grant-tables 1 2 3 mysql flush privileges; alter mysql.user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;xxxxxx\u0026#39;; vim /etc/my.cnf\n1 - skip-grant-tables redis 1 2 yum install epel-release yum install -y redis c/c++ 1 2 3 yum install gcc -y yum install gcc-c++ -y yum install gdb -y git 安装 1 2 3 4 5 yum install git -y ------------------------------------ apt install git -y 配置密钥 将公钥手动部署到github\n配置提交人信息 1 2 git config --global user.name \u0026#34;akynazh\u0026#34; git config --global user.email \u0026#34;1945561232@qq.com\u0026#34; http代理 1 git config --global http.https://github.com.proxy socks5://127.0.0.1:7891 ssh代理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # ~/.ssh/config Host github.com User git Port 22 Hostname github.com IdentityFile ~/.ssh/id_rsa ProxyCommand nc -v --proxy-type socks5 --proxy 127.0.0.1:7891 %h %p Host ssh.github.com User git Port 443 Hostname ssh.github.com IdentityFile ~/.ssh/id_rsa ProxyCommand nc -v --proxy-type socks5 --proxy 127.0.0.1:7891 %h %p unix系统使用nc（netcat）命令，若未安装netcat，需先安装：\n1 yum install nc Go 1 apt install golang-go From my blog: akynazh.\nOver.\n","permalink":"/posts/2022/11/linux-software-installation-and-configuration-records/","tags":["linux","software"],"title":"Linux 软件安装和配置记录"},{"categories":["Bug"],"contents":"持续更新中。\npipenv 无法正常 install 1 2 3 4 PS C:\\Users\\akyna\\Codes\\test\\test_py\u0026gt; pipenv install Usage: pipenv install [OPTIONS] [PACKAGES]... ERROR:: --system is intended to be used for pre-existing Pipfile installation, not installation of specific packages. Aborting. 解决方法：\n因为pipenv检测到之前在该目录下创建过了环境，需要先删除之前的环境才可以：\n1 2 PS C:\\Users\\akyna\\Codes\\test\\test_py\u0026gt; pipenv --rm Removing virtualenv (C:\\Users\\akyna\\.virtualenvs\\test_py-_qApXuy4)... requests 库 headers 字段编码错误 1 UnicodeEncodeError: \u0026#39;latin-1\u0026#39; codec can\u0026#39;t encode characters in position 30-34: ordinal not in range(256) 解决方法：\n加上.encode(\u0026lsquo;utf-8\u0026rsquo;)：\n1 2 3 4 5 6 7 8 return { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36\u0026#39;, \u0026#39;Host\u0026#39;: HOST, \u0026#39;Connection\u0026#39;: \u0026#39;close\u0026#39;, \u0026#39;X-Requested-With\u0026#39;: \u0026#39;XMLHttpRequest\u0026#39;, \u0026#39;Referer\u0026#39;: url.encode(\u0026#39;utf-8\u0026#39;), # fix bug } python + crontab 环境变量 crontab运行python时，如果python中使用了环境变量，将无法正常获取。\n解决方法：\n在crontab中配置好 python 中用到的环境变量：\n1 2 3 4 # backup 0 1 * * * env code=/root/Codes /bin/bash /root/Codes/scripts/unix/bbak # tg send 0 8 * * * env code=/root/Codes /bin/python3 ~/Codes/scripts/py/submit_tg_send.py 关于爬虫所设置的 Headers 中的 UserAgent 这是一个很难以发现的点，但不能说是bug吧。\nHeaders 中的 UserAgent 可以配置不同的设备端，如果设置了类似于 Android 这样的手机端，那从 requests.get() 返回得到的页面是手机端的界面！如果这个网站手机端的界面和电脑端的界面不是一样的，那么这个问题是很值得注意的。\nFrom my blog: akynazh.\nOver.\n","permalink":"/posts/2022/11/record-of-bugs-encountered-in-python-development/","tags":["python","bug"],"title":"Python 开发中遇到的 bug 记录"},{"categories":["Os"],"contents":"shell参数 $# 参数个数 $@ 取出所有参数 $0 取出第一个参数 1 2 3 4 5 if [ \u0026#34;$1\u0026#34; = \u0026#34;-u\u0026#34; ] then echo update fi echo $0 ans:\n1 2 3 4 5 [root =\u0026gt; ~]$ ./test.sh ./test.sh [root =\u0026gt; ~]$ ./test.sh -u update ./test.sh 算术运算 1 2 3 4 [root@VM-0-11-centos ~]# a=1 [root@VM-0-11-centos ~]# b=$((a*12)) [root@VM-0-11-centos ~]# echo $b 12 比较运算 指令：-eq -ne -lt -gt -ge -le\n注：字符串比较直接用“=”而不是上述指令。\n1 2 3 4 5 [root@VM-0-11-centos ~]# a=10 [root@VM-0-11-centos ~]# [ $a -eq 10 ] \u0026amp;\u0026amp; echo yes yes [root@VM-0-11-centos ~]# [ $a -ge 11 ] \u0026amp;\u0026amp; echo yes || echo no no 指令：-a -o\n1 2 3 4 5 [root@VM-0-11-centos ~]# a=10;b=12; [root@VM-0-11-centos ~]# [ $a -lt 11 -a $b -lt 13 ] \u0026amp;\u0026amp; echo yes || echo no yes [root@VM-0-11-centos ~]# [ $a -lt 11 -a $b -lt 11 ] \u0026amp;\u0026amp; echo yes || echo no no 字符串运算 -z（即zero）检测字符串长度是否为0，为0返回 true。 str检测字符串是否为空，不为空返回 true。 1 2 3 4 [root@VM-0-11-centos ~]# [ -z \u0026#34;jzh\u0026#34; ] \u0026amp;\u0026amp; echo yes || echo no no [root@VM-0-11-centos ~]# [ \u0026#34;jzh\u0026#34; = \u0026#34;zh\u0026#34; ] \u0026amp;\u0026amp; echo yes || echo no no 字符串的引号使用 双引号与单引号效果不一样，如下：\n1 2 3 4 root@ubuntu2004:~# echo \u0026#34;$PATH\u0026#34; /usr/local/java/jdk1.8.0_311/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:... root@ubuntu2004:~# echo \u0026#39;$PATH\u0026#39; $PATH 获取时间 1 2 3 4 5 6 # 输出格式化时间 [root@VM-0-11-centos ~]# date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39; 2022-04-10 13:22:04 # 输出当前时间戳 [root@VM-0-11-centos ~]# date +%s 1649568128 条件判断 注：中括号两端要有空白符。\n1 2 3 4 [root@VM-0-11-centos tmp]# [ \u0026#34;a\u0026#34; == \u0026#34;b\u0026#34; ] \u0026amp;\u0026amp; echo hello || echo bye bye [root@VM-0-11-centos tmp]# [ \u0026#34;a\u0026#34; == \u0026#34;a\u0026#34; ] \u0026amp;\u0026amp; echo hello || echo bye hello 文件运算 -r 即read -w 即write -x 即exec -s 即文件不为空 -e 即exist 1 2 3 4 5 [root@VM-0-11-centos ~]# touch t.sh [root@VM-0-11-centos ~]# [ -s ./t.sh ] \u0026amp;\u0026amp; echo yes || echo no no [root@VM-0-11-centos ~]# [ -e ./t.sh ] \u0026amp;\u0026amp; echo yes || echo no yes 读取输入 read -p \u0026ldquo;prompt words\u0026rdquo; var_name\n1 2 3 4 [root@VM-0-11-centos ~]# read -p \u0026#34;age:\u0026#34; age age:12 [root@VM-0-11-centos ~]# echo $age 12 read -a variable_name （读取数组）\n1 2 3 4 [root@VM-0-11-centos tmp]# read -a arr 1 2 3 4 5 [root@VM-0-11-centos tmp]# echo ${arr[4]} 5 条件判断语句 if else 1 2 3 4 5 6 7 8 9 if [ ] then do something elif [ ] then do something else do something fi case 1 2 3 4 5 6 7 8 9 10 11 case ${var} in \u0026#34;condition1\u0026#34;) do something ;; \u0026#34;condition2\u0026#34;) do something ;; *) #anything do something ;; esac 循环语句 while 1 2 3 4 while [ condition ] do do something done when meet the condition, start the loop.\nuntil 1 2 3 4 until [ condition ] do do something done when meet the condition, end the loop.\nfor 遍历数组：\n1 2 3 4 for $var in ${array} do do something done 遍历指定数字序列：\n1 2 3 4 for $var in {1..100} do do something done 条件遍历：\n1 2 3 4 for ( (i=1; i\u0026lt;=${var}; i++) ) do do something done sh命令 -n 不执行，只检查语法 not execute but check -v 执行前输出脚本内容 view the script -x 将使用到脚本内容输出 From my blog: akynazh.\nOver.\n","permalink":"/posts/2022/10/shell-basic-operation-summary/","tags":["linux"],"title":"Shell 基本操作总结"},{"categories":["Os"],"contents":"文件类型 d: directory -: file l: link p: pipeline，管道文件 b: block，块设备文件 c: character，字符设备文件 s: socket，套接字文件 配置文件 对于bashrc：\n/etc/bashrc：针对所有用户，每开启一个shell都会执行一次\n/etc/skel/.bashrc：针对所有用户，用于在新建一个用户时默认给用户配置的bashrc\n~/.bashrc：只针对单个用户，每开启一个shell执行一次\n对于profile：\n/etc/profile: 针对所有用户，首次登录执行一次\n/etc/skel/bash_profile: 针对所有用户，用于在新建一个用户时默认给用户配置的bashr_profile\n~/.bash_profile: 只针对单个用户，首次登录执行一次\n每次修改完配置文件后，都必须 source 一下已生效。\ncp命令 常用 cp -au：\n-a，即-dpR，-d 复制时保留链接，-p 保持权限不变，-R 递归复制，-u 表示在源文件有更新或者目标文件不存在时进行目标文件的复制。\nDos 与 Linux 换行符差异 首先知道：\n回车 CR \\r 换行 LF \\n win/dos的换行： \\r\\n\nunix mac linux的换行： \\n\nunix to win 换行失败。\nwin to unix 多了\\r -\u0026gt; \\r\\n -\u0026gt; ^M。\n解决方法，全部统一为LF即可。\n如果win下已经为CRLF，那么可以在linux下运行：\n安装dos2unix：yum install dos2unix，然后运行如下类似的命令：\n1 find . -name \u0026#39;*\u0026#39; |xargs dos2unix 可以将某目录下的所有文件从dos格式转为unix格式。\nFrom my blog: akynazh.\nOver.\n","permalink":"/posts/2022/10/linux-files-section-summary/","tags":["linux"],"title":"Linux 文件部分总结"},{"categories":["Tool"],"contents":"Git 初始化 1 2 git config --global user.name=\u0026#34;akynazh\u0026#34; git config --global user.email=\u0026#34;akynazh@qq.com\u0026#34; 配置 Http 代理 1 git config --global http.https://github.com.proxy socks5://127.0.0.1:7890 配置 SSH 代理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # ~/.ssh/config Host github.com User git Port 22 Hostname github.com IdentityFile ~/.ssh/id_rsa ProxyCommand connect -S 127.0.0.1:7890 -a none %h %p Host ssh.github.com User git Port 443 Hostname ssh.github.com IdentityFile ~/.ssh/id_rsa ProxyCommand connect -S 127.0.0.1:7890 -a none %h %p 其中connect命令是位于git安装目录下的一个操作命令，位置大致在：C:\\Program Files\\Git\\mingw64\\bin\\connect.exe，为了方便使用可以考虑将其加入环境变量。\nCRLF -\u0026gt; LF 1 git config --global core.autocrlf false From my blog: akynazh.\nOver.\n","permalink":"/posts/2022/10/git-configuration-record/","tags":["git"],"title":"Git 配置记录"},{"categories":["Tool"],"contents":"Docker 1 2 curl -fsSL https://get.docker.com | bash -s docker # curl -sSL https://get.daocloud.io/docker | sh Mirror 1 2 3 4 5 6 7 8 9 10 11 12 13 vim /etc/docker/daemon.json { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;, \u0026#34;http://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://registry.docker-cn.com\u0026#34; ] } ---------------------------------------------- systemctl restart docker Docker-compose 1 2 3 4 5 6 curl -L \u0026#34;https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose # curl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` \u0026gt; /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose # ln -s /usr/local/bin/docker-compose /usr/bin/dockerc 运行权限问题 1 2 sudo usermod -aG docker $USER sudo reboot MySQL 1 2 3 4 5 6 7 8 9 10 11 12 13 docker pull mysql:5.7 docker run -p 3306:3306 \\ --name mysqldb \\ # --network form-team-talent-network \\ -v /docker/mysql/conf:/etc/mysql/conf.d \\ -v /docker/mysql/logs:/logs \\ -v /docker/mysql/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=658766@Jzh \\ -d mysql:5.7 docker exec -it 7904c6d2c6f8 /bin/bash mysql -uroot -p From my blog: akynazh.\nOver.\n","permalink":"/posts/2022/10/docker-software-installation-record/","tags":["docker"],"title":"Docker 软件安装记录"},{"categories":["Language"],"contents":"8086 PC 机内存地址空间分配 00000~9FFFF: 主存储器地址空间（RAM） A0000~BFFFF: 显存地址空间 C0000~FFFFF: 各类ROM地址空间 段寄存器 8086CPU不支持将数据直接送入段寄存器的操作，ds 是一个段寄存器，所以mov ds，1000H这条指令是非法的。\n要将1000H送入ds，只好用一个寄存器来进行中转，即先将1000H送入一个一般的寄存器，如bx，再将bx中的内容送入ds。\n为什么8086CPU不支持将数据直接送入段寄存器的操作?\n这属于8086CPU硬件设计的问题。\n关于 SS，SP 8086CPU中，有两个寄存器，段寄存器 SS 和寄存器 SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。\n任意时刻，SS∶SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。\n伪指令 在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。\n汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。\n而伪指令没有对应的机器指令，最终不被 CPU 所执行。那么谁来执行伪指令呢?\n伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。\n汇编程序 在汇编源程序中，数据不能以字母开头，所以要在前面加0。比如，9138h在汇编源程序中可以直接写为“9138h”，而A000h在汇编源程序中要写为“0A000h”。\n对于mov al,[0]，是将常量0送入al中，等同于mov al,0； 对于mov al,ds:[0]，含义是(al)=((ds)*16+0)； 对于mov al,[bx]，含义是(al)=((ds)*16+(bx))； 对于mov al,ds:[bx]，含义等同于上者。 Debug R命令：查看、改变 CPU 寄存器的内容； D命令：查看内存中的内容； E命令：改写内存中的内容； U命令：将内存中的机器指令翻译成汇编指令； T命令：执行一条机器指令； A命令：以汇编指令的格式在内存中写入一条机器指令； P命令：可用于快速结束一段LOOP，遇到loop时使用； G命令：可以让指令直接执行到某个地址处，如-g 0016执行到0016处代码。 实模式和保护模式 实模式是Intel 80286和之后的x86兼容CPU的操作模式。\n实模式的特性是一个20位元的区段存储器地址空间（意思为只有1MB的存储器可以被寻址），软件可以直接访问BIOS例程以及周边硬件，没有任何硬件等级的存储器保护观念或多任务。\n保护模式是一种80286系列和之后的x86兼容CPU的运行模式。\n保护模式有一些新的特性，如存储器保护，标签页系统以及硬件支持的虚拟内存，能够增强多任务处理和系统稳定度。\n现今大部分的x86操作系统都在保护模式下运行，包含Linux、FreeBSD、以及微软Windows 2.0和之后版本。\n在纯 DOS 方式（实模式）下，可以不理会 DOS，直接用汇编语言去操作真实的硬件。\n因为运行在 CPU 实模式下的 DOS，没有能力对硬件系统进行全面、严格的管理。\n但在Windows 2000、Unix 这些运行于CPU保护模式下的操作系统中，不理会操作系统，用汇编语言去操作真实的硬件，是根本不可能的。硬件已被这些操作系统利用 CPU 保护模式所提供的功能全面而严格地管理了。\n问题 向内存0:200~0:23F依次传送0~63(3FH)：\n注意0:200~0:23F等同于0020:0~0020:3f，它们描述的是同一内存单元。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 assume cs:code code segment mov bx,20h mov ds,bx mov bx,0 mov cx,40h s:mov [bx],bx inc bx loop s mov ax,4c00h int 21h code ends end 将mov ax,4c00h之前的指令复制到内存0:200处：\nCX寄存器在debug调试一个可执行程序时，初始值为该程序的字节尺寸大小，要复制mov ax,4c00h之前的指令，需要减去mov ax,4c00h 和 int 21h 包含的5个字节。而由于程序指令的起始地址由CS:IP指定，所以将ds赋值为cs。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 assume cs:code code segment mov ax,cs ; 程序指令的起始地址由CS:IP指定 mov ds,ax mov ax,0020h mov es,ax mov bx,0 sub cx,5 ; 减去5个字节 mov ax,4c00h 和 int 21h s:mov al,[bx] mov es:[bx],al inc bx loop s mov ax,4c00h int 21h code ends end 参考：\n维基百科 王爽《汇编语言》 From My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/10/8086-assembly-learning-record/","tags":["assembly","cpu"],"title":"8086 汇编学习记录"},{"categories":["Tool"],"contents":"hwbk文件问题 假如你知道hwbk是什么，那么你肯定为它的存在而烦恼过。\n在华为系的机子上，任何第三方工具想要删除相册的一张图片，系统都会做出保护，你使用的第三方工具并没有真的删除那张图片，系统拦截了删除操作并再对文件添加后缀名.hwbk。\n更新：现在只要不卸载系统图库，系统会拦截第三方软件的删除操作，并将删除的照片送进图库的回收站，并不会生成hwbk文件。如果卸载了系统自带图库，则可以参考本文。\n其它类似的问题 还有一个例子就是默认桌面程序了，第三方软件nova launcher比系统自带的桌面程序好用得多，而实际上却完全无法使用，因为默认程序无法修改，系统直接锁死。\n同时，现在华为系的机子，只要是Android8以后的，似乎已经再也无法解开bootloader锁，官方不再给你申请的机会了，获取root，刷机已经成为一种幻想。\n如何看待这些问题 商家总会告诉你这是处于安全保护的考虑，可以防止你误删了东西。其实完全没有必要，第三方软件也有回收站功能，只要自己注意不要安装来路不明的软件，病毒也不会莫名其妙找上门。\n他不会给你一个选项，删除是否做出hwbk保护，而是直接强行做出保护，拒绝第三方的删除，这就等同于直接废了第三方软件的删除功能。这让许多人不得不使用系统自带软件，否则就是两头跑，这边删了，再到系统自带软件删一次。\n你可以说这是为了更好的安全性用户所必须做出的牺牲，但也可以说这只是商家为了利益而主动选择的一种控制用户的手段。\n从本质上看，无疑是一种很单纯的商业考量。他们让自己的系统封闭起来，强行让用户推动，发展自己的生态。\n如果华为自带的软件够好，我想慢慢地，用户也会主动选择自带的软件（就像apple一样）。他们不是从自身找问题，改善自己的产品，而是强迫用户去适应，剥夺自由选择的权力。\n如果是为了安全方面的问题，我想，一定也不只有这种一刀切的手段吧？对于安全方面的问题，我觉得应该让用户自己做决定，自己负责。就像有的人想获取root权限，他首先应该已经明白了获取root的后果是什么，愿意承担相应的风险。\n为用户体验着想，绝不是强迫用户干什么，而是让用户自己决定干什么。\n然而，他们凭什么为用户体验着想，能赚到钱不就完了？呵呵。\n当然，对于大多普通用户而言，或许从来都遇不到这些问题，但是当有一天你遇到这些问题并为之困扰时，你多少会感觉自由被剥夺了。毕竟，我们自己花钱买的东西，为什么不能让我们自己自由支配呢？\n通过adb干掉系统自带软件 电脑安装adb kits，adb所在目录加入环境变量（只是为了方便使用） 手机加入开发者模式 手机连接电脑，开启usb调试 命令行运行：adb devices 运行：adb shell 获取软件包名，写入applist.txt：pm list packages \u0026gt; applist.txt 通过包名卸载软件：pm uninstall --user 0 {pkg_name}（包名可自行google） 这是一个可选项，在你很反感系统自带软件时可以进行操作。\n下面，回到hwbk问题。\n让脚本帮我们自动消灭hwbk吧 假设你使用的是第三方的图库或者文件管理器，为了安全的考量，建议开启第三方软件的回收站。\n当存在大量hwbk文件时，一个个手动删除是不存在的，而且每天都可能产生新的hwbk，所以定时地进行扫描删除也是必要的。\n另外，通过尝试，将.hwbk后缀进行更改即可删除该文件。\n通过脚本可以方便地进行操作，这里我通过js完成工作。\n使用javascript进行删除操作 做法：每天固定一个时间（建议是在自己睡觉时）完成自动的清除。对所有目标文件夹进行扫描（递归性地），如果找到了.hwbk文件，将其后缀重命名为.hwbk.fuck_hwbk，再执行删除操作即可。\nkill_hwbk.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 function kill_hwbk_r(parent_dir) { let child_dirs = files.listDir(parent_dir, function(name) { return files.isDir(files.join(parent_dir, name)); }); let hwbk_files = files.listDir(parent_dir, function(name) { return name.endsWith(\u0026#39;.hwbk\u0026#39;) \u0026amp;\u0026amp; files.isFile(files.join(parent_dir, name)); }); child_dirs = child_dirs.map(String); hwbk_files = hwbk_files.map(String); for (let hwbk_file of hwbk_files) kill_hwbk(files.join(parent_dir, hwbk_file)); for (let child_dir of child_dirs) kill_hwbk_r(files.join(parent_dir, child_dir)); } function kill_hwbk(old_name) { new_name = old_name + \u0026#39;.fuck_hwbk\u0026#39;; files.move(old_name, new_name); console.log(\u0026#39;remove \u0026#39; + old_name + \u0026#39; -\u0026gt; \u0026#39; + files.remove(new_name)); kill_count++; } function main(dirs) { console.log(\u0026#39;[kill_hwbk.js] start\u0026#39;); for (let dir of dirs) kill_hwbk_r(dir); console.log(\u0026#39;[kill_hwbk.js] end, kill count: \u0026#39; + kill_count) kill_count = 0; } let kill_count = 0; // dirs: 需要清除hwbk的目录（递归性的） main(dirs=[ \u0026#39;/sdcard/Pictures\u0026#39;, \u0026#39;/sdcard/Video\u0026#39;, \u0026#39;/sdcard/DCIM\u0026#39;, // ...... ]) 手机安装hamibot或者autojs，即可运行该脚本，接着可以在软件中设置定时任务，定时运行该脚本。\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/10/solution-and-thinking-about-hwbk/","tags":["android"],"title":"关于 hwbk 文件问题的解决和思考"},{"categories":["OS"],"contents":"Linux下的定时任务 规则 */1 * * * * cmd\n5个单元：\n分钟（0-59） 小时（0-23 日期（1-31） 月份（1-12） 星期几（0-6，其中0代表星期日）\n例子 每分钟执行一次：* * * * * cmd\n或者：*/1 * * * * cmd\n每天早上6点10分执行一次：10 6 * * * cmd\n每两个小时执行一次：0 */2 * * * cmd\n在1月1日早上4点执行一次：0 4 1 1 * cmd\n注意事项 一、crontab不会使用在.bashrc之类的文件中定义的变量。\n解决方法：\n若为python脚本，可以通过`os.environ.get(\u0026rsquo;{env}\u0026rsquo;)在脚本中访问变量； 若为shell脚本，可以在脚本中执行source {your_env_file}; 类似于2，可以在crontab语句中执行source {your_env_file}。 二、crontab用户配置位于：/var/spool/cron/{用户名}\n可见，每个用户对应一个crontab配置，所以在crontab语句中使用~是可以的。\n三、crontab日志位于：/var/log/cron\nWindows下的定时任务 规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 SCHTASKS /parameter [arguments] Parameter List: /Create Creates a new scheduled task. /Delete Deletes the scheduled task(s). /Query Displays all scheduled tasks. /Change Changes the properties of scheduled task. /Run Runs the scheduled task on demand. /End Stops the currently running scheduled task. /ShowSid Shows the security identifier corresponding to a scheduled task name. /? Displays this help message. 查询某个操作的具体用法：\n1 2 3 4 5 6 7 8 9 schtasks /create /? SCHTASKS /Create [/S system [/U username [/P [password]]]] [/RU username [/RP password]] /SC schedule [/MO modifier] [/D day] [/M months] [/I idletime] /TN taskname /TR taskrun [/ST starttime] [/RI interval] [ {/ET endtime | /DU duration} [/K] [/XML xmlfile] [/V1]] [/SD startdate] [/ED enddate] [/IT | /NP] [/Z] [/F] [/HRESULT] [/?] ... 例子 一、每30分钟运行一次：\nschtasks /create /sc minute /mo 30 /tn \u0026quot;{task_name}\u0026quot; /tr \u0026quot;{task}\u0026quot;\n阅读可知：\n/sc，指定频率的单位：\n1 2 3 /SC schedule Specifies the schedule frequency. Valid schedule types: MINUTE, HOURLY, DAILY, WEEKLY, MONTHLY, ONCE, ONSTART, ONLOGON, ONIDLE, ONEVENT. /mo，在/sc的基础上，指定大小（可以的情况下使用，如MINUTE可以，而ONSTART不可以）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 Modifiers: Valid values for the /MO switch per schedule type: MINUTE: 1 - 1439 minutes. HOURLY: 1 - 23 hours. DAILY: 1 - 365 days. WEEKLY: weeks 1 - 52. ONCE: No modifiers. ONSTART: No modifiers. ONLOGON: No modifiers. ONIDLE: No modifiers. MONTHLY: 1 - 12, or FIRST, SECOND, THIRD, FOURTH, LAST, LASTDAY. ONEVENT: XPath event query string. /tn，即“task name”，注意是unique的，不能与其它任务重名。\n/tr，即“task run”，指定任务，即一个可执行的程序，如exe，bat。\n二、开机启动程序\n需要通过管理员模式运行以下命令：\nschtasks /create /tn \u0026quot;{task_name}\u0026quot; /sc onlogon /tr \u0026quot;{task}\u0026quot;\n三、每天22:00:00执行一次\nschtasks /create /tn \u0026quot;{task_name}\u0026quot; /sc daily /st 22:00:00 /tr \u0026quot;{task}\u0026quot;\n阅读可知：\n/st，用于指定执行的具体时刻：\n1 2 3 4 /ST starttime Specifies the start time to run the task. The time format is HH:mm (24 hour time) for example, 14:30 for 2:30 PM. Defaults to current time if /ST is not specified. This option is required with /SC ONCE. 四、删除定时任务\nschtasks /delete /tn \u0026quot;{task_name}\u0026quot;\n由于任务名是唯一的，所以通过/tn指定任务名即可删除任务。\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/10/summary-of-timed-tasks/","tags":["crontab","schtasks"],"title":"关于定时任务的总结"},{"categories":["OS"],"contents":"查看所有进程 ps -ef -e : all processes (-A) -f : full-format, including command lines 1 2 [root@VM-0-11-centos ~]# ps -ef | head -n 1 UID PID PPID C STIME TTY TIME CMD 解释如下：\nPPID 父进程ID C 占用CPU百分比 STIME 就是\u0026quot;start time\u0026quot; TTY 进程在哪个终端显示 CMD 命令的名称和参数 ps aux a: all with tty, including other users (和-a是不同的) u: user-oriented format x: processes without controlling ttys 1 2 [root@VM-0-11-centos ~]# ps -aux | head -n 1 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 解释如下：\n%MEM 占用内存百分比 VSZ 该进程使用的虚拟內存量（KB） RSS 该进程占用的固定內存量（KB）（驻留中页的数量） STAT 进程状态 STAT状态位常见的状态字符有:\n1 2 3 4 5 6 7 8 D //无法中断的休眠状态（通常 IO 的进程）； R //正在运行可中在队列中可过行的； S //处于休眠状态； T //停止或被追踪； Z //僵尸进程； s //进程的领导者（在它之下有子进程）； l //多线程，克隆线程（使用 CLONE_THREAD, 类似 NPTL pthreads）； + //位于后台的进程组； ps -l 仅查阅自己的bash相关程序\n\u0026hellip;\n查看相关进程 1 2 3 4 [root@VM-0-11-centos ~]# ps -ef | head -n 1; ps -ef | grep java UID PID PPID C STIME TTY TIME CMD root 25889 24972 4 17:46 pts/1 00:00:11 java -jar LonersHub-0.0.1-SNAPSHOT.jar root 26558 24972 0 17:51 pts/1 00:00:00 grep --color=auto java 终止或重启进程 关于kill命令 kill用于想某个进程发送信号。\n列出所有序号代表的信号含义：\n1 2 [root@VM-0-11-centos ~]# kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL ...... 最常用的信号是：\n1 (SIGHUP)：重新加载进程。\n9 (SIGKILL)：杀死一个进程。\n15 (SIGTERM)：正常停止一个进程。\n默认不带信号序号的kill就是SIGTERM，SIGTERM可以被阻塞、处理和忽略，因此有的进程可能无法按预期的结束。\n关于killall命令 无需PID，通过指定的名称进行对应进程的kill操作。\nkillall [-iIe] -signal 指令名称\n-i: interactive, 互动式kill\n停止进程 获取相关进程PID，再通过kill终止占用该端口的程序： 1 kill -9 PID 更快捷的方式：（根据某个名称进行操作，可能导致错误，因为多个进程可能含有相同名称，慎用。）\n1 kill -9 `ps -ef | grep ins | grep -v color | awk \u0026#39;{print $2}\u0026#39;` 通过相关名称kill e.g. 依次询问每个htppd相关程序是否需要被终止\n1 killall -i -9 httpd 背景工作切换 观察当前工作状态： jobs jobs -l可同时列出PID。\n将背景工作拿到前景来处理：fg %jobnumber\n让工作在背景的状态变成运行在：bg \u0026amp;jobnumber\ne.g.\n当按下ctrl-z将vim工作放到背景后，默认情况下，vim工作将处于\u0026quot;Stpped\u0026quot;状态，使用bg开始运行。\nplus: \u0026amp; 将工作放到背景“执行”。\n离线管理 1 nohub {cmd} \u0026amp; 不打印日志：\n1 nohup {cmd} \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; /dev/null类似于回收站，只是无法像window的回收站一样恢复。\n\u0026gt;/dev/null，就是把标准输出（1）写到/dev/null。\n对于2\u0026gt;\u0026amp;1：\n我们知道，1代表标准输出，而2代表标准错误输出，而0代表标准输入，这里就是将标准错误输出重定向到标准输出，这样也让标准错误输出写到了/dev/null。\n","permalink":"/posts/2022/10/process-management-of-linux-practical-operation/","tags":["linux"],"title":"Linux 实用操作之进程管理"},{"categories":["Book"],"contents":"作者：林奕含\n她们以前是思想上的双胞胎，精神的双胞胎，灵魂的双胞胎。以前伊纹姊姊说书，突然说好羡慕她们，她们马上异口同声说我们才羡慕姊姊和一维哥哥。伊纹姊姊说：恋爱啊，恋爱是不一样的，柏拉图说人求索他缺失的另一半，那就是说两个人合在一起才是完整，可是合起来就变成一个了，你们懂吗？像你们这样，无论缺少或多出什么都无所谓，因为有一个人与你镜像对称，「只有永远合不起来，才可以永远作伴」。\n思琪她们北上念书之后，伊纹的生活更苍白了。她开始陪一维出差。最喜欢陪一维飞日本，一维去工作，她就从他们在银座的公寓里走出来，闲晃大半天。日本真好，每个人脸上都写着待办事项四个字，每个人走路都急得像赶一场亲人的喜事，或是丧事。一个九十秒的路灯日本人只要十秒就可以走完，伊纹可以慢慢地走，走整整九十秒，想到自己的心事被投进人潮之中变得稀释，想到她总是可以走整整九十秒的斑马线，黑，白，黑，白地走。她浪费了多少时间啊。她还有那么多的人生等着被浪费！\n那一次，钱一维凌晨酒醒了，觉得握在被子里的手湿湿的，蹑手蹑脚不要吵醒伊纹，拍打脸颊，走进浴室，开灯看见脸上是血手印。此时的一维像希腊悲剧里的一幕，主人公不可思议地看着自己捧势却成空的双手，浴室灯光如舞台灯光如一束倒挂的郁金香包裹住他。他马上洗了脸，跑回房，开了灯，掀被子，发现睡在右手的伊纹下身全是血。一维突然想起昨天半夜回家，他用皮鞋尖勐踢伊纹。窄皮鞋头如一窝尖头毒蛇疯窜出去。伊纹抱紧双腿，他只能踢她的背。他想起伊纹一直说不要不要，不要不要。原来，伊纹说的是宝宝，宝宝。\n窗外有鸟啼春，伊纹的表情像从一个前所未有的好梦中醒过来，从此才明白好梦比噩梦更令人恐怖。她发出从前那对万物好奇的声音：宝宝呢？她白得像一片被误报了花讯的樱花林，人人提着丰盛的野餐篮，但樱花早已全部被雨水打烂在地上，一瓣一瓣的樱花在脚下，花瓣是爱心形状，爱心的双尖比任何时候看起来都像是被爽约的缺口，而不是本来的形状。宝宝呢？对不起，伊纹，我的亲亲，我们可以再生一个。伊纹看着他，就像他是由她所不懂的语言所写成。伊纹宝贝？你没事最重要，不是吗？一维看着伊纹全身颤抖，隆隆的马达，催到极限，眼看要发动的时候，又整个人熄灭了。\n伊纹听见思琪在啜泣，她在电话另一头，也可以看见思琪把手机拿远了小肩膀一耸一耸的样子。思琪说话了：「为什么这个世界是这个样子？为什么所谓教养就是受苦的人该闭嘴？为什么打人的人上电视上广告看板？姊姊，我好失望，但我不是对你失望，这个世界，或是生活，命运，或叫它神，或无论叫它什么，它好差劲，我现在读小说，如果读到赏善罚恶的好结局，我就会哭，我宁愿大家承认人间有一些痛苦是不能和解的，我最讨厌人说经过痛苦才成为更好的人，我好希望大家承认有些痛苦是毁灭的，我讨厌大团圆的抒情传统，讨厌王子跟公主在一起，正面思考是多么媚俗！可是姊姊，你知道我更恨什么吗？我宁愿我是一个媚俗的人，我宁愿无知，也不想要看过世界的背面。」思琪哭得字跟字都连在一起，伊纹也可以看见她涕泪满脸，五官都连在一起。\n原来，人对他者的痛苦是毫无想像力的，一个恶俗的语境──有钱有势的男人，年轻貌美的小三，泪涟涟的老婆──把一切看成一个庸钝语境，一齣八点档，因为人不愿意承认世界上确实存在非人的痛苦，人在隐约明白的当下就会加以否认，否则人小小的和平就显得坏心了。在这个人人争著称自己为输家的年代，没有人要承认世界上有一群女孩才是真正的输家。那种小调的痛苦其实与幸福是一体两面：人人坐享小小的幸福，嘴里嚷着小小的痛苦──当赤裸裸的痛苦端到他面前，他的安乐遂显得丑陋，痛苦显得轻浮。\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/09/fang-siqis-first-love-paradise-abstract/","tags":[],"title":"《房思琪的初恋乐园》文摘"},{"categories":["Language"],"contents":"作者：村上春树\n第9章 青豆 风景变了，规则变了 1Q84年——我就这么来称呼这个新世界吧。青豆决定。\nQ是question mark的Q。背负着疑问的东两。\n她边走边独自点头。\n不管喜欢还是不喜欢，目前我已经置身于这“1Q84年”。我熟悉的那个1984年已经无影无踪，今年是1Q84年。空气变了，风景变了。我必须尽快适应这个带着问号的世界。像被放进陌生森林中的动物一样，为了生存下去，得尽快了解并顺应这里的规则。\n第16章 天吾 能让你喜欢，我很高兴 《十二平均律钢琴曲集》对学数学的人来说，简直是天国的音乐。均衡地使用全部的十二音阶，以大调和小调分别创作前奏曲和赋格曲。总共二十四支乐曲。第一部和第二部合计四十八支曲子。形成一个完美的圆。\n第16章 天吾 能让你喜欢，我很高兴 回到家里，睡觉，做了个梦。许久没有的印象鲜明的梦境。梦中，自己变成了巨大拼图中的一个小块。不是固定在一处的小块，而是一个时时刻刻都在变幻形状的小块，因此任何位置都不能容纳他。这也是当然。另外，在寻找自身位置的同时，他还必须在规定时间内把定音鼓的分谱捡拾起来。这些乐谱被狂风吹散，七零八落，他必须一页页地拾起，确认页码，按照顺序整理成册。做这些事时，他自己还像阿米巴原虫一样不断地变幻形状。事态变得无法收拾。\n后来深绘里不知从哪儿赶来，握住他的左手。于是天吾停止了变形，风也骤然停下，乐谱不再飘散。这下好啦。天吾心想。但同时，规定时间也将结束。“到此结束。”深绘里小声宣告。依旧只有一个句子。时间戛然而止，世界在此终结。地球缓缓地停止转动，所有的声音和光芒都消失殆尽。\n翌日睁开眼时，世界安然无恙，还在继续。并且事物已经向前运转起来。就像印度神话中把前方所有生物统统碾杀的转轮一般。\n第22章 天吾 时间能以扭曲的形态前进 时间能以扭曲的形态前进，这一点天吾知道。时间自身固然是成分均一的东西，然而它一旦被消耗，就会变得形态扭曲。有的时间非常重而长，有的时间则轻而短。前后秩序有时还会颠来倒去，严重时甚至消失得无影无踪。而本来不应存在的东西又会被添加进来。人类大概就是这样随意地对时间进行调整，从而调整自己的存在意义。换个说法，就是通过这样的操作，人类才能保持神经正常。假如对自己经历过的时间，一定得严守顺序、依照原样均等地接受，只怕人类的神经注定忍受不了。那样的人生恐怕等于拷问。天吾浮想联翩。\n天吾一如往日，每周三天去补习学校讲课，其余的日子便继续伏案写作长篇小说，星期五和前来幽会的女朋友进行浓郁的午后做爱。但不论他做什么，都无法做到集中注意力。仿佛一个错把厚重云团的碎片吞进肚子里的人，郁塞滞重、心绪不宁地度日，食欲也慢慢减退。在半夜莫名其妙的时刻醒来，便再也无法入睡。在这样的不眠之夜思念着深绘里。她此刻在哪里？在做什么？和谁在一起？遭遇了什么？他在脑海中想象着种种状况，每一种尽管多少有差异，却都是带着悲观色彩的想象。而且在他的想象中，她总是身穿紧身夏季薄毛衣，胸脯呈现出美丽的形状。这个形象让天吾透不过气来，在他心中制造出更为剧烈的躁动。\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/09/1q84book1-excerpt/","tags":["excerpt"],"title":"《1Q84 Book1》文摘"},{"categories":["Language"],"contents":"定义 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。\n比如对于鸭子而言，不同鸭子的叫声方式可能不一样也可能一样，我们可以定义一个叫声行为接口，然后通过创建不同的叫声行为实现这个接口，在实例化鸭子时设定叫声行为即可。\n这样相比于直接继承抽象鸭子后重写叫声行为方法，好处是减少了重复代码，而坏处是增加了类的数量。\n代码展示 下面就以鸭子为例进行说明。\n从接口开始 定义一个叫声接口：（其它接口省略）\n1 2 3 public interface QuackBehavior { public void quack(); } 实现叫声接口 1 2 3 4 5 public class MuteQuack implements QuackBehavior { public void quack() { System.out.println(\u0026#34;\u0026lt;\u0026lt; Silence \u0026gt;\u0026gt;\u0026#34;); } } 其它接口省略。\n创建抽象鸭子 每只鸭子都有Fly和Quack这两种行为。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public abstract class Duck { FlyBehavior flyBehavior; QuackBehavior quackBehavior; public Duck() { } public void setFlyBehavior(FlyBehavior fb) { flyBehavior = fb; } public void setQuackBehavior(QuackBehavior qb) { quackBehavior = qb; } abstract void display(); public void performFly() { flyBehavior.fly(); } public void performQuack() { quackBehavior.quack(); } public void swim() { System.out.println(\u0026#34;All ducks float, even decoys!\u0026#34;); } } 创建具体鸭子 继承于抽象鸭子，实例化时指定行为。\n1 2 3 4 5 6 7 8 9 10 11 public class MallardDuck extends Duck { public MallardDuck() { quackBehavior = new Quack(); flyBehavior = new FlyWithWings(); } public void display() { System.out.println(\u0026#34;I\u0026#39;m a real Mallard duck\u0026#34;); } } 测试 1 2 3 4 5 6 7 8 Duck mallard = new MallardDuck(); mallard.performQuack(); mallard.performFly(); Duck model = new ModelDuck(); model.performFly(); model.setFlyBehavior(new FlyRocketPowered()); model.performFly(); 参考：《HeadFist设计模式》\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/policy-mode/","tags":["design","java"],"title":"策略模式"},{"categories":["Language"],"contents":"定义 代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。\n我们对一个对象的使用或者一个对象中方法的调用，可以通过这个对象的代理人进行访问，这个代理人可以方便地控制这个对象，让对象的功能更为强大或更易于使用。\n常见的代理有：远程代理，虚拟代理，动态代理。\n远程代理 对于远程代理，其实就是本地调用远程的方法，本地堆（客户端）有一个Stub代理对象，这个对象负责完成RMI操作，也就是远程方法调用，而远程堆（服务端）有一个Skeleton代理对象，它接收客户端的RMI操作，并传递给真正的服务对象进行服务，之后再返回给客户端结果。\n使用过程中需要注意调用的对象必须是可序列化的，无需序列化的对象可以添加transient关键字。通过rmiregistry \u0026amp;开启RMI，之后进行服务注册。服务端通过Naming.rebind()绑定服务地址，客户端通过Naming.lookup()调用远程方法。另外，远程传输对象需要继承于UnicastRemoteObject。\n在Java5中，RMI和动态代理搭配使用，动态代理动态产生Stub，远程对象的Stub是Proxy实例，它是自动产生的，来处理所有把客户的本地调用变成远程调用的细节。\n虚拟代理 对于虚拟代理，也就是说这个代理对象是虚拟的，由代理来扮演对象的替身。\n比如对于从网络加载一副图像展现给用户，我们可能需要等待一定时间，这段时间内图像应该展现为用户友好的“等待中”字样，而在网络图像获取成功后进行网络图像的展现。\n这个过程可以通过代理的方式方便地完成：虚拟代理对象扮演图像的替身，它通过创建一个线程加载网络图像，加载期间将图像动态地变为用户友好字样，完成加载后改为网络图像。\n可以发现我们不是直接使用图像本身，而使用了代理对象作为图像，也就是说，代理扮演了图像这个角色。\n下面是一个图像代理对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class ImageProxy implements Icon { volatile ImageIcon imageIcon; final URL imageURL; Thread retrievalThread; boolean retrieving = false; public ImageProxy(URL url) { imageURL = url; } public int getIconWidth() { ... } public int getIconHeight() { ... } synchronized void setImageIcon(ImageIcon imageIcon) { this.imageIcon = imageIcon; } public void paintIcon(final Component c, Graphics g, int x, int y) { if (imageIcon != null) { imageIcon.paintIcon(c, g, x, y); } else { g.drawString(\u0026#34;Loading album cover, please wait...\u0026#34;, x+300, y+190); if (!retrieving) { retrieving = true; retrievalThread = new Thread(() -\u0026gt; { try { setImageIcon(new ImageIcon(imageURL, \u0026#34;Album Cover\u0026#34;)); c.repaint(); } catch (Exception e) { e.printStackTrace(); } }); retrievalThread.start(); } } } } 动态代理 对于动态代理，代理对象在运行时才被创建，可以通过人为设定值来修改原本的对象，这样也就让一个代理对象可以获得不同的功能或属性，也就是说，代理对象增强了一个对象的功能。\n下面以一个简单例子说明动态代理的使用过程：\n创建类 1 2 3 4 5 6 public interface Person { String getName(); // ... void setName(String name); // ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class PersonImpl implements Person /*, {其它接口} */ { String name; String gender; String interests; int rating; int ratingCount = 0; public String getName() { return name;\t} // ... public void setName(String name) { this.name = name; } // ... } 创建InvocationHandler 实现invoke方法，设置该对象不允许setGeekRating。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class OwnerInvocationHandler implements InvocationHandler { Person person; public OwnerInvocationHandler(Person person) { this.person = person; } public Object invoke(Object proxy, Method method, Object[] args) throws IllegalAccessException { try { if (method.getName().startsWith(\u0026#34;get\u0026#34;)) { return method.invoke(person, args); } else if (method.getName().equals(\u0026#34;setGeekRating\u0026#34;)) { throw new IllegalAccessException(); // 不允许setGeekRating } else if (method.getName().startsWith(\u0026#34;set\u0026#34;)) { return method.invoke(person, args); } } catch (InvocationTargetException e) { e.printStackTrace(); } return null; } } 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 初始化一些对象 initializeDatabase(); // 获取对象 Person joe = getPersonFromDatabase(\u0026#34;Joe Javabean\u0026#34;); // 获取代理对象 Person ownerProxy = (Person) Proxy.newProxyInstance( joe.getClass().getClassLoader(), joe.getClass().getInterfaces(), new OwnerInvocationHandler(joe)); // 进行测试 System.out.println(\u0026#34;Name is \u0026#34; + ownerProxy.getName()); ownerProxy.setInterests(\u0026#34;bowling, Go\u0026#34;); try { ownerProxy.setGeekRating(10); // 将会抛出异常 } catch (Exception e) { System.out.println(\u0026#34;Can\u0026#39;t set rating from owner proxy\u0026#34;); } System.out.println(\u0026#34;Rating is \u0026#34; + ownerProxy.getGeekRating()); 参考：《HeadFist设计模式》\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/proxy-pattern/","tags":["design","java"],"title":"代理模式"},{"categories":["Language"],"contents":"定义 状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。\n比如某个机器有各种复杂的状态，每个状态都着共同的参数，而这些参数值有区别。用户通过某些操作会改变机器的状态，机器转变状态后，以当前状态的方法给用户反馈。\n代码展示 以机器的例子说明。\n从接口开始 编写状态接口：\n1 2 3 4 5 6 7 8 9 public interface State { public void insertQuarter(); public void ejectQuarter(); public void turnCrank(); public void dispense(); public void refill(); } 创建机器类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 package headfirst.designpatterns.state.gumballstate; public class GumballMachine { // 各种机器状态 State soldOutState; State noQuarterState; State hasQuarterState; State soldState; // 当前状态 State state; int count = 0; public GumballMachine(int numberGumballs) { soldOutState = new SoldOutState(this); noQuarterState = new NoQuarterState(this); hasQuarterState = new HasQuarterState(this); soldState = new SoldState(this); this.count = numberGumballs; if (numberGumballs \u0026gt; 0) { state = noQuarterState; } else { state = soldOutState; } } public void insertQuarter() { state.insertQuarter(); } public void ejectQuarter() { state.ejectQuarter(); } public void turnCrank() { state.turnCrank(); state.dispense(); } void releaseBall() { System.out.println(\u0026#34;A gumball comes rolling out the slot...\u0026#34;); if (count \u0026gt; 0) { count = count - 1; } } int getCount() { return count; } void refill(int count) { this.count += count; System.out.println(\u0026#34;The gumball machine was just refilled; its new count is: \u0026#34; + this.count); state.refill(); } void setState(State state) { this.state = state; } public State getState() { return state; } public State getSoldOutState() { return soldOutState; } public State getNoQuarterState() { return noQuarterState; } public State getHasQuarterState() { return hasQuarterState; } public State getSoldState() { return soldState; } public String toString() { // 省略了 } } 定义各种机器状态 以其中一个状态为例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class HasQuarterState implements State { GumballMachine gumballMachine; public HasQuarterState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } public void insertQuarter() { System.out.println(\u0026#34;You can\u0026#39;t insert another quarter\u0026#34;); } public void ejectQuarter() { System.out.println(\u0026#34;Quarter returned\u0026#34;); gumballMachine.setState(gumballMachine.getNoQuarterState()); } public void turnCrank() { System.out.println(\u0026#34;You turned...\u0026#34;); gumballMachine.setState(gumballMachine.getSoldState()); } public void dispense() { System.out.println(\u0026#34;No gumball dispensed\u0026#34;); } public void refill() { } public String toString() { return \u0026#34;waiting for turn of crank\u0026#34;; } } 每个状态中都有机器操作的一些方法，这些方法可能改变机器的状态。\n测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 GumballMachine gumballMachine = new GumballMachine(2); System.out.println(gumballMachine); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); System.out.println(gumballMachine); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.refill(5); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); System.out.println(gumballMachine); 参考：《HeadFist设计模式》\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/status-mode/","tags":["design","java"],"title":"状态模式"},{"categories":["Language"],"contents":"定义 组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。\n对于菜单内容而言，假如只有简单的菜品项，那么通过迭代器可以轻松地遍历，但是如果菜单内容中含有子菜单，那么就需要组合模式了。\n代码展示 下面就以菜单为例子展示组合模式。\n从抽象开始 创建菜单组件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public abstract class MenuComponent { public void add(MenuComponent menuComponent) { throw new UnsupportedOperationException(); } public void remove(MenuComponent menuComponent) { throw new UnsupportedOperationException(); } public MenuComponent getChild(int i) { throw new UnsupportedOperationException(); } public String getName() { throw new UnsupportedOperationException(); } public String getDescription() { throw new UnsupportedOperationException(); } public double getPrice() { throw new UnsupportedOperationException(); } public boolean isVegetarian() { throw new UnsupportedOperationException(); } public void print() { throw new UnsupportedOperationException(); } } 创建菜单 菜单本身是一个菜单组件，菜单继承于菜单组件，实现父类方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class Menu extends MenuComponent { ArrayList\u0026lt;MenuComponent\u0026gt; menuComponents = new ArrayList\u0026lt;MenuComponent\u0026gt;(); String name; String description; public Menu(String name, String description) { this.name = name; this.description = description; } public void add(MenuComponent menuComponent) { menuComponents.add(menuComponent); } public void remove(MenuComponent menuComponent) { menuComponents.remove(menuComponent); } public MenuComponent getChild(int i) { return (MenuComponent)menuComponents.get(i); } public String getName() { return name; } public String getDescription() { return description; } public void print() { System.out.print(\u0026#34;\\n\u0026#34; + getName()); System.out.println(\u0026#34;, \u0026#34; + getDescription()); System.out.println(\u0026#34;---------------------\u0026#34;); //\tIterator\u0026lt;MenuComponent\u0026gt; iterator = menuComponents.iterator(); //\twhile (iterator.hasNext()) { //\tMenuComponent menuComponent = //\t(MenuComponent)iterator.next(); //\tmenuComponent.print(); //\t} for (MenuComponent menuComponent : menuComponents) { menuComponent.print(); } } } 创建菜单项 菜单项当然也是一个菜单组件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package headfirst.designpatterns.composite.menu; public class MenuItem extends MenuComponent { String name; String description; boolean vegetarian; double price; public MenuItem(String name, String description, boolean vegetarian, double price) { this.name = name; this.description = description; this.vegetarian = vegetarian; this.price = price; } public String getName() { return name; } public String getDescription() { return description; } public double getPrice() { return price; } public boolean isVegetarian() { return vegetarian; } public void print() { System.out.print(\u0026#34; \u0026#34; + getName()); if (isVegetarian()) { System.out.print(\u0026#34;(v)\u0026#34;); } System.out.println(\u0026#34;, \u0026#34; + getPrice()); System.out.println(\u0026#34; -- \u0026#34; + getDescription()); } } 创建服务员 1 2 3 4 5 6 7 8 9 10 11 public class Waitress { MenuComponent allMenus; public Waitress(MenuComponent allMenus) { this.allMenus = allMenus; } public void printMenu() { allMenus.print(); } } 测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package headfirst.designpatterns.composite.menu; public class MenuTestDrive { public static void main(String args[]) { MenuComponent pancakeHouseMenu = new Menu(\u0026#34;PANCAKE HOUSE MENU\u0026#34;, \u0026#34;Breakfast\u0026#34;); MenuComponent dinerMenu = new Menu(\u0026#34;DINER MENU\u0026#34;, \u0026#34;Lunch\u0026#34;); MenuComponent cafeMenu = new Menu(\u0026#34;CAFE MENU\u0026#34;, \u0026#34;Dinner\u0026#34;); MenuComponent dessertMenu = new Menu(\u0026#34;DESSERT MENU\u0026#34;, \u0026#34;Dessert of course!\u0026#34;); MenuComponent coffeeMenu = new Menu(\u0026#34;COFFEE MENU\u0026#34;, \u0026#34;Stuff to go with your afternoon coffee\u0026#34;); MenuComponent allMenus = new Menu(\u0026#34;ALL MENUS\u0026#34;, \u0026#34;All menus combined\u0026#34;); allMenus.add(pancakeHouseMenu); allMenus.add(dinerMenu); allMenus.add(cafeMenu); pancakeHouseMenu.add(new MenuItem( \u0026#34;K\u0026amp;B\u0026#39;s Pancake Breakfast\u0026#34;, \u0026#34;Pancakes with scrambled eggs and toast\u0026#34;, true, 2.99)); // 省略其它菜品项... dinerMenu.add(new MenuItem( \u0026#34;Vegetarian BLT\u0026#34;, \u0026#34;(Fakin\u0026#39;) Bacon with lettuce \u0026amp; tomato on whole wheat\u0026#34;, true, 2.99)); ... dinerMenu.add(dessertMenu); dessertMenu.add(new MenuItem( \u0026#34;Apple Pie\u0026#34;, \u0026#34;Apple pie with a flakey crust, topped with vanilla icecream\u0026#34;, true, 1.59)); // 省略其它菜品项... cafeMenu.add(new MenuItem( \u0026#34;Veggie Burger and Air Fries\u0026#34;, \u0026#34;Veggie burger on a whole wheat bun, lettuce, tomato, and fries\u0026#34;, true, 3.99)); // 省略其它菜品项... cafeMenu.add(coffeeMenu); coffeeMenu.add(new MenuItem( \u0026#34;Coffee Cake\u0026#34;, \u0026#34;Crumbly cake topped with cinnamon and walnuts\u0026#34;, true, 1.59)); // 省略其它菜品项... Waitress waitress = new Waitress(allMenus); waitress.printMenu(); } } 参考：《HeadFist设计模式》\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/combination-mode/","tags":["design","java"],"title":"组合模式"},{"categories":["Language"],"contents":"定义 迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。\n通过一个Iterator，可以方便地遍历各种类型，如HashMap，ArrayList等。\n代码展示 下面通过菜单的例子进行说明。\n分别用简单数组String[]和ArrayList\u0026lt;String\u0026gt;类创建菜单内容。\n从接口开始 创建菜单接口：\n1 2 3 public interface Menu { public Iterator\u0026lt;String\u0026gt; createIterator(); } 每个菜单都可以返回一个迭代器。\n创建Diner菜单 该菜单用String[]创建内容，需要编写自己的迭代器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class DinerMenu implements Menu { static final int MAX_ITEMS = 6; int numberOfItems = 0; String[] menuItems; public DinerMenu() { menuItems = new String[MAX_ITEMS]; addItem(\u0026#34;Vegetarian BLT\u0026#34;); addItem(\u0026#34;BLT\u0026#34;); addItem(\u0026#34;Soup of the day\u0026#34;); addItem(\u0026#34;Hotdog\u0026#34;); addItem(\u0026#34;Steamed Veggies and Brown Rice\u0026#34;); addItem(\u0026#34;Pasta\u0026#34;); } public void addItem(String name) { if (numberOfItems \u0026gt;= MAX_ITEMS) { System.err.println(\u0026#34;Sorry, menu is full! Can\u0026#39;t add item to menu\u0026#34;); } else { menuItems[numberOfItems] = name; numberOfItems = numberOfItems + 1; } } public String[] getMenuItems() { return menuItems; } public Iterator\u0026lt;String\u0026gt; createIterator() { return new DinerMenuIterator(menuItems); } public String toString() { return \u0026#34;Diner Menu\u0026#34;; } // other menu methods here } 创建菜单迭代器 实现Iterater\u0026lt;String\u0026gt;接口，实现next()，hasNext()和remove()方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class DinerMenuIterator implements Iterator\u0026lt;String\u0026gt; { String[] list; int position = 0; public DinerMenuIterator(String[] list) { this.list = list; } public String next() { String menuItem = list[position]; position = position + 1; return menuItem; } public boolean hasNext() { if (position \u0026gt;= list.length || list[position] == null) { return false; } else { return true; } } public void remove() { if (position \u0026lt;= 0) { throw new IllegalStateException (\u0026#34;You can\u0026#39;t remove an item until you\u0026#39;ve done at least one next()\u0026#34;); } if (list[position-1] != null) { for (int i = position-1; i \u0026lt; (list.length-1); i++) { list[i] = list[i+1]; } list[list.length-1] = null; } } } 创建PancakeHouse菜单 该菜单使用ArrayList\u0026lt;String\u0026gt;创建内容，可以直接使用Java内置迭代器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class PancakeHouseMenu implements Menu { ArrayList\u0026lt;String\u0026gt; menuItems; public PancakeHouseMenu() { menuItems = new ArrayList\u0026lt;String\u0026gt;(); addItem(\u0026#34;K\u0026amp;B\u0026#39;s Pancake Breakfast\u0026#34;); addItem(\u0026#34;Regular Pancake Breakfast\u0026#34;); addItem(\u0026#34;Blueberry Pancakes\u0026#34;); addItem(\u0026#34;Waffles\u0026#34;); } public void addItem(String name) { menuItems.add(name); } public ArrayList\u0026lt;String\u0026gt; getMenuItems() { return menuItems; } public Iterator\u0026lt;String\u0026gt; createIterator() { return menuItems.iterator(); } public String toString() { return \u0026#34;Pancake House Menu\u0026#34;; } // other menu methods here } 测试 printMenu方法通过一个迭代器遍历并打印菜单。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Cafe { public static void main(String args[]) { PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu(); DinerMenu dinerMenu = new DinerMenu(); // with iterators Iterator\u0026lt;String\u0026gt; pancakeIterator = pancakeHouseMenu.createIterator(); Iterator\u0026lt;String\u0026gt; dinerIterator = dinerMenu.createIterator(); System.out.println(\u0026#34;\\nMENU (with iterators)\\n----\\nBREAKFAST\u0026#34;); printMenu(pancakeIterator); System.out.println(\u0026#34;\\nLUNCH\u0026#34;); printMenu(dinerIterator); } private static void printMenu(Iterator\u0026lt;String\u0026gt; iterator) { while (iterator.hasNext()) { String menuItem = (String)iterator.next(); System.out.println(menuItem); } } } 参考：《HeadFist设计模式》\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/iterators-mode/","tags":["design","java"],"title":"迭代器模式"},{"categories":["Language"],"contents":"定义 模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。\n“好莱坞”原则 别调用我们，我们会调用你。\n其实就是防止“依赖腐败”，也就是要避免高层组件和低层组件相互依赖。一般由高层组件依赖低层组件。\n代码展示 泡茶和泡咖啡有着几乎相同的步骤，但在某些子步骤中有差别。通过模板方法可以很好地解决问题。\n定义模板方法 子步骤brew()和addCondiments()为抽象方法，由子类具体实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public abstract class CaffeineBeverage { final void prepareRecipe() { boilWater(); brew(); pourInCup(); addCondiments(); } abstract void brew(); abstract void addCondiments(); void boilWater() { System.out.println(\u0026#34;Boiling water\u0026#34;); } void pourInCup() { System.out.println(\u0026#34;Pouring into cup\u0026#34;); } } 定义具体方法 继承CaffeineBeverage并实现抽象方法。\n1 2 3 4 5 6 7 8 public class Coffee extends CaffeineBeverage { public void brew() { System.out.println(\u0026#34;Dripping Coffee through filter\u0026#34;); } public void addCondiments() { System.out.println(\u0026#34;Adding Sugar and Milk\u0026#34;); } } 1 2 3 4 5 6 7 8 public class Tea extends CaffeineBeverage { public void brew() { System.out.println(\u0026#34;Steeping the tea\u0026#34;); } public void addCondiments() { System.out.println(\u0026#34;Adding Lemon\u0026#34;); } } 测试 1 2 3 4 5 6 7 8 Tea tea = new Tea(); Coffee coffee = new Coffee(); System.out.println(\u0026#34;\\nMaking tea...\u0026#34;); tea.prepareRecipe(); System.out.println(\u0026#34;\\nMaking coffee...\u0026#34;); coffee.prepareRecipe(); 参考：《HeadFist设计模式》\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/template-method-mode/","tags":["design","java"],"title":"模板方法模式"},{"categories":["Language"],"contents":"外观模式 定义 外观模式提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。\n“最少知识”原则 减少对象之间的交互，只和“密友”谈话，也就是减少一个类所交互的类的数量。\n代码展示 执行一些复杂操作需要一步步执行许多小操作，那么可以将复杂操作封装为一个高层类中的方法，将所有复杂操作需要用到的类作为高层类的成员，在复杂操作的方法中可以方便的调用各个类执行各自的功能。\n下面是一个家庭影院的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 public class HomeTheaterFacade { Amplifier amp; Tuner tuner; StreamingPlayer player; CdPlayer cd; Projector projector; TheaterLights lights; Screen screen; PopcornPopper popper; public HomeTheaterFacade(Amplifier amp, Tuner tuner, StreamingPlayer player, Projector projector, Screen screen, TheaterLights lights, PopcornPopper popper) { this.amp = amp; this.tuner = tuner; this.player = player; this.projector = projector; this.screen = screen; this.lights = lights; this.popper = popper; } public void watchMovie(String movie) { System.out.println(\u0026#34;Get ready to watch a movie...\u0026#34;); popper.on(); popper.pop(); lights.dim(10); screen.down(); projector.on(); projector.wideScreenMode(); amp.on(); amp.setStreamingPlayer(player); amp.setSurroundSound(); amp.setVolume(5); player.on(); player.play(movie); } public void endMovie() { System.out.println(\u0026#34;Shutting movie theater down...\u0026#34;); popper.off(); lights.on(); screen.up(); projector.off(); amp.off(); player.stop(); player.off(); } public void listenToRadio(double frequency) { System.out.println(\u0026#34;Tuning in the airwaves...\u0026#34;); tuner.on(); tuner.setFrequency(frequency); amp.on(); amp.setVolume(5); amp.setTuner(tuner); } public void endRadio() { System.out.println(\u0026#34;Shutting down the tuner...\u0026#34;); tuner.off(); amp.off(); } } 各个功能器件的代码省略了。\n进行测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Amplifier amp = new Amplifier(\u0026#34;Amplifier\u0026#34;); Tuner tuner = new Tuner(\u0026#34;AM/FM Tuner\u0026#34;, amp); StreamingPlayer player = new StreamingPlayer(\u0026#34;Streaming Player\u0026#34;, amp); CdPlayer cd = new CdPlayer(\u0026#34;CD Player\u0026#34;, amp); Projector projector = new Projector(\u0026#34;Projector\u0026#34;, player); TheaterLights lights = new TheaterLights(\u0026#34;Theater Ceiling Lights\u0026#34;); Screen screen = new Screen(\u0026#34;Theater Screen\u0026#34;); PopcornPopper popper = new PopcornPopper(\u0026#34;Popcorn Popper\u0026#34;); HomeTheaterFacade homeTheater = new HomeTheaterFacade(amp, tuner, player, projector, screen, lights, popper); homeTheater.watchMovie(\u0026#34;Raiders of the Lost Ark\u0026#34;); homeTheater.endMovie(); 参考：《HeadFist设计模式》\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/appearance-mode/","tags":["design","java"],"title":"外观模式"},{"categories":["Language"],"contents":"适配器模式 定义 适配器模式将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。\n代码展示 鸭子和火鸡叫声不一样，通过编写适配器让火鸡适配鸭的方法。\n从接口开始 1 2 3 4 public interface Duck { public void quack(); public void fly(); } 1 2 3 4 public interface Turkey { public void gobble(); public void fly(); } 编写适配器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class TurkeyAdapter implements Duck { Turkey turkey; public TurkeyAdapter(Turkey turkey) { this.turkey = turkey; } public void quack() { turkey.gobble(); } public void fly() { for(int i=0; i \u0026lt; 5; i++) { turkey.fly(); } } } 编写具体类 绿头鸭：\n1 2 3 4 5 6 7 8 9 public class MallardDuck implements Duck { public void quack() { System.out.println(\u0026#34;Quack\u0026#34;); } public void fly() { System.out.println(\u0026#34;I\u0026#39;m flying\u0026#34;); } } 野火鸡：\n1 2 3 4 5 6 7 8 9 public class WildTurkey implements Turkey { public void gobble() { System.out.println(\u0026#34;Gobble gobble\u0026#34;); } public void fly() { System.out.println(\u0026#34;I\u0026#39;m flying a short distance\u0026#34;); } } 代码测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class DuckTestDrive { static void testDuck(Duck duck) { duck.quack(); duck.fly(); } public static void main(String[] args) { Duck duck = new MallardDuck(); Turkey turkey = new WildTurkey(); Duck turkeyAdapter = new TurkeyAdapter(turkey); turkey.gobble(); turkey.fly(); testDuck(duck); testDuck(turkeyAdapter); } } 参考：《HeadFist设计模式》\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/adapter-mode/","tags":["design","java"],"title":"适配器模式"},{"categories":["Book"],"contents":"作者：本尼迪克特\n第5章 背负着历史和社会恩情债的日本人 日本人对于卷入“恩情”的事都表现得十分谨慎。即使是一支烟，递烟的人要是过去与他没有什么交往，也会让他感到别扭。碰到这种情况，日本人表达谢意的最礼貌回答一般是：“真过意不去”（日语是“の毒”，它原本的意思是让人为难的感情）。\n曾经有一个日本人给我解释了为什么要这样说：“碰到这样的事，把自己感到为难的情况直接表达出来还会更好受一些，虽然拒绝总是让人难为情。如果轻易接受了这样的帮助，而你又根本没有想过为对方做事，那么你的‘受恩’就是让人感到羞耻的。”因此只能说，“真过意不去”（の毒）。\n英语对于“の毒”这句话的翻译，有时是“Thank you”（谢谢。谢谢您的烟）有时是“I am sorry”（很抱歉，很遗憾），或者需要翻译成“I feel like a heel”（蒙您看得起。实在不好意思）。每个译法都没有错误，可是都不贴切。\n第8章 名声的价值 他们觉得，如果不能洗刷有关自己的耻辱，那就是彼此之间存在着不公平，“世界就不平衡”。一个正义之士的最高理想就是尽自己最大的努力让世界重归平衡。这是一种高尚的美德，无关于人性中的罪恶。\n在欧洲历史上也出现过人们非常看重名誉的时期，人们也把“对名誉的情义”看做一种道德准则，比如文艺复兴时期的意大利，这种风尚也曾盛极一时，还有古典时期西班牙的el valor Espanol（西班牙的勇敢）以及德意志的die Ehre（名誉），都与日本的“对名誉的情义”有很多共通的地方，甚至在一百多年以前欧洲颇为流行的决斗行为似乎也是在与这种道德准则相类似的观念驱使下进行的。\n值得注意的是，不管是日本，还是西欧各国，只要是雪耻道德观念成为多数人认同的共同价值，那么这个地方的人多数都会把道德置于物质利益之上。所以，越是为了自己的“名誉”而牺牲财产、家庭及其生命的人，就越被认为是一个有着高尚道德的人。名誉已经成了道德的一部分，它被这个国家常常作为“精神”价值的基础而大大提倡。这种价值观必然会产生对物质价值观的贬抑，同样它能够给这个民族带来与众不同的东西。\n这种对于名誉十分看重的观念，正与我们美国人在生活中到处都要激烈竞争和公开对抗的观念有一个鲜明的对比。在美国的一些政治或经济活动中，如果要获得或保持某种物质利益，那一定是一种“战争”。日本人对于名誉的捍卫就像我们对于利益的捍卫一样，没有什么不同。\n不过，我们不要觉得亚洲大陆都会有出现因捍卫自己的名誉而有的敌意和伺机报复甚至是极端行动。这完全不是东方的气质，中国人就不会这样，暹罗人、印度人也没有这个特点。当中国人遇到侮辱或诽谤的时候，他们会认为这些人是“小人”，是没有道德的人。中国人非常重视名誉但中国人不会像日本人一样把名誉看成是高尚的理想。在中国，如果一个人因为名誉受损而使用不正当的暴力来肆意报复所遇的侮辱被视为一种十分愚蠢的行为。他们认为这是神经过敏，十分可笑。他们也不会一定要做什么以证明自己的清白，更多时候，他们会对毫无根据的侮辱和诽谤置之不理，因为在中国人眼里，“君子”是不值得和“小人”一般见识的。至于暹罗人，根本无法从他们身上看到有谁对侮辱多么敏感。他们和中国人一样，让诽谤者自己处于尴尬的地位，便足以保证自己的名誉不会受到损害。他们的格言说：“让对方暴露自己卑鄙的最好办法就是自己的容忍。”\n如果说世界上有最不能饶恕的罪过的话，那就是待人没有诚意，而嘲笑别人是最没有诚意的待人之道。\n如果有人朝我发火，我会原谅他，因为有些人就是有一副急脾气；如果有人对我撒谎，我也可以原谅他，因为有些谎言是被逼无奈的选择；如果有人在传一些没有任何根据的流言或者背后对别人品头论足，我同样可以原谅他，因为当人们在遇到别人聊起闲话时，有时候会不自觉地陷进去。\n甚至就算是一个杀人犯，我也不会不分青红皂白彻底否定他。可是对于嘲笑别人的人，这是绝对无法原谅的，因为这样的人内心之中没有任何待人的真诚，所以他才不顾他人的感受让一个无辜者难堪。\n现在让我来说明一下我对这两个词的定义。所谓杀人犯，就是残害他人肉体的人；而所谓嘲笑者，是残害他人心灵的人。\n遇到失败、污蔑或者被排斥的日本人都非常敏感，因此常常生自己的气而不是生别人的气。现在的日本小说大多所描写的就是一个有教养的日本人是如何不安地面对极端狂怒与悲伤抑郁的故事，这能反映很多日本人的情绪。在小说中，主角对于一切不满，讨厌日常生活，讨厌家庭，讨厌城市，讨厌乡村。这种情绪不是因为自己的理想没有实现，而是在理想的目标面前，自己的努力太过渺小。其实如果有一个远大的目标远景，无论这是一个多么遥远的目标，日本人的厌倦情绪都会消失得无影无踪，之所以有这种厌倦情绪更多的是因为自己的敏感，他们常常害怕自己被排斥在伟大事业之外，因此内心没有依靠。\n日本的小说所反映的内容总是一个弥漫着能够让人情绪爆发的有毒气体的社会。无论是小说的主人公还是作者本人都不会花心思弄明白为什么在日本社会中会弥漫着这样的空气，似乎这是一种正常现象。正是因为总有这种刺激人们情绪的氛围，所以人们都容易伤感。在封建时代，日本人会把自己的情绪指向对自己进行侵犯的人，可是现在，他们却将这种攻击转向自己。在他们看来，一个人忧郁不一定因为十分明确的原因，虽然能够找一些借口安慰自己：我是因为某事而心情不好，可是他们内心之中更多的是埋怨自己。\n第十二章 儿童学习 在转入扩大精神自由的过渡时期，日本人或许可以借助两三种古老的传统而保持平稳。其中之一就是“自我负责”精神，亦印他们所说的自己负责擦掉“身上的锈”。这一形象的语言把身体比作刀，正如佩刀者有责任保护刀的光洁，人也要对自己行为的后果负责。他必须承认并接受由于自己的弱点、不坚定和无效性而产生的一切自然后果。在日本，对自我负责的解释远比自由的美国更加严格。在这种意义上，刀不是进攻的象征，而是理想和敢于自我负责者的比喻。在尊重个人自由的社会，这种德性将起着最有效的平衡轮的作用。而且，日本的儿童教养和行为哲学已使自我负责的德性深入人心，成为日本精神的一部分。现在日本人已经在西方意义上提出了“放下刀”（投降），但在日本意义上，他们仍将继续努力关注如何才能使心中那把易被锈蚀的刀保持光洁。就他们的道德术语而言，这把刀是一种即使在自由、和平世界也能保存的象征。\n","permalink":"/posts/2022/08/chrysanthemum-and-knife-abstract/","tags":["excerpt"],"title":"《菊与刀》文摘"},{"categories":["Book"],"contents":"作者：米兰·昆德拉\n第一部 轻与重 他付了账，走出饭店，想在街上逛逛，满怀的忧郁渐渐地令他心醉。他同特蕾莎已经生活了七个春秋，此刻他才发现，对这些岁月的回忆远比他们在一起生活时更加美好。\n他和特蕾莎之间的爱情无疑是美好的，但也很累人：总要瞒着什么，又是隐藏，又是假装，还得讲和，让她振作，给她安慰，翻来覆去地向她证明他爱她，还要忍受因为嫉妒、痛苦、做噩梦而产生的满腹怨艾，总之，他总感到自己有罪，得为自己开脱，请对方原谅。现在，再也不用受累了，剩下的只有美好。\n星期六的夜晚开始了；他第一次独自在苏黎世漫步，深深地呼吸着自由的芬芳。在每个角落，都潜藏着诱惑。未来成了一个谜。他又回到了单身汉的生活，他曾坚信自己命中注定要过这种生活，因为只有在这样的生活中他才真正是他自己。\n他跟特蕾莎捆在一起生活了七年，七年里，他每走一步，她都在盯着。仿佛她在他的脚踝上套了铁球。现在，他的脚步突然间变得轻盈了许多。他几乎都要飞起来了。此时此刻，他置身于巴门尼德的神奇空间：他在品尝着温馨的生命之轻。\n第二部 灵与肉 我们每天的生活充满了各种偶然性，确切地说，是人、事之间的偶然相遇，我们称之为巧合。两件预料不到的事出现在同一时刻，就叫巧合。他俩的相遇，便是巧合：托马斯出现在酒吧的时刻，收音机里正播放着贝多芬的乐曲。这些巧合绝大多数都在不经意中就过去了。如果不是托马斯，而是街角卖肉的坐在酒吧的桌子旁，特蕾莎可能不会注意到收音机在播放贝多芬的乐曲（虽然贝多芬和卖肉的相遇也是一种奇怪的巧合）。但是萌生的爱情使她对美的感觉异常敏锐，她再也忘不了那首乐曲。每次听到这首乐曲，她都激动不已。那一刻发生在她身边的一切都闪耀着这首乐曲的光环，美轮美奂。\n这不是喘息，也不是呻吟，是真正的喊叫。叫声太大了，托马斯不得不让头偏离她的脸远一点，仿佛这尖叫声就要震裂他的耳膜。这不是肉欲的发泄。所谓肉欲便是极度调动众感官：热切地注视对方的一举一动，全神贯注地倾听对方的每一丝声响。恰恰相反，特蕾莎喊叫，却是为了让感官迟钝，使它们无法去注视、去倾听。在她体内发出的喊叫，是为了表达她那幼稚的理想主义的爱情，要消除一切矛盾，消除肉体和灵魂的两重性，甚或消除时间。\n特蕾莎读的书比他们多，对生活的了解也比他们透彻，但她自己从未意识到这些。自学者和学生的区别，不在于知识的广度，而在于生命力和自信心的差异。\n第三部 不解之词 音乐对弗兰茨来说，最接近于酒神狄俄尼索斯那种狂醉之美的，是艺术。靠小说和画幅难以自遣，但是听贝多芬的《第九交响曲》，巴托克的《钢琴二重奏鸣曲》，或是披头士的一支歌，就能自我陶醉。弗兰茨对高雅音乐和轻音乐不加区分。区分在他看来是虚伪而老套的。他对摇滚乐和莫扎特的喜爱不偏不倚。\n对他来说，音乐是救星：它将他从孤独、幽闭和图书馆里的灰尘之中解救出来，它在他的身躯上打开了多扇门，使灵魂得以释放，与他人相亲相爱。他喜欢跳舞，并为萨比娜不跟他一样喜欢跳舞而感到遗憾。\n对萨比娜来说，活着意味着观看。视觉受双重边界所限：让人什么也看不见的强光与完全彻底的黑暗。她对任何极端主义的憎恶，或许产生于此。极端标志着生命的终极之界，极端主义的激情，不论是政治上的，还是艺术上的，都是一种改头换面的对死的渴望。\n而对于弗兰茨，“光明”这个词不会让人联想到柔和的日光照耀下的风景，而会想到光源，如太阳，灯泡，探照灯。他想起一些常见的隐喻，如真理之太阳，理性的耀眼之光，等等。\n他被光明吸引，同样也被黑暗所吸引。如今，关灯做爱，在世人看来委实可笑。对此他也明白，所以让床上方亮着一盏小灯。但在进入萨比娜身体的那一瞬，他还是闭上了双眼。吞噬着他的极度快感企求的是黑暗。那黑暗是彻底的，绝对的，没有形象也没有幻影，无穷无尽，无边无际。那黑暗是我们每个人内心所在的无限。（是的，凡寻求无限者，只需闭上双眼！）\n就在快感在他全身蔓延开来的那一刻，弗兰茨在无边的黑暗中渐渐展开，融化，化作了无限。但是，人在内在的黑暗中变得越大，他的外在形象就越小。一个紧闭双眼的男人，只是一个毁弃了的自我，看起来让人心生厌恶。因此萨比娜不愿看着他，也闭上了眼睛。但这种黑暗对她来说并不意味着无限，而仅仅是对她所见的东西的拒绝，是对所见之物的否定，是拒绝去看。\n从浴室出来，她摁下了开关。这是她第一次这么做。弗兰茨本该留心她这一举动。他并没注意到，因为光线对于他无关紧要，我们知道，做爱时他总是闭着眼睛。正是由于他紧闭的双眼萨比娜才将灯熄灭。她不愿看见，即便只是一秒，那垂下的眼帘。如俗语所说，眼睛是心灵之窗。弗兰茨的身体伏在她身上扭动，双眼紧闭，在她看来，这只是一具没有灵魂的躯体。他像是一只尚未睁眼的幼崽，因为饥渴而发出阵阵可怜的嗷叫。肌肉强健的弗兰茨做爱时就像一只吃奶的巨大幼犬。确实如此，他嘴里还含着她的一只乳头，如同吮奶一样！下半身的弗兰茨是个成年男子，而上半身则是个吮乳的婴儿，那么她是在跟一个婴儿上床，一想到这，她觉得厌恶到了极点。不，她再也不愿看到他无望地在她身上挣扎，再也不愿像母狗喂幼崽一样送上自己的乳房。今天是最后一次，无可挽回的最后一次！\n当然，她明白，自己的决定极不公平。弗兰茨是她所遇见的男人中最优秀的。他聪明，懂她的画。他善良，正直，英俊。但她心里愈清楚，愈想去践踏他的聪明、善良，践踏他那脆弱的强健。\n这一夜，她以胜过往日的激情与他做爱，因为想到是最后一次而万分激动。她与他缠绵着，而心早已到了遥远的别处。她再度听见远方吹响叛逆的金号角，清楚自己无力抗拒那号声的召唤。她眼前仿佛展开了一片更为广阔的自由天地，那天地之广大令她兴奋。她疯狂而粗野地与弗兰茨做爱，好像从未曾有过那样。\n弗兰茨在她身上唏嘘，他肯定明白了一切：晚餐时，萨比娜默不作声，也没跟他说对他的决定是怎么想的。可是现在，她回应了他。她在向他显示她的欢悦、激情、允诺和与他共度一生的渴望。\n他感觉自己像是骑士，驰骋在一片极其美妙的空白里，没有配偶，没有子女，没有家庭，被赫拉克勒斯巨人之帚清扫一空的绝对空白，他将以爱情来把它填满。\n他们彼此以对方为坐骑，奔向他们所向往的远方。他们都沉醉在令自己获得解放的背叛之中，弗兰茨骑着萨比娜背叛了他的妻子，而萨比娜骑着弗兰茨背叛了弗兰茨。\n人生的悲剧总可以用沉重来比喻。人常说重担落在我们的肩上。我们背负着这个重担，承受得起或是承受不起。我们与之反抗，不是输就是赢。可说到底，萨比娜身上发生过什么事？什么也没发生。她离开了一个男人，因为她想离开他。在那之后，他有没有再追她？有没有试图报复？没有。她的悲剧不是因为重，而是在于轻。压倒她的不是重，而是不能承受的生命之轻。\n第四部 灵与肉 她只想在工程师家里待一会儿，只喝杯咖啡，看看自己是如何走向不忠的边缘的。她想把自己的身体推至那边缘，在不忠的示众柱上待上片刻，然后，当工程师试图把她抱在怀里的那一刻，她会像她在彼得山上对持枪的男人那样，对他说：“不，不！这不是我的意愿。”\n那男人会垂下他的枪口，声音温柔地说：“如果这不是您的意愿，我就不能这样做。我没有这个权利。”\n她会转过头去，朝向树干，号啕大哭。\n第五部 轻与重 追逐众多女性的男人很容易被归为两类。一类人在所有女人身上寻找他们自己的梦，他们对于女性的主观意念。另一类人则被欲念所驱使，想占有客观女性世界的无尽的多样性。\n前者的迷恋是浪漫型的迷恋：他们在女人身上寻找的是他们自己，是他们的理想。他们总是不断地失望，因为，正如我们所知，理想从来都是不可能找到的。失望把他们从一个女人推向另一个女人，赋予他们的善变一种感伤的借口，因此，许多多愁善感的女人为他们顽强的纠缠所感动。\n后者的迷恋是放荡型的迷恋，女人在其中看不到丝毫感人之处：由于男人没有在女性身上寄托一个主观的理想，他们对所有女人都感兴趣，没有谁会令他们失望。的确，就是这从不失望本身带有某种可耻的成分。在世人眼中，放浪之徒的迷恋是不可宽恕的（因为从不为失望而补赎）。\n他想起了柏拉图《会饮篇》中那个著名传说：以前人类是两性同体的，上帝把他们分成了两半，从那时起，这两半就开始在世界上游荡，相互寻找。爱情，是对我们自己失去的另一半的渴望。\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/abstract-of-unbearable-lightness-of-life/","tags":["excerpt"],"title":"《不能承受的生命之轻》文摘"},{"categories":["Language"],"contents":"定义 命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。\n比如对于遥控器而已，我们会将操作封装为一个按钮（命令）对象，通过按下按钮执行操作。\n代码展示 下面以遥控器作为例子：\n从接口开始 命令接口：\n1 2 3 public interface Command { public void execute(); } 定义操控对象 一个风扇对象：（其它对象省略了）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Light { String location = \u0026#34;\u0026#34;; public Light(String location) { this.location = location; } public void on() { System.out.println(location + \u0026#34; light is on\u0026#34;); } public void off() { System.out.println(location + \u0026#34; light is off\u0026#34;); } } 定义操控对象的命令 操作风扇的命令：\n开风扇：\n1 2 3 4 5 6 7 8 9 10 11 public class LightOnCommand implements Command { Light light; public LightOnCommand(Light light) { this.light = light; } public void execute() { light.on(); } } 关风扇：\n1 2 3 4 5 6 7 8 9 10 11 public class LightOffCommand implements Command { Light light; public LightOffCommand(Light light) { this.light = light; } public void execute() { light.off(); } } 定义空命令 用于初始化遥控器：\n1 2 3 public class NoCommand implements Command { public void execute() {} } 定义遥控器 包含两个数组，分别用于开命令和关命令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class RemoteControl { Command[] onCommands; Command[] offCommands; public RemoteControl() { onCommands = new Command[7]; offCommands = new Command[7]; Command noCommand = new NoCommand(); for (int i = 0; i \u0026lt; 7; i++) { onCommands[i] = noCommand; offCommands[i] = noCommand; } } public void setCommand(int slot, Command onCommand, Command offCommand) { onCommands[slot] = onCommand; offCommands[slot] = offCommand; } public void onButtonWasPushed(int slot) { onCommands[slot].execute(); } public void offButtonWasPushed(int slot) { offCommands[slot].execute(); } public String toString() { ... } } 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 RemoteControl remoteControl = new RemoteControl(); Light livingRoomLight = new Light(\u0026#34;Living Room\u0026#34;); Light kitchenLight = new Light(\u0026#34;Kitchen\u0026#34;); CeilingFan ceilingFan= new CeilingFan(\u0026#34;Living Room\u0026#34;); GarageDoor garageDoor = new GarageDoor(\u0026#34;Garage\u0026#34;); Stereo stereo = new Stereo(\u0026#34;Living Room\u0026#34;); LightOnCommand livingRoomLightOn = new LightOnCommand(livingRoomLight); LightOffCommand livingRoomLightOff = new LightOffCommand(livingRoomLight); LightOnCommand kitchenLightOn = new LightOnCommand(kitchenLight); LightOffCommand kitchenLightOff = new LightOffCommand(kitchenLight); CeilingFanOnCommand ceilingFanOn = new CeilingFanOnCommand(ceilingFan); CeilingFanOffCommand ceilingFanOff = new CeilingFanOffCommand(ceilingFan); GarageDoorUpCommand garageDoorUp = new GarageDoorUpCommand(garageDoor); GarageDoorDownCommand garageDoorDown = new GarageDoorDownCommand(garageDoor); StereoOnWithCDCommand stereoOnWithCD = new StereoOnWithCDCommand(stereo); StereoOffCommand stereoOff = new StereoOffCommand(stereo); remoteControl.setCommand(0, livingRoomLightOn, livingRoomLightOff); remoteControl.setCommand(1, kitchenLightOn, kitchenLightOff); remoteControl.setCommand(2, ceilingFanOn, ceilingFanOff); remoteControl.setCommand(3, stereoOnWithCD, stereoOff); System.out.println(remoteControl); remoteControl.onButtonWasPushed(0); remoteControl.offButtonWasPushed(0); remoteControl.onButtonWasPushed(1); remoteControl.offButtonWasPushed(1); remoteControl.onButtonWasPushed(2); remoteControl.offButtonWasPushed(2); remoteControl.onButtonWasPushed(3); remoteControl.offButtonWasPushed(3); 参考：《HeadFist设计模式》\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/command-mode/","tags":["design","java"],"title":"命令模式"},{"categories":["Language"],"contents":"我的思考 单件模式，容易知道需要某个对象是独一无二的，那么它首先应该是静态的，不能在程序动态运行期间被再次创建。\n当在多个线程中用到它时，在创建时需要考虑线程安全问题，可通过加锁等方式解决。\n代码实现 传统的单件 定义一个私有实例化的对象，把单件对象作为一个私有的静态成员变量，通过静态方法Singleton.getInstance()获取，若获取为null则创建对象。\n1 2 3 4 5 6 7 8 9 10 11 12 public class Singleton { private static Singleton uniqueInstance; private Singleton() {} public static Singleton getInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } } 线程安全的单件 传统的单件线程不安全，解决如下：\n1 2 3 4 5 6 7 8 9 10 11 12 public class Singleton { private static Singleton uniqueInstance; private Singleton() {} public static synchronized Singleton getInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } } 改善多线程性能 如上线程安全的代码，getInstance()在多次调用的情况下性能太低，改善方法如下：\n一、“急切”创建实例（“饿汉式”）\nJVM加载该类时马上创建实例，也保证线程安全。\n1 2 3 4 5 6 7 8 9 public class Singleton { private static final Singleton uniqueInstance = new Singleton(); private Singleton() {} public static Singleton getInstance() { return uniqueInstance; } } 二、双重检查加锁（“懒汉式”）\n保证只在第一次获取对象时才加锁。\nvolatile确保当uniqueInstance被初始化时，多个线程正确处理uniqueInstance变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Singleton { private volatile static Singleton uniqueInstance; private Singleton() {} public static Singleton getInstance() { if (uniqueInstance == null) { synchronized (Singleton.class) { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } } } return uniqueInstance; } } 枚举实现的单件 首先明白一个问题，枚举类型为什么是线程安全的？\n我们定义的一个枚举，在第一次被真正用到的时候，会被虚拟机加载并初始化，而这个初始化过程是线程安全的。而我们知道，解决单例的并发问题，主要解决的就是初始化过程中的线程安全问题。\n所以，由于枚举的以上特性，枚举实现的单例是天生线程安全的。\n1 2 3 public enum Singleton { UNIQUE_INSTANCE; } 通过Singleton.UNIQUE_INSTANCE;即可获取该实例。\n参考：《HeadFist设计模式》\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/singleton-pattern/","tags":["java","design"],"title":"单件模式"},{"categories":["Language"],"contents":"我的思考 工厂模式，包括工厂方法模式和抽象工厂模式。\n对于工厂方法模式，工厂是一个抽象类，提供了一些默认实现方法和一些抽象方法，具体工厂继承于它，实现对应抽象方法。\n假设有多家比萨店，他们提供不同口味的比萨，而都有相同的订购比萨的方法，那么可以定义一个抽象类，提供订购比萨的具体方法和创建比萨的抽象方法。\n对于抽象工厂模式，工厂是一个接口，提供了一些具体工厂会用到的方法，同时还需要定义这些方法可能用到的接口。具体工厂需要首先实现抽象工厂定义的方法可能用到的接口，然后实现抽象工厂的所有方法。\n假设有多家生产比萨配料的工厂，他们都有自己的独特的配料（实现所有配料接口），那么可以定义一个抽象工厂（一个接口），提供所有配料创建方法，具体工厂各自实现所有创建方法即可。\n总之，他们的具体区别如下：\n工厂方法模式使用继承，把对象的创建委托给子类，子类实现工厂方法来创建对象。 抽象工厂模式使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中。 工厂方法模式代码 从抽象开始 比萨店抽象类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public abstract class PizzaStore { abstract Pizza createPizza(String item); public Pizza orderPizza(String type) { Pizza pizza = createPizza(type); System.out.println(\u0026#34;--- Making a \u0026#34; + pizza.getName() + \u0026#34; ---\u0026#34;); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; } } 具体的比萨店 芝加哥的比萨店：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ChicagoPizzaStore extends PizzaStore { Pizza createPizza(String item) { if (item.equals(\u0026#34;cheese\u0026#34;)) { return new ChicagoStyleCheesePizza(); } else if (item.equals(\u0026#34;veggie\u0026#34;)) { return new ChicagoStyleVeggiePizza(); } else if (item.equals(\u0026#34;clam\u0026#34;)) { return new ChicagoStyleClamPizza(); } else if (item.equals(\u0026#34;pepperoni\u0026#34;)) { return new ChicagoStylePepperoniPizza(); } else return null; } } 关于其它比萨店和比萨的实现省略了。\n测试代码 根据自然的思路：首先应有比萨店，顾客选择比萨店，选择具体口味的比萨，完成订单。\n1 2 3 4 5 6 7 8 9 10 11 PizzaStore nyStore = new NYPizzaStore(); PizzaStore chicagoStore = new ChicagoPizzaStore(); Pizza pizza = nyStore.orderPizza(\u0026#34;cheese\u0026#34;); System.out.println(\u0026#34;Ethan ordered a \u0026#34; + pizza.getName() + \u0026#34;\\n\u0026#34;); pizza = chicagoStore.orderPizza(\u0026#34;cheese\u0026#34;); System.out.println(\u0026#34;Joel ordered a \u0026#34; + pizza.getName() + \u0026#34;\\n\u0026#34;); pizza = nyStore.orderPizza(\u0026#34;clam\u0026#34;); System.out.println(\u0026#34;Ethan ordered a \u0026#34; + pizza.getName() + \u0026#34;\\n\u0026#34;); 抽象工厂模式代码 从抽象开始 配料工厂接口：\n1 2 3 4 5 6 7 8 9 10 public interface PizzaIngredientFactory { public Dough createDough(); public Sauce createSauce(); public Cheese createCheese(); public Veggies[] createVeggies(); public Pepperoni createPepperoni(); public Clams createClam(); } 提供各种配料接口：\n1 2 3 public interface Cheese { public String toString(); } 其它的省略了。\n实现配料接口 1 2 3 4 5 public class MozzarellaCheese implements Cheese { public String toString() { return \u0026#34;Shredded Mozzarella\u0026#34;; } } 其它的省略了。\n实现配料工厂接口 具体的配料工厂，提供自己实现的配料。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class ChicagoPizzaIngredientFactory implements PizzaIngredientFactory { public Dough createDough() { return new ThickCrustDough(); } public Sauce createSauce() { return new PlumTomatoSauce(); } public Cheese createCheese() { return new MozzarellaCheese(); } public Veggies[] createVeggies() { Veggies veggies[] = {new BlackOlives(), new Spinach(), new Eggplant()}; return veggies; } public Pepperoni createPepperoni() { return new SlicedPepperoni(); } public Clams createClam() { return new FrozenClams(); } } 其它配料工厂省略了。\n再从抽象开始 抽象的比萨应该含有所有工厂可能用到的配料，同时应该提供一个准备配料的抽象方法，在具体的比萨中实现这个方法，指定需要的配料，不要的则为null。\n抽象的比萨店如工厂方法模式一样。\n代码省略了。\n测试代码 如工厂方法模式一样，这里省略了。\n参考：《HeadFist设计模式》\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/factory-mode/","tags":["design","java"],"title":"工厂模式"},{"categories":["Language"],"contents":"我的思考 装饰，如其名，就是对一个对象进行加工，包装，修饰。\n假设一杯“普通的咖啡，价格10”，我们可以选择添加自己喜欢的配料。\n首先我们添加牛奶，那么就变成了一杯“含牛奶配料的咖啡，价格2 +（价格12）”；\n我想再加点巧克力，那么再往上包装变成“含巧克力的含牛奶配料的咖啡，价格3 +【价格2+（价格12）】”。\n这么一层层封装上去就是装饰模式。\n我们要在每一个配料中定义一个可包装的对象，在包装后返回这个对象。具体代码如下文。\n代码实现 定义抽象类 饮料抽象类：\n1 2 3 4 5 6 7 8 9 public abstract class Beverage { String description = \u0026#34;Unknown Beverage\u0026#34;; public String getDescription() { return description; } public abstract double cost(); } 配料抽象类：\n注意这里配料也继承了饮料类，这样Beverage在通过包装之后还是返回一个Beverage，具体见测试代码。\n1 2 3 4 public abstract class CondimentDecorator extends Beverage { Beverage beverage; public abstract String getDescription(); } 定义具体类 牛奶配料：（其他配料省略）\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Milk extends CondimentDecorator { public Milk(Beverage beverage) { this.beverage = beverage; } public String getDescription() { return beverage.getDescription() + \u0026#34;, Milk\u0026#34;; } public double cost() { return .10 + beverage.cost(); } } 浓缩咖啡类：（其他饮料略）\n1 2 3 4 5 6 7 8 9 10 public class Espresso extends Beverage { public Espresso() { description = \u0026#34;Espresso\u0026#34;; } public double cost() { return 1.99; } } 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class StarbuzzCoffee { public static void main(String args[]) { Beverage beverage = new Espresso(); System.out.println(beverage.getDescription() + \u0026#34; $\u0026#34; + beverage.cost()); Beverage beverage2 = new DarkRoast(); beverage2 = new Mocha(beverage2); beverage2 = new Mocha(beverage2); beverage2 = new Whip(beverage2); System.out.println(beverage2.getDescription() + \u0026#34; $\u0026#34; + beverage2.cost()); Beverage beverage3 = new HouseBlend(); beverage3 = new Soy(beverage3); beverage3 = new Mocha(beverage3); beverage3 = new Whip(beverage3); System.out.println(beverage3.getDescription() + \u0026#34; $\u0026#34; + beverage3.cost()); } } 参考：《HeadFist设计模式》\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/decorator-mode/","tags":["design","java"],"title":"装饰者模式"},{"categories":["Language"],"contents":"我的思考 对于观察者模式，既然有观察者，那么就首先有被观察者。\n观察者可以通过订阅，监听等方式实现“观察”，被观察者需要通过通知，发消息之类的方式通知观察者接收信息。\n假设有一个气象观测站，天气数据对象作为被观察者，各个气象观测站作为观察者订阅天气数据，而天气数据记录各个订阅了自己的观测站，以便于通知。具体代码实现如下文。\n代码实现 定义接口 被观察者：\n1 2 3 4 5 public interface Subject { public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers(); } 观察者：\n1 2 3 public interface Observer { public void update(float temp, float humidity, float pressure); } 定义对象实现接口 天气数据对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class WeatherData implements Subject { private List\u0026lt;Observer\u0026gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() { observers = new ArrayList\u0026lt;Observer\u0026gt;(); } public void registerObserver(Observer o) { observers.add(o); } public void removeObserver(Observer o) { observers.remove(o); } public void notifyObservers() { for (Observer observer : observers) { observer.update(temperature, humidity, pressure); } } public void measurementsChanged() { notifyObservers(); } public void setMeasurements(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); } public float getTemperature() { return temperature; } public float getHumidity() { return humidity; } public float getPressure() { return pressure; } } 气象观测站对象：\n省略了StatisticsDisplay和ForecastDisplay。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class CurrentConditionsDisplay implements Observer { private float temperature; private float humidity; private WeatherData weatherData; public CurrentConditionsDisplay(WeatherData weatherData) { this.weatherData = weatherData; weatherData.registerObserver(this); } public void update(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; display(); } public void display() { ... } } 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class WeatherStation { public static void main(String[] args) { WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentDisplay = new CurrentConditionsDisplay(weatherData); StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData); ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData); weatherData.setMeasurements(80, 65, 30.4f); weatherData.setMeasurements(82, 70, 29.2f); weatherData.setMeasurements(78, 90, 29.2f); weatherData.removeObserver(forecastDisplay); weatherData.setMeasurements(62, 90, 28.1f); } } 参考：《HeadFist设计模式》\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/observer-mode/","tags":["java","design"],"title":"观察者模式"},{"categories":["Book"],"contents":"作者：冈岛二人\n梨纱凝视着我。她的鼻子近在咫尺。我俩的鼻尖蹭在了一起，梨纱缓缓闭上了眼睛。于是我贴近她的脸，让唇与唇轻轻触碰。她的吐息拂过我的脸颊。我加深了吻，她的气息中顿时掺杂了如啜泣般的声音。\n——快回去。\n百濑的声音从梨纱的喘息中传来。\n——趁现在还可以控制，快逃吧。\n我抱住梨纱，手上用力。\n梨纱双眸微闭，我学着她的样子，也慢慢闭上了眼。\n镜子，映出了我的身影。\n然而，人们为什么能断言自己在镜外、映出的影像在镜内呢?谁也无法直接看见自己的眼睛。想知道自己的瞳孔颜色，就只能窥视镜子。既然如此，或许双瞳仅存在于镜中，不是吗?\n现在想想，与“克莱因壶”扯上关系的最初一瞬间，我就已经被吸进壶里了。一定是的。正如拿起镜子时，双瞳会被摄入镜中世界一样。一旦被吞入，就绝无可能爬出去。\n从阁楼的窗户向外眺望，山叶开始渐渐转红。我下山买的报纸上还在大肆报道残暑未消，这一带却已是秋意袭人。\n这时，一只翠羽鸟从我眼前飞过，唯有翅膀的中央夹着一道白纹。\n我打算写完这段话，就下楼去浴室把脏胡子刮掉，然后从刮胡刀上拆下刀片，躺进浴缸。我想裸身在浴缸里躺下，用刀片割腕试试。\n这是留给我的最后一招。\n这里是壶内还是壶外，别无他法验证。我只能在浴缸里割腕。然后会怎样，我不知道。我甚至无法看到结果。\n如果这是壶内，恐怕会游戏终止。如果这是壶外——\n其实，结果如何并不重要，将这百转千回的思绪击个粉碎才是我的本意。 “从开始的地方开始，在结束的地方结束。这样就行。”\n就这么做吧，我想。\n","permalink":"/posts/2022/08/klein-pot-abstract/","tags":["excerpt"],"title":"《克莱因壶》文摘"},{"categories":["Life"],"contents":"记录下沉浸在只狼的世界中的那段时光里，让我印象深刻的一些地方。\n这是白雪覆盖之下的苇名城，颇具美感。\n第一个感觉难残的boss是赤鬼，但凡多贪一刀就很容易被抓住干掉，同时如果不知道红颜怪怕火这个特点，那么只能跟它一来一回磨血量了。后面双难模式下打赤鬼，虽然被抓到就是秒杀，但是如果使用火刀，反而轻而易举地可以拿下赤鬼。和赤鬼的战斗十分刺激，也十分绝望，当时花了不少时间，在一次又一次的死亡中，吸取教训，提高熟练度，最终战胜强敌。\n之后打完赤鬼往前走，在悬崖峭壁之间，我初遇白蛇，开始真正被这个游戏所吸引：\n这是一条巨大无比的白蛇，据考证应该是一条双头蛇，要么就是有两条这样的蛇，因为后期忍杀了一条后，还能发现在洞窟里发现另一个蛇头在动。它曾经是当地人信仰的白蛇神。遇见这条蛇时，我欣赏了许久（也挂了不少次=_=），颇有趣味，感觉来到了一个奇异的世界。\n对战义父，父慈子孝。选择了保护神子，坚持自己的信念，就必须和义父反目成仇。此时的天守阁正是黄昏时刻，一场艰苦卓绝的战斗即将开始：\n这是一场无比艰难的战斗。义父的攻击时快时慢，各种招数层出不穷。他的韧性很高，想把他逼入绝境，必须不断地进攻。\n最后，狼是从背后忍杀了义父，留下一句“落影，物归原主”，取回落樱。而同时也是狼还给义父的一刀，还的是三年前义父背刺狼的那一刀。\n在前往狮子猿所在地的路上，悬崖绝壁之间，筑有许多巨大佛雕，额外有意思，也令人生畏：\n置身源之宫，如梦如画。满湖落樱，清水如镜。第一次来时的确感觉来到了世外桃源。但是后来慢慢深入内部，才发现这华美的景象背后潜藏着多么丑陋的东西\u0026hellip;\u0026hellip;\n初见樱龙，气势凌人，这虽然只是一场表演战，但是还是特别有意思。第一次见的时候完全被樱龙的气势震撼到：\n拿到龙泪后，便回到苇名城，准备最后的对决了。此时的苇名城已经混乱不堪，战斗愈演愈烈。\n最后对战剑圣苇名一心。它无疑是只狼中难度仅次于怨恨之鬼的boss了。但在一周目时感觉和义父也五五开吧，在双难模式下就比义父难多了。\n第一次遇见一心，很难不为他的剑圣风范所震慑到：\n最后作为介错人处死一心，也能感受到他无比的剑圣气质。\n在三周目尝试堕为修罗，这的确算是是最坏的结局，狼最后甚至把义父也杀了\u0026hellip;\u0026hellip;在高周目玩了一次这个结局，感觉没有动力在玩一次修罗结局了。\n于火光中结束一切\u0026hellip;\u0026hellip;\n个人最满意的结局，也是官方指定结局，龙之还乡：\n狼和皇子都活了下来，和神子一道前往西方，送还樱龙，断绝不死之诅咒，走向新的征程：\n到此结束。感谢fs社给我带来的这一段珍贵的经历！\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/sekiro-memoir/","tags":["game"],"title":"《只狼》游戏回忆和场景记录"},{"categories":["Web"],"contents":"关于分布式事务 ​分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作。\n这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务。\n例如用户下一个订单，需要首先创建订单，然后删减库存，接着扣除用户的金钱，最后完成订单。这个过程中，每个操作都可以作为一个微服务，每个微服务操作对应的数据库，而各个数据库可能分布在不同机器上，那么分布式事务就产生了，我们要确保一个事务被正确地处理，必须解决好分布式事务的数据提交与回滚。\n关于Seata Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。（来源官网）\nTC (Transaction Coordinator) - 事务协调者：\n维护全局和分支事务的状态，驱动全局事务提交或回滚。\nTM (Transaction Manager) - 事务管理器：\n定义全局事务的范围：开始全局事务、提交或回滚全局事务。\nRM (Resource Manager) - 资源管理器：\n管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。\n开始编码测试 架构说明 开启三个微服务，创建订单服务，删减库存服务，扣除用户金钱服务，均注册到nacos。\n由订单服务作为入口，首先创建订单，然后删减库存，最后扣钱，完成订单，各个服务数据存取操作均处于不同数据库中。\n使用seata作为分布式事务解决方案，也注册到nacos中。\n配置Seata环境 一、下载Seata1.0.0\n二、建seata表，sql链接\n三、修改配置\n(1) registry.conf:\ntype修改为nacos\n1 2 3 4 5 6 7 8 9 10 11 registry { # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = \u0026#34;nacos\u0026#34; nacos { serverAddr = \u0026#34;localhost:8848\u0026#34; namespace = \u0026#34;\u0026#34; cluster = \u0026#34;default\u0026#34; } ... } (2) file.conf:\nmy_test_tx_group修改为自定义group名，store.mode改为db，修改db配置内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 service { #transaction service group mapping vgroup_mapping.jzh = \u0026#34;default\u0026#34; #only support when registry.type=file, please don\u0026#39;t set multiple addresses default.grouplist = \u0026#34;127.0.0.1:8091\u0026#34; #disable seata disableGlobalTransaction = false } ## transaction log store, only used in seata-server store { ## store mode: file、db mode = \u0026#34;db\u0026#34; ## file store property file { ## store location dir dir = \u0026#34;sessionStore\u0026#34; } ## database store property db { ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc. datasource = \u0026#34;dbcp\u0026#34; ## mysql/oracle/h2/oceanbase etc. db-type = \u0026#34;mysql\u0026#34; driver-class-name = \u0026#34;com.mysql.jdbc.Driver\u0026#34; url = \u0026#34;jdbc:mysql://127.0.0.1:3306/seata\u0026#34; user = \u0026#34;root\u0026#34; password = \u0026#34;******\u0026#34; } } 四、启动seata\nbin目录下：\n1 .\\seata-server.bat -p 8091 -h 127.0.0.1 -m db 编写微服务模块 一、创建数据库表： 创建seata_order，seata_account，seata_storage三个数据库，创建对应数据表，以及undo_log表，数据库脚本地址。\n二、微服务配置： 将file.conf和registry.conf复制到微服务对应配置文件目录下。\n在application.yaml指明自定义的服务组。\n1 2 3 4 5 spring: cloud: alibaba: seata: tx-service-group: jzh 导入seata依赖（指定好自己用的seata版本）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-seata\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;seata-all\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;io.seata\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.seata\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;seata-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 三、多数据源配置 seata需要处理多个数据源，因此必须配置多数据源，然而DataSourceAutoConfiguration.class默认会帮我们自动配置单数据源，所以必须排除它。\n启动类添加如下注解即可：\n1 @SpringBootApplication(exclude = DataSourceAutoConfiguration.class) 同时指定多数据源配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Configuration public class DataSourceProxyConfig { @Bean @ConfigurationProperties(prefix = \u0026#34;spring.datasource\u0026#34;) public DataSource druidDataSource() { return new DruidDataSource(); } @Bean public DataSourceProxy dataSourceProxy(DataSource dataSource) { return new DataSourceProxy(dataSource); } @Bean public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception { SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceProxy); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\u0026#34;classpath:mapper/*.xml\u0026#34;)); sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory()); return sqlSessionFactoryBean.getObject(); } } 微服务代码编写 订单服务具体实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Service @Slf4j public class OrderServiceImpl implements OrderService { @Override @GlobalTransactional(name = \u0026#34;jzh-create\u0026#34;, rollbackFor = Exception.class) public void create(Order order) { log.info(\u0026#34;************开始创建订单\u0026#34;); orderDao.create(order); log.info(\u0026#34;************开始扣库存\u0026#34;); storageService.decrease(order.getProductId(), order.getCount()); log.info(\u0026#34;************完成扣库存\u0026#34;); log.info(\u0026#34;************开始扣钱\u0026#34;); accountService.decrease(order.getUserId(), order.getMoney()); log.info(\u0026#34;************扣钱完成\u0026#34;); orderDao.update(order.getUserId(), 0); log.info(\u0026#34;************订单完成\u0026#34;); } @Resource private OrderDao orderDao; @Resource private StorageService storageService; @Resource private AccountService accountService; } rollbackFor指定为任何异常发生都回滚。\n其他两个微服务通过feign调用：\nAccountService.java:\n1 2 3 4 5 6 @FeignClient(value = \u0026#34;seata-account-service\u0026#34;) public interface AccountService { @PostMapping(value = \u0026#34;/account/decrease\u0026#34;) CommonResult decrease(@RequestParam(\u0026#34;userId\u0026#34;) Long userId, @RequestParam(\u0026#34;money\u0026#34;) BigDecimal money); } StorageService.java\n1 2 3 4 5 6 @FeignClient(value = \u0026#34;seata-storage-service\u0026#34;) public interface StorageService { @PostMapping(value = \u0026#34;/storage/decrease\u0026#34;) CommonResult decrease(@RequestParam(\u0026#34;productId\u0026#34;) Long productId, @RequestParam(\u0026#34;count\u0026#34;) Integer count); } 其他两个微服务具体代码省略了。\nOrderController:\n通过/order/create请求服务：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @RestController @Slf4j public class OrderController { @Resource private OrderService orderService; @PostMapping(\u0026#34;/order/create\u0026#34;) public CommonResult create(@RequestBody Order order) { log.info(order.toString()); orderService.create(order); return new CommonResult(200, \u0026#34;订单创建成功\u0026#34;); } } 测试 一、访问localhost:8848/nacos，发现三个微服务和seata服务都已经注册成功；\n二、发送localhost:2001/order/create请求（POST，请求体为订单信息），返回200，查看数据库表，数据变更正确；\n三、手动给Account服务添加除0异常，重复如上请求，返回500，后台报异常，查看库存数据库表，发现存量没有变化，证明回滚成功。\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/using-seata-to-process-distributed-transactions/","tags":["springcloud","microservice"],"title":"使用 Seata 处理分布式事务"},{"categories":["Web"],"contents":"Sentinel是什么 Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件，主要以流量为切入点，从流量路由、流量控制、流量整形、熔断降级、系统自适应过载保护、热点流量防护等多个维度来帮助开发者保障微服务的稳定性。（来源于官方文档）\n个人使用感觉：类似于Hystrix，使用上感觉比Hystrix更容易，功能也更强大。\n架构说明 两个生产者服务运行在9001和9002端口，一个消费者服务运行在80端口，均注册到nacos，消费者调用两个生产者的服务。\n将消费者服务注册到sentinel中，通过修改一些规则进行测试。\ncontroller下的方法指定好处理服务限流，降级或熔断等的方法blockHandler，以及处理未知异常的fallback方法，通过指定class的方法避免代码膨胀。\nservice下的方法指定好关于生产者的服务限流，降级或熔断等的处理方法。\n代码编写记录 生产者端 一、配置\n关于nacos的配置省略，只记录sentinel的配置：\n1 2 3 4 5 6 7 8 spring: application: name: nacos-payment-provider cloud: sentinel: transport: dashboard: localhost:8080 port: 8179 二、controller编写\n1 2 3 4 5 6 7 8 9 10 11 @RestController @Slf4j public class PaymentController { @Value(\u0026#34;${server.port}\u0026#34;) private String port; @GetMapping(\u0026#34;/payment/nacos/info\u0026#34;) public String paymentInfo() { return \u0026#34;port: \u0026#34; + port; } } 返回对应端口，方便测试负载均衡。\n消费者端 一、配置\n1 2 3 4 5 6 7 8 9 10 spring: application: name: nacos-order-consumer sentinel: transport: dashboard: localhost:8080 port: 8179 feign: sentinel: enabled: true 注意要开启feign的sentinel支持。\n二、依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-sentinel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; ... 三、service编写\n1 2 3 4 5 6 @FeignClient(value = \u0026#34;nacos-payment-provider\u0026#34;, fallback = PaymentFallbackService.class) @Service public interface PaymentService { @GetMapping(\u0026#34;/payment/nacos/info\u0026#34;) String paymentInfo(); } 对应实现类：\n1 2 3 4 5 6 7 @Service public class PaymentFallbackService implements PaymentService{ @Override public String paymentInfo() { return \u0026#34;feign::fallback\u0026#34;; } } 这里处理关于生产者的服务限流，降级或熔断问题。\n四、两个服务问题Hanlder的编写\n根据官方文档，这里的方法都需指明为static，否者无法识别。\n1、GlobalBlockHandler\n1 2 3 4 5 @Component public class GlobalBlockHandler { public static String block1(BlockException e) {return \u0026#34;block1\u0026#34;;} public String block2(BlockException e) {return \u0026#34;block2\u0026#34;;} } 这个用于消费者端处理服务限流，降级或熔断等问题。\nGlobalFallbackHandler 1 2 3 4 5 @Component public class GlobalFallbackHandler { public static String fallback1() {return \u0026#34;fallback1\u0026#34;;} public static String fallback2() {return \u0026#34;fallback2\u0026#34;;} } 这个用于消费者端处理未知异常。\n五、controller编写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @RestController @Slf4j public class OrderController { @Resource PaymentService paymentService; @GetMapping(\u0026#34;/consumer/payment/nacos/info\u0026#34;) @SentinelResource( value = \u0026#34;paymentInfo\u0026#34;, fallbackClass = GlobalFallbackHandler.class, fallback = \u0026#34;fallback1\u0026#34;, blockHandlerClass = GlobalBlockHandler.class, blockHandler = \u0026#34;block1\u0026#34; ) public String paymentInfo() { int a = 1 / 0; return paymentService.paymentInfo(); } } 指定好class的同时，需用fallback和blockHandler分别指定好具体的方法名。\n测试 一、测试除0错误是否正确进入fallback1：直接访问接口，返回“fallback1”，正确；\n二、测试消费者端服务限流：sentinel指定流控规则，QPS设置阈值为1，连续访问接口，返回“block1”，正确；\n三、测试生产者端除0错误是否正确进入fallback：给生产者controller添加除0错误，访问接口，返回“feign::fallback”，正确；\n四、测试其他服务规则：\n指定熔断规则，熔断策略选为慢调用比例，最大RT（Round Trip Time，也叫响应时间）设置为200ms，比例阈值设置为0.5，最小请求数设置为5。\n为模拟慢调用，手动增大发出接口请求到收到结果的延迟，在controller中添加Thread.sleep(1000)，延迟1秒。\n连续访问接口，首先返回了“9001”，即访问正常时得到的结果，然而发现在5次以上的请求以后，返回了“block1”，成功熔断。\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/sentinel-usage-record/","tags":["springcloud","microservice"],"title":"Sentinel 使用记录"},{"categories":["Web"],"contents":"前言 总体架构说明 在一台CentOS主机上部署，版本为7.9，IP为192.168.1.127。\n通过docker创建三台nacos环境的机器，端口均运行在8848，分别映射到主机的8848，8858，8868端口上，名称（hostname）分别为nacos-server1，nacos-server2，nacos-server3。\n主机通过nginx监听8080端口，通过负载均衡将请求转发到三台nacos机器上。\n主机作为数据库源，使用mysql作为数据库，端口为3306，三台机器都安装mysql环境，端口运行在3306，映射到主机3307端口。\n服务说明 创建一个简单的服务，注册到上述nacos环境中，通过在bootstrap.yaml中读取nacos配置来验证环境是否配置成功。\n搭建nacos环境 编辑docker-compose的yaml文件 在nacos官网下载nacos-docker到主机上，编辑example/cluster-hostname.yaml文件。\n根据官网说明，在nacos2中需要额外暴露两个端口，分别偏移8848这个端口1000和1001。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 version: \u0026#34;3\u0026#34; services: nacos1: hostname: nacos-server-1 container_name: nacos1 image: nacos/nacos-server:${NACOS_VERSION} volumes: - ./cluster-logs/nacos1:/home/nacos/logs - ./init.d/custom.properties:/home/nacos/init.d/custom.properties ports: - \u0026#34;8848:8848\u0026#34; - \u0026#34;9848:9848\u0026#34; # 偏移1000 - \u0026#34;9849:9849\u0026#34; # 偏移1001 - \u0026#34;9555:9555\u0026#34; env_file: - ../env/nacos-hostname.env restart: always depends_on: - mysql nacos2: hostname: nacos-server-2 image: nacos/nacos-server:${NACOS_VERSION} container_name: nacos2 volumes: - ./cluster-logs/nacos2:/home/nacos/logs - ./init.d/custom.properties:/home/nacos/init.d/custom.properties ports: - \u0026#34;8858:8848\u0026#34; - \u0026#34;9858:9848\u0026#34; - \u0026#34;9859:9849\u0026#34; env_file: - ../env/nacos-hostname.env restart: always depends_on: - mysql nacos3: hostname: nacos-server-3 image: nacos/nacos-server:${NACOS_VERSION} container_name: nacos3 volumes: - ./cluster-logs/nacos3:/home/nacos/logs - ./init.d/custom.properties:/home/nacos/init.d/custom.properties ports: - \u0026#34;8868:8848\u0026#34; - \u0026#34;9868:9848\u0026#34; - \u0026#34;9869:9849\u0026#34; env_file: - ../env/nacos-hostname.env restart: always depends_on: - mysql mysql: container_name: mysql image: nacos/nacos-mysql:5.7 env_file: - ../env/mysql.env volumes: - ./mysql:/var/lib/mysql ports: - \u0026#34;3307:3306\u0026#34; 配置数据库信息 通过官网提供的sql脚本在主机建好数据库。\n接着指定mysql数据库源信息，编辑env/nacos-hostname.env文件如下：\n1 2 3 4 5 6 7 PREFER_HOST_MODE=hostname # hostname模式 NACOS_SERVERS=nacos-server-1 nacos-server-2 nacos-server-3 MYSQL_SERVICE_HOST=192.168.1.127 MYSQL_SERVICE_DB_NAME=nacos_config MYSQL_SERVICE_PORT=3306 MYSQL_SERVICE_USER=**** MYSQL_SERVICE_PASSWORD=****** 注意填写好主机的mysql账号密码。\n最后指定docker中mysql信息，编辑env/mysql.env文件即可：\n1 2 3 4 MYSQL_ROOT_PASSWORD=****** MYSQL_DATABASE=nacos_config MYSQL_USER=**** MYSQL_PASSWORD=****** 运行docker 执行如下命令即可：\n1 docker-compose -f example/cluster-hostname.yaml up 等到出现如下信息即成功部署环境：\n1 2 3 4 5 6 7 8 9 nacos2 | 2022-08-07 07:05:41,147 INFO Nacos started successfully in cluster mode. use external storage nacos2 | nacos1 | 2022-08-07 07:05:41,194 INFO Nacos is starting... nacos1 | nacos1 | 2022-08-07 07:05:41,240 INFO Nacos started successfully in cluster mode. use external storage nacos1 | nacos3 | 2022-08-07 07:05:42,097 INFO Nacos is starting... nacos3 | nacos3 | 2022-08-07 07:05:42,135 INFO Nacos started successfully in cluster mode. use external storage 搭建nginx环境 首先安装nginx，接着编辑/etc/nginx/nginx.conf文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ... http { ... upstream nacos-servers { server 192.168.1.127:8848; server 192.168.1.127:8858; server 192.168.1.127:8868; } server { location / { proxy_pass http://nacos-servers; } listen 8080; } } 监听8080端口，通过upstream转发到三台机器上。\n接着运行nginx即可：\n1 nginx -c /etc/nginx/nginx.conf 创建微服务 一、关于依赖导入：\n除了其他一些基本的依赖，还需要导入：\n1 2 3 4 5 6 7 8 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 二、配置文件编写：\n编辑bootstarp.yaml如下：\nnacos的地址即nginx配置好的地址192.168.1.127:8080。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 spring: cloud: nacos: discovery: server-addr: 192.168.1.127:8080 config: server-addr: 192.168.1.127:8080 file-extension: yaml profiles: active: prod application: name: nacos-config-client server: port: 9669 三、启动类记得还要开启@EnableDiscoveryClient注解。\n四、编写具体服务：\n1 2 3 4 5 6 7 8 9 10 11 12 @RefreshScope @RestController @Slf4j public class ConfigController { @Value(\u0026#34;${config.version}\u0026#34;) private String version; @GetMapping(\u0026#34;/v\u0026#34;) public String getVersion() { return version; } } 注意开启@RefreshScope注解。\n测试 一、访问192.168.1.127:8080，成功访问并登录；\n二、查看集群管理的节点列表，三个前缀名为nacos-server的节点都处在UP状态；\n三、编写nacos-config-client-prod.yaml文件，为微服务名+环境的格式：\n1 2 config: version: 1.0 四、开启微服务，再查看服务列表，名为nacos-config-client的服务已经成功注册，访问接口/v，返回1.0；\n五、修改配置，version改为2.0，再次访问/v接口，返回2.0。\n测试完毕。\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/docker-compose-quickly-configures-nacos-cluster-environment/","tags":["docker","microservice","springcloud"],"title":"Docker-compose 快速配置 nacos 集群环境"},{"categories":["Language"],"contents":"读取输入 1 2 set /p ch=\u0026#34;y/n:\u0026#34; echo %ch% 变量运算 通过%{var}%访问变量，通过/a进行表达式计算设置值。\n1 2 3 4 5 6 7 8 @echo off set money=100 echo 初始金额： %money% set /a money=%money%*2 set /a money=%money%+100 echo 现在的金额：%money% 选择并跳转 :{point} 用于指定一个跳转点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @echo off set /p ch=\u0026#34;y/n:\u0026#34; if \u0026#34;%ch%\u0026#34;==\u0026#34;\u0026#34; ( goto end ) else if \u0026#34;%ch%\u0026#34;==\u0026#34;n\u0026#34; ( goto no ) else if \u0026#34;%ch%\u0026#34;==\u0026#34;y\u0026#34; ( goto yes ) else ( goto end ) :no echo NO goto end :yes echo YES goto end :end 循环语句 通过%%x设置和访问循环值； 通过(start, steps, end)设置循环； /l 将通过比较start和end来执行迭代。 1 2 3 4 5 @echo off for /l %%x in (1, 5, 100) do ( echo hello, jzh-%%x ) 变量动态变化 setlocal enabledelayedexpansion开启变量延迟，使得变量可以动态变化; 需通过!{var}!访问变化中的量。 1 2 3 4 5 6 7 8 9 10 11 @echo off @REM 开启变量延迟，使得变量可以动态变化 setlocal enabledelayedexpansion set /a i=1 for /l %%i in (1, 1, 10) do ( echo hello set /a i+=1 echo !i! ) echo %i% 接收参数 1 2 3 4 5 @echo off rem %1 即 args[0] if \u0026#34;%1\u0026#34; == \u0026#34;a\u0026#34; echo open a.txt if \u0026#34;%2\u0026#34; == \u0026#34;b\u0026#34; echo open b.txt 参考文档：windows-commands\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/08/batch-basic-compilation-method-record/","tags":["batch","windows"],"title":"Batch 基本编写方法记录"},{"categories":["Web"],"contents":"Zipkin的作用 查看微服务调用过程； 分析微服务依赖关系； 方便地找到调用过程错误发生位置。 Zipkin使用记录 一、下载Zipkin并运行：\n1 java -jar zipkin.jar 这样成功运行后，默认在端口9411可以查看图形管理界面。\n二、依赖引入\n在所有调用到的微服务中引入：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-zipkin\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 三、配置文件\n1 2 3 4 5 6 spring: zipkin: base-url: http://localhost:9411 sleuth: sampler: probability: 1 # 采样率介于0和1之间，1表示全部采集 测试 通过service-name标签搜索自己的微服务名称，即可检索到与该微服务有依赖的所有微服务，可查看调用过程，依赖关系等。\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/07/zipkin-usage-record/","tags":["springcloud","microservice"],"title":"Zipkin 使用记录"},{"categories":["Web"],"contents":"为何使用Stream？ 实现消息的收发可以用许多种方式来实现，如Kafka，RabbitMQ等，而通过Stream可以方便地通过一个Binder对象与这些不同的实现工具对接，应用程序通过Inputs和Outputs来与Binder交互即可实现消息的收发，这样我们就只需要知道如何与Stream交互即可方便地使用消息驱动。\n下图即Stream工作原理：\nStream使用记录 一、依赖导入 除去一些基本依赖之外，发布端和订阅端均导入：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-stream-rabbit\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 二、基本配置 发布端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 spring: cloud: stream: binders: defaultRabbit: type: rabbit environment: spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: output: destination: myExchange content-type: application/json binder: defaultRabbit 订阅端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 spring: cloud: stream: binders: defaultRabbit: type: rabbit environment: spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: input: destination: myExchange content-type: application/json binder: defaultRabbit group: jzh1 注意，两个订阅端如果实现同一微服务，group应该一样，这样，在同一个组内会发生竞争关系，只有其中一个可以消费（默认采用轮询的机制处理），避免了出现重复消费的问题。\n三、发送端代码编写 （1）编写IMessageProvider接口并实现：\nIMessageProvider.java:\n1 2 3 public interface IMessageProvider { String send(); } MessageProviderImpl.java\n1 2 3 4 5 6 7 8 9 10 11 12 @EnableBinding(Source.class) public class MessageProviderImpl implements IMessageProvider { @Resource private MessageChannel output; @Override public String send() { String s = IdUtil.simpleUUID(); output.send(MessageBuilder.withPayload(s).build()); return s; } } Source代表为消息来源方； MessageChannel是应用与Binder之间建立的通道，通过它收发消息； send()方法处理参数为Message类型。 （2）编写controller，用于发送消息：\n1 2 3 4 5 6 7 8 9 10 @RestController public class SendController { @Resource private IMessageProvider messageProvider; @GetMapping(\u0026#34;/msg\u0026#34;) public String sendMsg() { return messageProvider.send(); } } 四、订阅端代码编写 编写controller，用于接收并打印消息：\n1 2 3 4 5 6 7 8 9 10 11 @Component @EnableBinding(Sink.class) public class GetController { @Value(\u0026#34;${server.port}\u0026#34;) private String port; @StreamListener(Sink.INPUT) public void input(Message\u0026lt;String\u0026gt; msg) { System.out.println(\u0026#34;consumer(port=\u0026#34; + port + \u0026#34;), receive msg:\u0026#34; + msg.getPayload()); } } Sink表示是消息接收方； 通过@StreamListener实现消息的监听。 测试 开启RabbitMQ服务，打开图形管理界面（默认15672端口）； 开启各微服务，发送端通过/msg接口发送消息； 订阅端在控制台成功监听到消息，由于在同一组中，可见消息交替出现。 From My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/07/springcloud-stream-usage-record/","tags":["springcloud","microservice"],"title":"SpringCloud-Stream 使用记录"},{"categories":["Web"],"contents":"为何要使用Config和Bus Config可以进行多个微服务下的全局配置，更加方便，易于管理。\n当全局配置修改时，需要通知各个微服务，一个一个地通知是非常耗时的，如果可以通过广播的方式快速将消息传递出去就轻松多了，而通过Bus即可实现这一点。\n测试方法 一、在6996端口通过git拉取全局配置，相当于一个ConfigServer，6886和6776端口作为ConfigClient；\n二、Bus结合RabbitMQ实现，修改配置时，只通知ConfigServer，达到消息广播的效果。\n依赖引入 一、ConfigServer端：\n1 2 3 4 5 6 7 8 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-bus-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-config-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 二、ConfigClient端：\n1 2 3 4 5 6 7 8 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-bus-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 其他一些基本包就省略了。\n文件配置 一、ConfigServer端：\n以下为application.yml:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 spring: cloud: config: server: git: # github项目地址 uri: https://github.com/akynazh/SpringCloud-Demo.git # 指定搜索项目下config文件夹中的内容 search-paths: - config # 指定分支 default-label: master rabbitmq: host: localhost port: 5672 username: guest password: guest management: endpoints: web: exposure: # 通过/actuator/bus-refresh可进行事件通知 include: \u0026#34;bus-refresh\u0026#34; 以后，运维人员修改config时，即可通过如下地址：\n1 http://localhost:6996/actuator/bus-refresh 即可发送POST请求进行消息通知。\n二、ConfigClient端：\n以下为bootstrap.yml:（可以加载全局配置）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 spring: application: name: cloud-config-client cloud: config: label: master # 分支 name: config # 文件名 profile: dev # 环境 uri: http://localhost:6996 # 全局配置加载地址 rabbitmq: host: localhost port: 5672 username: guest password: guest 值得注意的地方：\n第一，config文件名编写需要遵循一定规则，我选择的是{name}-{profile}.yml的格式，然后如上配置文件应该填写对应内容。\n第二，application-name可以用于后续选择性通知，如只想通知6776，可通过POST请求访问如下地址：http://localhost:6996/actuator/bus-refresh/cloud-config-client:6776\n编写Java类 一、ConfigServer需要注意添加@EnableConfigServer注解。\n二、ConfigClient端的Controller编写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @RestController @Slf4j public class MyController { @Resource private Environment env; @Value(\u0026#34;${server.port}\u0026#34;) String port; @GetMapping(\u0026#34;/v\u0026#34;) public String getVersion() { return \u0026#34;port: \u0026#34; + port + \u0026#34;\\t \u0026#34; + env.getProperty(\u0026#34;config.version\u0026#34;); } } 测试 启动RabbitMQ 进入到sbin文件目录下：\n1 .\\rabbitmq-service.bat start 默认启动在5672端口。（图形界面在15672端口）\n加载配置测试 访问：http://localhost:6996/master/config-dev.yml\n会从github加载得到：\n1 2 3 4 config: label: master profile: dev version: 3.0 访问：http://localhost:6776/v\n得到：\n1 port: 6776 3.0 6886得到相同结果，证明成功加载全局配置。\n修改配置测试 修改配置version为3.6，提交，发送请求如下：\n1 curl -X POST \u0026#34;http://localhost:6996/actuator/bus-refresh\u0026#34; 发现三个端口version均改为3.6，测试通过。\n修改配置version为3.9，提交，发送请求如下：\n1 curl -X POST \u0026#34;http://localhost:6996/actuator/bus-refresh/cloud-config-client:6776\u0026#34; 发现6996和6776的version为3.9，而6886的version仍为3.6，测试通过。\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/07/config-combined-with-bus-usage-record/","tags":["springcloud","microservice"],"title":"Config 结合 Bus 使用记录"},{"categories":["Web"],"contents":"网关的作用 如图所示，网关介于外部请求和具体微服务之间，在不暴露内部微服务端口的情况下，通过一个或者多个指定的网关端口统一地处理外部各种请求。\n使用SpringCloud Gateway 依赖引入 除了基本依赖以外，引入下列依赖：\n1 2 3 4 5 6 7 8 9 \u0026lt;!-- others --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 注意不能引入web相关依赖，因为Gateway是基于WebFlux的。\n文件配置 列出部分重要配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 server: port: 9669 cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由 routes: - id: path_route uri: lb://CLOUD-PAYMENT-SERVICE # lb：负载均衡 predicates: - Path=/payment/** - After=2022-07-26T17:33:52.449+08:00[Asia/Shanghai] # ZonedDateTime.now() - Cookie=username,jzh 注意点如下：\n9669端口作为网关端口； uri中http改为了lb，用于负载均衡； predicates，即断言，上述断言是： 匹配路径：/payment/**； 开始允许访问时间：ZonedDateTime.now()（Java函数获取该格式时间） 携带cookie：key=username, value=jzh 过滤器配置 实现GlobalFilter, Ordered，重写方法即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Component @Slf4j public class MyGlobalFilter implements GlobalFilter, Ordered { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { String username = exchange.getRequest().getQueryParams().getFirst(\u0026#34;username\u0026#34;); if (username == null) { log.info(\u0026#34;username lost\u0026#34;); exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE); return exchange.getResponse().setComplete(); } return chain.filter(exchange); } @Override public int getOrder() { return 0; } } 定义了url中携带必须携带一个key为username的参数。\n测试 注意先开启指定的微服务，访问http://localhost:9669/payment/get/11?username=aaa（同时配好cookie），成功返回结果：\n1 2 3 4 5 6 7 8 { \u0026#34;code\u0026#34;: 200, \u0026#34;data\u0026#34;: { \u0026#34;serial\u0026#34;: \u0026#34;8asd8sa2j\u0026#34;, \u0026#34;id\u0026#34;: 11 }, \u0026#34;message\u0026#34;: \u0026#34;查询成功，访问端口：8001\u0026#34; } 再刷新，发现端口动态变化为8002，负载均衡功能也测试成功。\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/07/springcloud-gateway-usage-record/","tags":["springcloud","microservice"],"title":"SpringCloud-Gateway 使用记录"},{"categories":["Web"],"contents":"什么是服务熔断 概念 应对微服务雪崩效应的一种链路保护机制，类似保险丝。\n关于雪崩效应 微服务之间的数据交互是通过远程调用来完成的。服务A调用服务，服务B调用服务C，某一时间链路上对服务C的调用响应时间过长或者服务C不可用，随着时间的增长，对服务C的调用也越来越多，然后服务C崩溃了，但是链路调用还在，对服务B的调用也在持续增多，然后服务B崩溃，随之A也崩溃，导致雪崩效应。\n实现机制 当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。\n通过Hystrix实现服务熔断，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，就会启动熔断机制，断路器打开。而在一段时间之后，断路器会变为半开状态，此时允许部分微服务调用，如果都成功了，即不超过设定好的阈值，那么断路器将恢复为关闭状态。\n如下图所示：（来自Martin Fowler大神的博客）\n应用场景 微服务架构中，多个微服务相互调用出使用\nHystrix实现服务熔断 环境搭建 1. 关于pom.xml 1 2 3 4 5 6 7 8 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 2. 启动类添加@EnableHystrix注解，表示使用熔断器。 实现服务熔断 1. PaymentService.java 1 2 3 4 public interface PaymentService { ... String circuitBreaker(Integer id); } 2. PaymentServiceImpl.java 设置服务熔断的核心配置：\n（1）启用断路器:\n1 @HystrixProperty(name = \u0026#34;circuitBreaker.enabled\u0026#34;, value = \u0026#34;true\u0026#34;) （2）设置请求次数:\n1 @HystrixProperty(name = \u0026#34;circuitBreaker.requestVolumeThreshold\u0026#34;, value = \u0026#34;10\u0026#34;) （3）设置时间窗口期:\n1 @HystrixProperty(name = \u0026#34;circuitBreaker.sleepWindowInMilliseconds\u0026#34;, value = \u0026#34;10000\u0026#34;) （4）设置失败率:\n1 @HystrixProperty(name = \u0026#34;circuitBreaker.errorThresholdPercentage\u0026#34;, value = \u0026#34;60\u0026#34;) 如上设置的值，如果在10秒内，失败率达到请求次数（10）的百分之60，也就是6次，就会打开断路器，否则断路器依然关闭。\n断路器打开后，在一定时间之后，断路器变为半开状态，允许部分请求访问，如果这些请求满足要求，不超阈值，则断路器恢复为关闭状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Service public class PaymentServiceImpl implements PaymentService { ... @Override @HystrixCommand(fallbackMethod = \u0026#34;circuitBreaker_fallback\u0026#34;, commandProperties = { @HystrixProperty(name = \u0026#34;circuitBreaker.enabled\u0026#34;, value = \u0026#34;true\u0026#34;), @HystrixProperty(name = \u0026#34;circuitBreaker.requestVolumeThreshold\u0026#34;, value = \u0026#34;10\u0026#34;), @HystrixProperty(name = \u0026#34;circuitBreaker.sleepWindowInMilliseconds\u0026#34;, value = \u0026#34;10000\u0026#34;), @HystrixProperty(name = \u0026#34;circuitBreaker.errorThresholdPercentage\u0026#34;, value = \u0026#34;60\u0026#34;) }) public String circuitBreaker(Integer id) { if (id \u0026lt; 0) throw new RuntimeException(\u0026#34;id 不能小于0\u0026#34;); String uuid = IdUtil.simpleUUID(); return Thread.currentThread().getName() + \u0026#34;\\t\u0026#34; + \u0026#34;uuid:\u0026#34; + uuid; } public String circuitBreaker_fallback(@PathVariable(\u0026#34;id\u0026#34;) Integer id) { return \u0026#34;id 不能小于0, 请重试~ id: \u0026#34; + id; } } 3. PaymentController.java 1 2 3 4 5 6 7 8 9 10 11 @RestController @Slf4j public class PaymentController { @Resource private PaymentService paymentService; @GetMapping(\u0026#34;/payment/cir/{id}\u0026#34;) public String paymentCircuitBreaker(@PathVariable(\u0026#34;id\u0026#34;) Integer id) { return paymentService.circuitBreaker(id); } ... Hystrix实现服务监控 一、在另一个module或者project中进行：\n（1）关于pom.xml\n除了一些基本依赖外：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix-dashboard\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; （2）启动类开启@EnableHystrixDashboard注解。\n二、在要监控的服务的配置文件中添加：\n1 2 3 4 5 6 # hystrix 9001监控配置 management: endpoints: web: exposure: include: hystrix.stream, info, health 测试 （一）打开：http://{ip}:{port}/hystrix；\n（二）监控：http://{ip}:{port}/actuator/hystrix.stream；\n（三）访问http://localhost:8001/payment/cir/1，可以正常访问；\n（四）多次访问http://localhost:8001/payment/cir/-1, 返回系统繁忙信息，发现断路器开启了：\n此时，再访问http://localhost:8001/payment/cir/1，发现返回了系统繁忙信息。\n（五）多次访问http://localhost:8001/payment/cir/1，发现断路器关闭，恢复正常访问。\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/07/hytrix-realizes-service-fusing-and-monitoring/","tags":["hystrix","microservice","springcloud"],"title":"Hystrix 实现服务熔断与监控"},{"categories":["Web"],"contents":"什么是服务降级 概念 一般指在服务器压力剧增的时候，根据实际业务使用情况以及流量，对一些服务和页面有策略的不处理或者用一种简单的方式进行处理，从而释放服务器资源的资源以保证核心业务的正常高效运行。\n应用场景 多用于微服务架构中，一般当整个微服务架构整体的负载超出了预设的上限阈值（和服务器的配置性能有关系），或者即将到来的流量预计会超过预设的阈值时。\n大致实现过程 为了预防某些功能出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。\n使用Hystrix实现服务降级 本实验配合了Feign实现，利用Feign通过接口的方式解耦服务这一特点，通过在实现服务接口的类来编写方法对应的fallback方法。\n环境搭建 一、关于pom\n在消费方实现服务降级，除了基本包导入外，导入以下：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 二、关于application.yml\n除了基本配置外，以下两个超时时间的配置需要格外注意：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 设置feign超时时间（默认为1秒） feign: hystrix: enabled: true client: config: default: ConnectTimeOut: 5000 ReadTimeOut: 5000 # 设置hystrix超时时间（默认为1秒） hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000 其他关于Feign的环境配置省略了。\n实现服务降级 一、PaymentService.java\n在使用了Feign的基础上使用Hystrix功能，指定fallback对应的实现类。\n1 2 3 4 5 6 7 @Service @FeignClient(value = \u0026#34;CLOUD-HYSTRIX-PAYMENT-SERVICE\u0026#34;, fallback = PaymentHystrixService.class) public interface PaymentService { ... @GetMapping(\u0026#34;/payment/tt\u0026#34;) CommonResult\u0026lt;Object\u0026gt; timeoutTest(); } 二、PaymentServiceImpl.java\n1 2 3 4 5 6 7 8 @Service public class PaymentHystrixService implements PaymentService{ ... @Override public CommonResult\u0026lt;Object\u0026gt; timeoutTest() { return new CommonResult\u0026lt;\u0026gt;(500, \u0026#34;error\u0026#34;); } } 三、 PaymentController.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @RestController @Slf4j public class PaymentController { @Resource private PaymentService paymentService; ... /** * @description: 访问一个耗时超过3秒的服务 * @author Jiang Zhihang * @date 2022/7/26 11:16 */ @GetMapping(\u0026#34;/consumer/payment/tt\u0026#34;) public CommonResult\u0026lt;Object\u0026gt; timeoutTest() { return paymentService.timeoutTest(); } } 测试 一、访问http://localhost:8001/payment/tt，由于hystrix配置最小超时时间为2秒，而访问时间超3秒，所以得到如下结果：\n1 2 3 4 5 { \u0026#34;code\u0026#34;: 500, \u0026#34;message\u0026#34;: \u0026#34;error\u0026#34;, \u0026#34;data\u0026#34;: null } 可以发现调用了fallback方法。\n二、修改hystrix超时时间为4秒，再次访问得到：\n1 2 3 4 5 { \u0026#34;code\u0026#34;: 200, \u0026#34;message\u0026#34;: \u0026#34;timeout test\u0026#34;, \u0026#34;data\u0026#34;: null } 得到成功返回的数据。\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/07/hytrix-enables-service-degradation/","tags":["hystrix","springcloud","microservice"],"title":"Hystrix 实现服务降级"},{"categories":["OS"],"contents":"systemctl指令 立即启动一个服务：systemctl start my.service 立即停止一个服务：systemctl stop my.service 重启一个服务：systemctl restart my.service 重新加载一个服务的配置文件：systemctl reload my.service 重载所有修改过的配置文件：systemctl daemon-reload 开启自启动服务：systemctl enable my.service 取消开启自启动：systemctl disable my.service 查看是否已经自启动：systemctl is-enabled my.service 查看服务运行状态：systemctl status my.service 查看所有服务：systemctl --type service service和chkconfig指令 启动服务：service my.service start 终止服务：service my.service stop 重启服务：service my.service restart 查看服务运行状态：service my.service status 开启或取消开机自启动：chkconfig my.service on/off 查看开机自启动列表：chkconfig --list Unit配置文件解释 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 - Unit - Description，服务的描述 - Requires，定义此unit需在哪个daemon启动后才能够启动 - Service - Type，定义启动时的进程行为。它有以下几种值。 - Type=simple，默认值，执行ExecStart指定的命令，启动主进程 - Type=forking，以 fork 方式从父进程创建子进程，创建后父进程会立即退出 - Type=oneshot，一次性进程，Systemd 会等当前服务退出，再继续往下执行 - Type=dbus，当前服务通过D-Bus启动 - Type=notify，当前服务启动完毕，会通知Systemd，再继续往下执行 - Type=idle，若有其他任务执行完毕，当前服务才会运行 - ExecStart，启动当前服务的命令 - ExecStartPre，启动当前服务之前执行的命令 - ExecStartPost，启动当前服务之后执行的命令 - ExecReload，重启当前服务时执行的命令 - ExecStop，停止当前服务时执行的命令 - ExecStopPost，停止当其服务之后执行的命令 - RestartSec，自动重启当前服务间隔的秒数 - Restart，定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog - TimeoutSec，定义 Systemd 停止当前服务之前等待的秒数 - Environment，指定环境变量 - Install - WantedBy，值是一个或多个Target，当前Unit激活(enable)时，符号链接会放入/etc/systemd/system目录下面以Target名+.wants后缀构成的子目录中 - RequiredBy，它的值是一个或多个Target，当前Unit激活(enable)时，符号链接会放入/etc/systemd/system目录下面以Target名+.required后缀构成的子目录中 - Alias，当前Unit可用于启动的别名 - Also，当前Unit激活(enable)时，会被同时激活的其他Unit 自定义服务启动 服务的管理通过systemd进行，systemd大部分配置文件位于/usr/lib/systemd/system/内，一般不在这进行修改。\n修改的位置位于/etc/systemd/system内，在这里可以加入自己的服务。\n新建service文件 1 2 3 4 5 6 7 8 9 10 11 12 vim /etc/systemd/system/test.service # test.service [Unit] Description=service test [Service] Type=simple ExecStart=/bin/bash -c \u0026#34; ~/test-service.sh\u0026#34; [Install] WantedBy=multi-user.target 开启服务并观察 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [root@VM-0-11-centos ~]# systemctl daemon-reload [root@VM-0-11-centos ~]# systemctl start test.service [root@VM-0-11-centos ~]# systemctl status test.service ● test.service - service test Loaded: loaded (/etc/systemd/system/test.service; disabled; vendor preset: disabled) Active: active (running) since Wed 2022-04-13 00:04:24 CST; 4s ago Main PID: 15428 (bash) CGroup: /system.slice/test.service ├─15428 /bin/bash -c ~/test-service.sh | at now; ├─15429 /bin/bash -c ~/test-service.sh | at now; ├─15430 at now └─15432 sleep 30s Apr 13 00:04:24 VM-0-11-centos systemd[1]: Started service test. 查看Unit启动日志 Systemd统一管理了所有Unit的启动日志，因此只需要使用journalctl命令就可以查看到服务的日志。\n显示尾部指定行数的日志：journalctl -n 20 查看指定服务的日志：journalctl /usr/lib/systemd/systemd 查看指定进程的日志：journalctl _PID=1 查看某个 Unit 的日志：journalctl -u nginx.service ","permalink":"/posts/2022/07/system-service-management-of-linux-practical-operation/","tags":["linux"],"title":"Linux 实用操作之系统服务管理"},{"categories":["OS"],"contents":"wsl在window开机后自启ssh服务 wsl下创建脚本，执行：vim /etc/init.wsl，并根据需要写入服务：\n1 /etc/init.d/${需要的服务} # 或者使用service/systemctl命令 再赋予init.wsl执行权限，执行：chmod +x /etc/init.wsl\nwindow下在启动目录下创建脚本：wsl.bat，写入开机命令如下：\n1 wsl -d \u0026lt;DistributionName\u0026gt; -u root /etc/init.wsl 其中，版本通过wsl -l查看。\nwsl一些常用命令 wsl ~ -u jzh: 以jzh用户登录并进入用户文件夹 wsl --shutdown: 关闭wsl wsl -l -v: 查看已安装的wsl版本 wsl --status: 检查wsl状态 wsl -l --online: 查看可通过在线商店获得的 Linux 发行版列表 wsl修改默认登录用户 \u0026lt;DistributionName\u0026gt; config --default-user root: 将登录默认用户设为root\n手动安装wsl的话可能无法生效，可通过修改/etc/wsl.conf完成：\n1 2 3 # Set the user when launching a distribution with WSL. [user] default = root 然后重启wsl即可完成。\n切换wsl1和wsl2 1 wsl --set-version \u0026lt;distribution name\u0026gt; \u0026lt;versionNumber\u0026gt; \u0026lt;versionNumber\u0026gt;值为1或2，对应wsl1和wsl2。\n升级ubuntu发行版本 1 2 3 apt update apt upgrade do-release-upgrade -d 升级wsl的linux内核版本 1 wsl --update 可以使用wsl --update rollback 命令回滚到内核的上一版本。\n卸载wsl 1 wsl --unregister \u0026lt;DistributionName\u0026gt; From My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/07/wsl-main-operation-records/","tags":["wsl","linux","windows"],"title":"Wsl 主要操作记录"},{"categories":["Tool"],"contents":"自定义wsl安装位置 下载wsl-ubuntu： 20.04版本：https://aka.ms/wslubuntu2004 18.04版本：https://aka.ms/wsl-ubuntu-1804 其他版本自行前往官网查找。\n修改后缀名 下载后得到AppxBundle文件，将后缀名改为zip，然后解压。\n解压后得到如下内容：\n选择x64或ARM64的安装包均可均可，将后缀名改为zip，然后解压。\n开始安装wsl-ubuntu 解压后得到如下内容：\n双击ubuntu.exe，即可开始安装wsl-ubuntu。\n安装完成后在该目录下得到虚拟盘：\n注：虚拟盘也可能变成rootfs文件。\n登录wsl 安装时会让你指定用户名和密码，这个用户是默认添加到sudoers里的。\n如果想用root登录，通过sudo passwd root可以设置root密码（root刚开始没有密码），接着通过su即可登录root。\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/07/wsl-custom-installation-location/","tags":["wsl","windows"],"title":"Wsl 自定义安装位置"},{"categories":["Web"],"contents":"为什么要使用OpenFeign 之前在消费端使用RestTemplate时，每次请求都要进行诸如\n1 restTemplate.postForObject(PAYMENT_URL + \u0026#34;/payment/create\u0026#34;, payment, CommonResult.class); 这样的调用，需要指定较多参数，当一个接口调用中需要非常多这样的请求时，会比较繁琐，而且这种方式不够抽象。\nOpenFegin利用面向接口编程的思想，抽象化，简化了上述操作。\n使用OpenFeign 关于pom.xml 1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 关于application.yml 除了基本配置内容外，注意以下配置：\n1 2 3 4 5 6 7 8 9 10 11 feign: # 设置feign客户端超时时间（默认为1秒） client: config: default: ConnectTimeOut: 10000 ReadTimeOut: 10000 # 针对每个接口设置日志监控级别 logging: level: com.jzh.springcloud.service.PaymentService: debug # feign日志以什么级别监控端口 编写服务接口 首先在启动类开启@EnableFeignClients注解，接着编写服务接口：\n添加@FeignClient注解，值为对应微服务名； 方法对应微服务Controller下的方法即可。 1 2 3 4 5 6 7 8 9 @Component @FeignClient(value = \u0026#34;CLOUD-PAYMENT-SERVICE\u0026#34;) public interface PaymentService { @GetMapping(\u0026#34;/payment/get/{id}\u0026#34;) CommonResult\u0026lt;Payment\u0026gt; getPaymentById(@PathVariable(\u0026#34;id\u0026#34;) Long id); @PostMapping(\u0026#34;/payment/create\u0026#34;) CommonResult\u0026lt;Integer\u0026gt; createPayment(@RequestBody Payment payment); } 调用接口 注入PaymentController接口，然后即可调用它的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @RestController @Slf4j public class PaymentController { @Resource private PaymentService paymentService; @PostMapping(\u0026#34;/consumer/payment/create\u0026#34;) public CommonResult\u0026lt;Integer\u0026gt; create(@RequestBody Payment payment) { return paymentService.createPayment(payment); } @GetMapping(\u0026#34;/consumer/payment/get/{id}\u0026#34;) public CommonResult\u0026lt;Payment\u0026gt; getPayment(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return paymentService.getPaymentById(id); } } 配置日志输出级别 返回Logger.Level对象，放入spring容器中\n1 2 3 4 5 6 7 @Configuration public class FeignConfig { @Bean Logger.Level feignLogLevel() { return Logger.Level.BASIC; } } From My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/07/openfeign-usage-record/","tags":["springcloud","microservice"],"title":"OpenFeign 使用记录"},{"categories":["Algorithm"],"contents":"快速幂运算的解释 问n是否满足$x^n \\mod n = x (1 \u0026lt; x \u0026lt; n)$？\n先由一个例子引入：\n$3^{11} = 3 \\times 9^5 = 3 \\times 9 \\times 81^2 = 3 \\times 9 \\times 6561^1$\n$result = 3 \\times 9 \\times 6561 = 3^{2^0} \\times 3^{2^1} \\times 3^{2^3}$\n可见发现这次运算中，幂的结果等于变化中所有当指数为奇数时底数之积。其中，每次运算均发生指数除二（对应二进制右移一位），且当该指数为奇数时，原式乘上底数。\n而这个过程其实相当于一个数进行模2取余求二进制数的过程，每次都除2，当模2余1，即对应二进制最末位为1时乘上底数，则由此可以推知快速幂运算的算法过程。\n这个结论是可以证明的，如下：\n对于任何十进制正整数n，设其对应二进制数为\u0026quot;$b_m\u0026hellip;b_3b_2b_1$\u0026quot;，则有：\n二进制转十进制：$n = 1b_1+2b_2+4b_3+\u0026hellip;+2^{m-1}b_m$； 幂的二进制展开：$x^n = x^{1b_1}x^{2b_2}x^{4b_3}\u0026hellip;x^{2^{m-1}b_m}$。 则对于$x^n$的求解，可以转化为：\n计算$x^1,x^2,x^4\u0026hellip;x^{m-1}$的值，相当于$x=x^2$的过程； 获取二进制各位$b_1,b_2,b_3,\u0026hellip;,b_m$的值，相当于模2求余的过程。 上述过程中，当$b_i=0$时，$x^{2^{i-1}b_i}=1$，反之为$x^{2^{i-1}}$，由此可以顺利计算$x^n$。\n相应代码：\n1 2 3 4 5 6 7 8 9 10 typedef long long ll; ll mod_pow(ll x, ll n, ll mod) { ll res = 1; while(n \u0026gt; 0) { if(n \u0026amp; 1 == 1) res = res * x % mod; // 一个数\u0026amp;1的结果就是取该数二进制的最末位 x = x * x % mod; n \u0026gt;\u0026gt;= 1; }\treturn res; } 注意，运用位运算可以提高效率！\n一道易错题 剑指 Offer 16. 数值的整数次方\n实现 pow(x, n) ，即计算x的n次幂函数。不得使用库函数，同时不需要考虑大数问题。\n其实就是快速幂运算的简单应用，然而却很容易忽略一些细节：\n可以看几个判例：\n1 2 1.00000 -2147483648 不特判的话有可能超时，注意当$x=1，x=-1，x=0，n=0$时都可以直接得到答案。\n同时，如果执行n=-n，将会出错，因为2147483648超出了int的范围[-2147483648, 2147483647]！可以通过long n1 = n解决这个问题。\n1 2 2.10000 3 应该注意到x可以为小数。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: double myPow(double x, int n) { if (x == 0) return 0; if (x == 1 || n == 0) return 1; if (x == -1) return n % 2 ? -1 : 1; long n1 = n; double ans = 1.0; if (n \u0026lt; 0) { x = 1 / x; n1 = -n1; } while (n1) { if (n1 \u0026amp; 1) ans *= x; x = x * x; n1 \u0026gt;\u0026gt;= 1; } return ans; } }; From My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/07/understand-and-apply-fast-power-operation/","tags":["algorithm","math"],"title":"理解快速幂运算并进行应用"},{"categories":["Tool"],"contents":"注册账号并创建Index 官网链接：Algolia，注册完成后保存好ApiID和ApiKey。\n接着，创建一个Index，保存好Index的名称。\n数据生成以及上传Algolia 方法一：通过hugo-algolia插件的方式 一、下载hugo-algolia： npm install -g hugo-algolia\n二、编写config.yaml\n网站根目录下创建config.yaml，编写参数如下：\n1 2 3 4 5 6 --- algolia: index: \u0026#34;{indexName}\u0026#34; key: \u0026#34;{key}\u0026#34; appID: \u0026#34;{appID}\u0026#34; --- 三、生成algolia.json\n网站根目录下运行： hugo-algolia -s，即可生成 {site}/public/algolia.json，同时该数据也同步到了algolia账户下，可以去官网查看。\n四、前往algolia的indices进行搜索类型的设置\n可以选择按tag，category，content等内容进行搜索，并指定优先级。\n方法二：通过GithubAction的方式 这里不通过插件而是通过hugo定制化地生成algolia.json，然后通过GithubAction在每次push时上传数据。\n个人更推荐这样做，更好定制化且方便。同时上面方法一有个bug，对中文数据好像不支持。\n一、配置algolia输出文件 1 2 3 4 5 6 7 8 9 10 outputs: home: - HTML - RSS - Algolia outputFormats: Algolia: mediaType: application/json baseName: algolia isPlainText: true 二、生成algolia.json 编辑 {site}/themes/layouts/_default/list.algolia.json 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [ {{- range $index, $entry := .Site.RegularPages }} {{- if $index }}, {{ end }} { \u0026#34;objectID\u0026#34;: \u0026#34;{{ .File.TranslationBaseName }}\u0026#34;, \u0026#34;url\u0026#34;: {{ .Permalink | jsonify }}, \u0026#34;title\u0026#34;: {{ .Title | jsonify }}, \u0026#34;date\u0026#34;: {{ .PublishDate | jsonify }}, \u0026#34;tags\u0026#34;: {{ .Params.tags | jsonify }}, \u0026#34;categories\u0026#34;: {{.Params.categories | jsonify}}, \u0026#34;summary\u0026#34;: {{ .Summary | jsonify }}, \u0026#34;content\u0026#34;: {{ .Plain | jsonify }} } {{- end }} ] 这里可以自行查阅文档定制化查询数据。\n接着，在{site}下通过hugo命令即可在public下生成algolia.json文件。\n三、在GithubAction新建工作流： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 name: Algolia Upload Records on: [push] # 推送时执行 jobs: algolia: runs-on: ubuntu-latest steps: - name: Checkout # 获取代码 Checkout uses: actions/checkout@v2 - name: Upload Records # 使用 Action uses: iChochy/Algolia-Upload-Records@main # 设置环境变量 env: APPLICATION_ID: ${{secrets.ALGOLIA_APPID}} # appID ADMIN_API_KEY: ${{secrets.ALGOLIA_KEY}} # key INDEX_NAME: ${{secrets.ALGOLIA_INDEX}} # index FILE_PATH: algolia.json 注意添加好对应环境变量。\n之后，每次push都会自动将algolia.json推送到algolia数据库啦。\n四、关于搜索类型的设置 前往algolia的indices进行搜索类型的设置，可以选择按tag，category，content等内容进行搜索，并指定优先级。\n定制搜索框 定制search.html 在{site}/themes/{theme}/layouts/partials下创建search.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;div id=\u0026#34;modalSearch\u0026#34; class=\u0026#34;modal fade\u0026#34; role=\u0026#34;dialog\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;modal-dialog\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;modal-content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;modal-body\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;aa-input-container\u0026#34; id=\u0026#34;aa-input-container\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;search\u0026#34; id=\u0026#34;aa-search-input\u0026#34; class=\u0026#34;aa-input-search\u0026#34; placeholder=\u0026#34;write here...\u0026#34; name=\u0026#34;search\u0026#34; autocomplete=\u0026#34;off\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;{{ \u0026#34;https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js\u0026#34; | absURL }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;{{ \u0026#34;https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js\u0026#34; | absURL }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var client = algoliasearch(\u0026#34;{appID}\u0026#34;, \u0026#34;{key}\u0026#34;); var index = client.initIndex(\u0026#39;{indexName}\u0026#39;); autocomplete(\u0026#39;#aa-search-input\u0026#39;, { hint: false}, { source: autocomplete.sources.hits(index, {hitsPerPage: 8}), displayKey: \u0026#39;name\u0026#39;, templates: { suggestion: function(suggestion) { var des_url = suggestion.uri; var reg = /[《》（）]/g; // 转化一些中文字符，可以自己指定需要的 des_url = des_url.toLowerCase().replace(reg, \u0026#34;\u0026#34;); // 转为小写 return \u0026#39;\u0026lt;span\u0026gt;\u0026#39; + \u0026#39;\u0026lt;a href=\u0026#34;\u0026#39; + des_url + \u0026#39;\u0026#34;\u0026#34;\u0026gt;\u0026#39; + suggestion._highlightResult.title.value + \u0026#39;\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\u0026#39;; } } }); \u0026lt;/script\u0026gt; 其中注意代码片段：\n1 2 var client = algoliasearch(\u0026#34;{appID}\u0026#34;, \u0026#34;{key}\u0026#34;); var index = client.initIndex(\u0026#39;{indexName}\u0026#39;); 自己填入自己的appID，key，index名称即可。\n在自己需要的地方放置搜索框 1 2 \u0026lt;!--搜索文章--\u0026gt; {{ partial \u0026#34;search.html\u0026#34; . }} From My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/07/hugo-adds-onsite-search-function-through-algolia/","tags":["hugo","site"],"title":"Hugo 通过 Algolia 添加站内搜索功能"},{"categories":["Web"],"contents":"负载均衡（LB）是什么 对于用户的某个请求，将有多个相同功能的服务点服务该请求，某个服务点挂了，其他服务点还是可以进行服务，这样就实现了系统的高可用。\n关于集中式LB和进程内LB 集中式LB 在服务的消费方和提供方之间使用独立的LB设施，（软硬件均可，软件如Nginx，硬件如F5），由该设施负责把访问请求通过某种策略（可自行指定）转发至服务的提供方。\n进程内LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务点进行服务。\nRibbon属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它获取服务提供方的地址。\n使用Ribbon实现负载均衡 关于导包 1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 已经包含了ribbon --\u0026gt; \u0026lt;/dependency\u0026gt; 注意eureka内置了ribbon。\n开启注解 1 2 3 4 5 6 7 8 @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced // 赋予负载均衡能力 public RestTemplate getRestTemplate() { return new RestTemplate(); } } 访问相同服务名地址即可。\n修改Ribbon负载均衡规则 所有规则均实现了IRule接口，通过查看接口实现类即可知道规则的种类。\n默认是RoundRobinRule（轮询）这一规则。\n下面修改为RandomRule（随机）这一规则：\n在启动类扫描不到的包下创建规则： 1 2 3 4 5 6 7 @Configuration public class MyRibbonRule { @Bean public IRule myRule() { return new RandomRule(); } } 在启动类指定规则： 1 2 3 4 5 6 7 8 @SpringBootApplication @EnableEurekaClient @RibbonClient(name=\u0026#34;CLOUD-PAYMENT-SERVICE\u0026#34;, configuration = MyRibbonRule.class) public class OrderMain80 { public static void main(String[] args) { SpringApplication.run(OrderMain80.class, args); } } 自己实现负载均衡 编写LB接口即实现类 要实现负载均衡，首先应获取得到所有的服务实例ServiceInstance。\n1 2 3 public interface LoadBalancer { ServiceInstance getServiceInstance(List\u0026lt;ServiceInstance\u0026gt; instances); } 通过自旋锁获取新值，取余ServiceInstance个数，得到目标ServiceInstance下标。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component public class MyLoadBalancer implements LoadBalancer { private AtomicInteger aint = new AtomicInteger(0); public final int myCAS() { int expect, next; for (;;) { expect = aint.get(); next = (expect + 1) % Integer.MAX_VALUE; if (aint.compareAndSet(expect, next)) return next; } } @Override public ServiceInstance getServiceInstance(List\u0026lt;ServiceInstance\u0026gt; instances) { if (instances == null || instances.size() \u0026lt;= 0) return null; return instances.get(myCAS() % instances.size()); } } 编写Controller 注意需要通过获取得到的ServiceInstance的uri作为访问前缀。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Resource private RestTemplate restTemplate; @Resource private EurekaDiscoveryClient discoveryClient; @Resource private LoadBalancer loadBalancer; @GetMapping(\u0026#34;/consumer/payment/lb\u0026#34;) public String lbTest() { List\u0026lt;ServiceInstance\u0026gt; instances = discoveryClient.getInstances(\u0026#34;CLOUD-PAYMENT-SERVICE\u0026#34;); ServiceInstance instance = loadBalancer.getServiceInstance(instances); log.info(\u0026#34;lbtest: \u0026#34; + instance.getUri().toString()); return restTemplate.getForObject(instance.getUri() + \u0026#34;/payment/lb\u0026#34;, String.class); } From My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/07/understand-ribbon-and-realize-load-balancing-by-yourself/","tags":["microservice","springcloud"],"title":"理解 Ribbon 并自己实现负载均衡"},{"categories":["Web"],"contents":"前言 类似于zookeeper和eureka，也起到微服务注册中心的作用, 满足分布式系统中的CP原则，是弱可用性的。\n不同于zookeeper和eureka这两种主要由Java编写的语言，它主要由Go语言编写。\n配置Consul环境 下载consul，配置环境变量。 运行consul agent -dev开启服务。 默认端口为8500，访问localhost:8500进入管理界面。 编写springcloud服务代码 一、关于pom.xml\n除了一些基本包的导入之外，关于consul包的导入：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-consul-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 二、关于application.yml\n1 2 3 4 5 6 7 8 9 10 spring: application: name: cloud-consumer-order cloud: consul: host: localhost port: 8500 discovery: service-name: ${spring.application.name} 三、启动类添加@EnableDiscoveryClient注解。\nconsul测试 较为简单，访问localhost:8500查看即可。\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/07/consul-configuration-process-and-test/","tags":["springcloud","microservice"],"title":"Consul 配置过程及测试"},{"categories":["Web"],"contents":"前言 Zookeeper类似于Eureka，起到微服务注册中心的作用，满足分布式系统中的CP原则，是弱可用性的。\n配置zookeeper环境 安装zookeeper 下载并解压zookeeper包为zookeeper3.7.1（假设下载的是3.7.1版本）。\n然后将zookeeper解压缩到/usr/local/zookeeper3.7.1。\n配置参数 一、编辑/conf/zoo.cfg\n编辑zookeeper包内配置文件/conf/zoo.cfg（先创建，再将zoo_sample.cfg内容复制到其中）\n修改或添加以下内容：\n1 2 dataDir=/usr/local/zookeeper3.7.1/dataDir dataLogDir=/usr/local/zookeeper3.7.1/dataLogDir 注意同时创建对应文件夹。其中端口号默认为2181，也可以进行修改。\n二、 配置环境变量\n1 2 3 # zookeeper export ZOOKEEPER_HOME=/usr/local/zookeeper3.7.1 export PATH=$PATH:$ZOOKEEPER_HOME/bin 接着通过source命令生效。\n开启zookeeper连接 （前置条件是已配好java环境）\n执行 zkServer.sh start即可。\n查看连接情况： 1 2 3 4 5 6 zkServer.sh status ZooKeeper JMX enabled by default Using config: /usr/local/zookeeper3.7.1/bin/../conf/zoo.cfg Client port found: 2181. Client address: localhost. Client SSL: false. Mode: standalone 可见已经开启成功了。\n客户端进行连接： 执行 zkCli.sh，连接成功后可查看：\n1 2 3 [zk: localhost:2181(CONNECTED) 1] ls / [zookeeper] [zk: localhost:2181(CONNECTED) 2] get /zookeeper 编写springcloud服务代码 一、关于pom.xml\n除了一些基本包的导入之外，关于zookeeper包的导入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-zookeeper-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.apache.zookeeper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zookeeper\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.zookeeper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zookeeper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.7.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; starter默认包可能和自己服务器上的zookeeper版本不一致，需要排除并执行导入。\n二、关于application.yml\n1 2 3 cloud: zookeeper: connect-string: 172.23.215.195:2181 # 自己服务器ip以及zookeeper端口地址。 三、启动类添加@EnableDiscoveryClient注解。\nzookeeper测试 1 2 3 4 5 6 7 8 9 [zk: localhost:2181(CONNECTED) 3] ls / [services, zookeeper] [zk: localhost:2181(CONNECTED) 4] ls /services [cloud-provider-payment] [zk: localhost:2181(CONNECTED) 5] ls /services/cloud-provider-payment [2f68697b-4e55-4740-9204-f74842694a1d] [zk: localhost:2181(CONNECTED) 10] get /services/cloud-provider-payment/2f68697b-4e55-4740-9204-f74842694a1d {\u0026#34;name\u0026#34;:\u0026#34;cloud-provider-payment\u0026#34;,\u0026#34;id\u0026#34;:\u0026#34;2f68697b-4e55-4740-9204-f74842694a1d\u0026#34;,\u0026#34;address\u0026#34;:\u0026#34;LAPTOP-JZH\u0026#34;,\u0026#34;port\u0026#34;:8004,\u0026#34;sslPort\u0026#34;:null,\u0026#34;payload\u0026#34;:{\u0026#34;@class\u0026#34;:\u0026#34;org.springframework.cloud.zookeeper.discovery.ZookeeperInstance\u0026#34;,\u0026#34;id\u0026#34;:\u0026#34;application-1\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;cloud-provider-payment\u0026#34;,\u0026#34;metadata\u0026#34;:{}},\u0026#34;registrationTimeUTC\u0026#34;:1658200325523,\u0026#34;serviceType\u0026#34;:\u0026#34;DYNAMIC\u0026#34;,\u0026#34;uriSpec\u0026#34;:{\u0026#34;parts\u0026#34;:[{\u0026#34;value\u0026#34;:\u0026#34;scheme\u0026#34;,\u0026#34;variable\u0026#34;:true},{\u0026#34;value\u0026#34;:\u0026#34;://\u0026#34;,\u0026#34;variable\u0026#34;:false},{\u0026#34;value\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;variable\u0026#34;:true},{\u0026#34;value\u0026#34;:\u0026#34;:\u0026#34;,\u0026#34;variable\u0026#34;:false},{\u0026#34;value\u0026#34;:\u0026#34;port\u0026#34;,\u0026#34;variable\u0026#34;:true}]}} 对以上json串格式化后，可以获得服务具体信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 { \u0026#34;name\u0026#34;: \u0026#34;cloud-provider-payment\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;2f68697b-4e55-4740-9204-f74842694a1d\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;LAPTOP-JZH\u0026#34;, \u0026#34;port\u0026#34;: 8004, \u0026#34;sslPort\u0026#34;: null, \u0026#34;payload\u0026#34;: { \u0026#34;@class\u0026#34;: \u0026#34;org.springframework.cloud.zookeeper.discovery.ZookeeperInstance\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;application-1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;cloud-provider-payment\u0026#34;, \u0026#34;metadata\u0026#34;: {} }, \u0026#34;registrationTimeUTC\u0026#34;: 1658200325523, \u0026#34;serviceType\u0026#34;: \u0026#34;DYNAMIC\u0026#34;, \u0026#34;uriSpec\u0026#34;: { \u0026#34;parts\u0026#34;: [ { \u0026#34;value\u0026#34;: \u0026#34;scheme\u0026#34;, \u0026#34;variable\u0026#34;: true }, { \u0026#34;value\u0026#34;: \u0026#34;://\u0026#34;, \u0026#34;variable\u0026#34;: false }, { \u0026#34;value\u0026#34;: \u0026#34;address\u0026#34;, \u0026#34;variable\u0026#34;: true }, { \u0026#34;value\u0026#34;: \u0026#34;:\u0026#34;, \u0026#34;variable\u0026#34;: false }, { \u0026#34;value\u0026#34;: \u0026#34;port\u0026#34;, \u0026#34;variable\u0026#34;: true } ] } } From My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/07/zookeeper-configuration-process-and-test/","tags":["microservice","springcloud"],"title":"Zookeeper 配置过程与测试"},{"categories":["Web"],"contents":"前言 起到微服务注册中心的作用，满足分布式系统中的AP原则，是弱一致性的。\nEureka微服务架构图 服务接口采用集群模式，8001和8002端口都实现支付接口服务。 用户接口在运行在80端口，调用8001和8002的服务。 注册中心内部也采用集群模式，7001和7002端口都实现注册服务。 引入Eureka依赖说明 client端：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; server端：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 7001和7002端口关键配置内容 一、启动类开启注解\n1 2 3 4 5 6 7 @SpringBootApplication @EnableEurekaServer public class EurekaMain7001 { public static void main(String[] args) { SpringApplication.run(EurekaMain7001.class, args); } } 二、application.yml文件配置\n对于7001端口服务：（7002端口类似）\n1 2 3 4 5 6 7 8 9 10 11 eureka: instance: hostname: eureka7001.com client: # false 表示不向注册中心注册自己 register-with-eureka: false # false 表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 fetch-registry: false service-url: # 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址 defaultZone: http://eureka7002.com:7002/eureka/ 注意defaultZone配置指向其他注册服务端口，需满足“相互注册”。\n另外，eureka7001.com和eureka7002.com其实配置指向localhost，这里只是为了模拟多台机器。\n8001和8002端口关键配置内容 一、开启EnableEurekaClient注解\n1 2 3 4 5 6 7 @SpringBootApplication @EnableEurekaClient public class PaymentMain8001 { public static void main(String[] args) { SpringApplication.run(PaymentMain8001.class, args); } } @EnableEurekaClient表明它是一个Eureka注册客户端。\n二、application.yml文件配置\neureka配置部分：\n1 2 3 4 5 6 7 8 9 eureka: client: register-with-eureka: true # 配置是否进行注册 fetch-registry: true # 配置是否从eureka注册中心拉取注册信息 service-url: # 配置注册地址 defaultZone: http://eureka7001.com:7001/eureka, http://eureka7002.com:7002/eureka instance: instance-id: payment8001 prefer-ip-address: true # 鼠标到instance上会显示ip 配置服务名称：\n1 2 3 spring: application: name: cloud-payment-service 这个服务名很重要，用于配置后面用户接口的服务地址。\n80端口关键配置内容 一、开启EnableEurekaClient注解\n1 2 3 4 5 6 7 @SpringBootApplication @EnableEurekaClient public class OrderMain80 { public static void main(String[] args) { SpringApplication.run(OrderMain80.class, args); } } 二、配置RestTemplate，开启负载均衡\n1 2 3 4 5 6 7 8 @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced // 赋予负载均衡能力 public RestTemplate getRestTemplate() { return new RestTemplate(); } } 三、Controller指定负载均衡访问服务地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @RestController @Slf4j public class OrderController { public static final String PAYMENT_URL = \u0026#34;http://CLOUD-PAYMENT-SERVICE\u0026#34;; @Resource private RestTemplate restTemplate; @GetMapping(\u0026#34;/consumer/payment/create\u0026#34;) public CommonResult\u0026lt;Integer\u0026gt; create(@RequestParam(value = \u0026#34;serial\u0026#34;) String serial) { Payment payment = new Payment(0L, serial); log.info(\u0026#34;serial: \u0026#34; + serial); return restTemplate.postForObject(PAYMENT_URL + \u0026#34;/payment/create\u0026#34;, payment, CommonResult.class); } @GetMapping(\u0026#34;/consumer/payment/get/{id}\u0026#34;) public CommonResult\u0026lt;Payment\u0026gt; getPayment(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return restTemplate.getForObject(PAYMENT_URL + \u0026#34;/payment/get/\u0026#34; + id, CommonResult.class); } } 注意：\nController必须是GetMapping，然后通过 restTemplate.getForObject()或 restTemplate.postForObject()发送get或post请求。 配置的服务地址前缀为http://加上服务接口对应的application-name的全大写形式。 效果展示 一、访问http://localhost:7001或者http://eureka7001.com:7001\n可见所有服务已经成功注册。\n二、访问http://localhost/consumer/payment/get/3\n成功返回结果，服务端口动态变换：\n1 2 3 4 5 { \u0026#34;code\u0026#34;:200, \u0026#34;message\u0026#34;:\u0026#34;查询成功，访问端口：8001\u0026#34;, \u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:3,\u0026#34;serial\u0026#34;:\u0026#34;ajefskldfa\u0026#34;} } 1 2 3 4 5 { \u0026#34;code\u0026#34;:200, \u0026#34;message\u0026#34;:\u0026#34;查询成功，访问端口：8002\u0026#34;, \u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:3,\u0026#34;serial\u0026#34;:\u0026#34;ajefskldfa\u0026#34;} } From My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/07/eureka-configuration-process-and-understanding/","tags":["springcloud","microservice"],"title":"Eureka 配置过程与理解"},{"categories":["Tool"],"contents":"Vim 1 2 3 4 5 vim /etc/vimrc set tabstop=4 # 修改vim中tab长度 set shiftwidth=4 # 修改vim自动缩进长度 set noeb vb t_vb= # 禁用vim蜂鸣声 1 2 3 vim /etc/inputrc set bell-style none # 禁用bash蜂鸣声 主机名称 1 2 3 hostnamectl hostnamectl set-hostname xxx 登录欢迎信息配置 1 vim /etc/update-motd.d 自行修改基本欢迎信息。\n1 2 3 vim /etc/ssh/sshd_config PrintLastLog no 不打印上次登录信息。\n命令提示符 1 2 3 vim ~/.bashrc export PS1=\u0026#34;[\\u =\u0026gt; \\w]\\$ \u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \\a\t铃声字符 \\d\t格式为“日 月 年”的日期 \\e\tASCII 转义字符 \\h\t本地主机名 \\H\t完全合格的限定域主机名 \\j\tshell 当前管理的作业数 \\1\tshell 终端设备名的基本名称 \\n\tASCII 换行字符 \\r\tASCII 回车 \\s\tshell 的名称 \\t\t格式为“小时:分钟:秒”的24小时制的当前时间 \\T\t格式为“小时:分钟:秒”的12小时制的当前时间 \\A\t格式为“小时:分钟”的24小时制的当前时间 @\t格式为 am/pm 的12小时制的当前时间 \\s\tshell的名字 \\u\t当前用户的用户名 \\v\tbash shell 的版本 \\V\tbash shell 的发布级别 \\w\t当前工作目录 \\W\t当前工作目录的基本名称 !\t该命令的 bash shell 历史数 #\t该命令的命令数量 $\t如果是普通用户，则为美元符号$；如果超级用户（root 用户），则为井号#。 \\nnn\t对应于八进制值 nnn 的字符 \\\t斜杠 [\t控制码序列的开头 ]\t控制码序列的结尾 系统时区修改 1 2 3 4 5 6 7 8 9 10 11 root@OranMe2474:~# timedatectl list-timezones | grep Shanghai Asia/Shanghai root@OranMe2474:~# timedatectl set-timezone Asia/Shanghai root@OranMe2474:~# timedatectl Local time: Mon 2022-11-28 10:59:39 CST Universal time: Mon 2022-11-28 02:59:39 UTC RTC time: n/a Time zone: Asia/Shanghai (CST, +0800) System clock synchronized: yes NTP service: inactive RTC in local TZ: no Crontab时区修改 1 2 3 4 5 6 vim /etc/crontab CRON_TZ=Asia/Shanghai TZ=Asia/Shanghai systemctl restart cron From my blog: akynazh.\nOver.\n","permalink":"/posts/2022/07/linux-display-content-configuration-record/","tags":["linux"],"title":"Linux 展示性内容配置记录"},{"categories":["Book"],"contents":"作者：川端康成\n黄昏的景色在镜后移动着。也就是说，镜面映现的虚像与镜后的实物在晃动，好像电影里的叠影一样。出场人物和背景没有任何联系。而且人物是一种透明的幻象，景物则是在夜霭中的朦胧暗流，两者消融在一起，描绘出一个超脱人世的象征世界。特别是当山野里的灯火映照在姑娘的脸上时，那种无法形容的美，使岛村的心都几乎为之颤动。 在遥远的山巅上空，还淡淡地残留着晚霞的余晖。透过车窗玻璃看见的景物轮廓，退到远方，却没有消逝，但已经黯然失色。尽管火车继续往前奔驰，在他看来，山野那平凡的姿态显得更加平凡。由于什么东西都不十分惹他注目，他内心反而好像隐隐地存在着一股巨大的感情激流。这自然是由于镜中浮现出姑娘的脸的缘故。只有身影映在窗玻璃上的部分，遮住了窗外的暮景，然而，景色却在姑娘的轮廓周围不断地移动，使人觉得姑娘的脸也像是透明的。是不是真的透明呢？这是一种错觉。因为从姑娘面影后面不停地掠过的暮景，仿佛是从她脸的前面流过。定睛细看，却又扑朔迷离。 车厢里也不太明亮。窗玻璃上的映像，不像真的镜子那样清晰。没有反光。这使岛村看得入了神，他渐渐地忘却了镜子的存在，只觉得姑娘好像漂浮在流逝的暮景之中。 这当儿，姑娘的脸上闪现着灯光。镜中映像的清晰度并没有减弱窗外的灯火。灯火也没有把映像抹去。灯火就这样从她的脸上闪过，但并没有把她的脸照亮。这是一束从远方投来的寒光，模模糊糊地照亮了她眼睛的周围。她的眼睛同灯光重叠的那一瞬间，就像在夕阳的余晖里飞舞的夜光虫，妖艳而美丽。\n岛村明白，自己从一开头就是想找这个女子，可偏偏和平常一样拐弯抹角，不免讨厌起自己来。与此同时，越发觉得这个女子格外的美。从刚才她站在杉树背后喊自己开始，他就感到这个女子的倩影是多么袅娜多姿啊。 玲珑而悬直的鼻梁，虽嫌单薄些，但在下方搭配着的小巧的紧闭的柔唇，却宛如美极了的水蛭环节，光滑而伸缩自如，在默默无言中也有一种动的感觉。如果嘴唇起了皱纹，或者色泽不好，就会显得不洁净。她的嘴唇却不是这样，而是滋润光泽的。两只眼睛，眼梢不翘起也不垂下，简直像有意描直了似的，虽逗人发笑，却恰到好处地镶嵌在两道微微下弯的浓密的短眉毛下。颧骨稍耸的圆脸，轮廓一般，但肤色恰似在白瓷上抹了一层淡淡的胭脂。脖颈底下的肌肉尚未丰满。她虽算不上是个美人，但比谁都要显得洁净。\n岛村朝她望去，突然缩了缩脖子。镜子里白花花闪烁着的原来是雪。在镜中的雪里现出了女子通红的脸颊。这是一种无法形容的纯洁的美。 也许是旭日东升了，镜中的雪愈发耀眼，活像燃烧的火焰。浮现在雪上的女子的头发，也闪烁着紫色的光，更增添了乌亮的色泽。\n玲珑而悬直的鼻梁，虽显得有点单薄，但双颊绯红，很有朝气，仿佛在窃窃私语：我在这里呢。那两片美丽而又红润的嘴唇微微闭上时，上面好像闪烁着红光，显得格外润泽。那樱桃小口纵然随着歌唱而张大，可是很快又合上，可爱极了，就如同她的身体具有的魅力一样。在微弯的眉毛下，那双外眼梢既不翘起，也不垂下，眼睛简直像有意描直了似的，如今滴溜溜的，带着几分稚气。她没有施白粉，都市的艺伎生活却给她留下惨白的肤色，而今天又渗入了山野的色彩，娇嫩得好像新剥开的百合花或是洋葱的球根，连脖颈也微微泛起了淡红，显得格外洁净无瑕。\n火车开动之后，候车室里的玻璃窗豁然明亮起来，驹子的脸在亮光中闪闪浮现，眼看着又消失了。这张脸同早晨雪天映在镜中的那张脸一样，红扑扑的。在岛村看来，这又是介于梦幻与现实之间的另一种颜色。 火车从北面爬上县界的山，穿过长长的隧道，只见冬日下午淡淡的阳光，像被地底下的黑暗吞噬，又像那陈旧的火车把明亮的外壳脱落在隧道里，在重重叠叠的山峦之间，向暮色苍茫的峡谷驶去。山的这一侧还没有下雪。 沿着河流行驶不多久，来到了辽阔的原野，山巅好像精工的雕刻，从那里浮现出一道柔和的斜线，一直延伸到山脚下。山头上罩满了月色。这是原野尽头唯一的景色。淡淡的晚霞把整座山映成深宝蓝色，轮廓分明地浮现出来。月色还很淡，并不使人产生冬夜寒峭的感觉。天空没有一只飞鸟。山麓的原野，一望无垠，远远地向左右伸展，快到河边的地方，耸立着一座好像是水电站的白色建筑物。那是透过车窗望见的、在一片冬日萧瑟的暮色中仅留下来的景物。\n村仿佛坐上了某种非现实的东西，失去了时间和距离的概念，陷入了迷离恍惚之中，徒然地让它载着自己的身躯奔驰。单调的车轮声，开始听的时候像是女子的絮絮话语。 这话语断断续续，而且相当简短，但它却是女子竭力争取生存的象征。他听了十分难过，以致难以忘怀。然而，对渐渐远去的岛村来说，现在这已经是徒增几许旅愁的遥远的声音了。\n“银河，多美啊！” 驹子喃喃自语。她仰望着天空，又跑起来。 啊，银河！岛村也仰头叹了一声，仿佛自己的身体悠然飘上了银河当中。银河的亮光显得很近，像是要把岛村托起来似的。当年漫游各地的芭蕉￼，在波涛汹涌的海上所看见的银河，也许就像这样一条明亮的大河吧。茫茫的银河悬在眼前，仿佛要以它那赤裸裸的身体拥抱夜色苍茫的大地。真是美得令人惊叹。岛村觉得自己那小小的身影，反而从地面上映入了银河。缀满银河的星辰，耀光点点，清晰可见，连一朵朵光亮的云彩，看起来也像粒粒银沙子，明澈极了。而且，银河那无底的深邃，把岛村的视线吸引过去了。\n","permalink":"/posts/2022/07/snow-country-abstract/","tags":["excerpt"],"title":"《雪国》文摘"},{"categories":["Web"],"contents":"依赖导入： 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!-- swagger所需依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置Swagger /config/SwaggerConfig.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.withClassAnnotation(Api.class)) .paths(PathSelectors.any()) .build(); } // 基本信息的配置，信息会在api文档上显示 private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\u0026#34;jzh测试的接口文档\u0026#34;) .description(\u0026#34;xx相关接口的文档\u0026#34;) .termsOfServiceUrl(\u0026#34;http://localhost:7777\u0026#34;) .version(\u0026#34;1.0\u0026#34;) .build(); } } 以后访问http://localhost:7777即可查看文档界面。\nSwagger具体使用 注解用途 一、@Api\n使用在类上，表明是swagger资源，@API拥有两个属性:value、tags，源码如下：\n1 2 3 4 5 //If tags is not used,this value will be used to set the tag for the operations described by this resource. Otherwise, the value will be ignored. String value() default \u0026#34;\u0026#34;; //Tags can be used for logical grouping of operations by resources or any other qualifier. String[] tags() default {\u0026#34;\u0026#34;}; 生成的api文档会根据tags分类，如果tags未被使用，那么value将被当作tag使用（value一般用于描述该类的作用，但不能有多个值）。\n二、@ApiOperation\n使用于在方法上，表示一个请求的操作。\nvalue：用于方法描述 notes：用于提示内容 tags：可以重新分组（视情况而用） 三、@ApiParam\n使用在方法上或者参数上。\nname：参数名 value：参数说明 required：是否必填 四、@ApiModel\n使用在类上，表示对类进行说明。\nvalue：表示对象名 description：描述 五、@ApiModelProperty\n使用在方法，字段上，表示对model属性的说明或者数据操作更改。\nvalue：字段说明 name：重写属性名字 dataType：重写属性类型 required：是否必填 example：举例说明 hidden：隐藏 具体使用 /SwaggerTest.java\n1 2 3 4 5 6 7 8 9 10 11 @RestController @RequestMapping(\u0026#34;/swagger\u0026#34;) @Api(tags = {\u0026#34;测试swagger\u0026#34;, \u0026#34;用户基本操作\u0026#34;}) public class SwaggerTest { @ApiOperation(value = \u0026#34;新增用户\u0026#34;) @GetMapping(\u0026#34;/adduser/{userName}/{userPwd}\u0026#34;) public SwaggerUser addUser(@PathVariable @ApiParam(value = \u0026#34;用户名\u0026#34;, required = true) String userName, @PathVariable @ApiParam(value = \u0026#34;密码\u0026#34;, required = true) String userPwd) { return new SwaggerUser(new Random().nextInt(100), userName, userPwd); } } /SwaggerUser.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Data @AllArgsConstructor @NoArgsConstructor @ToString public class SwaggerUser { @ApiModelProperty(value = \u0026#34;用户ID\u0026#34;) private Integer userId; @ApiModelProperty(value = \u0026#34;用户名\u0026#34;) private String userName; @ApiModelProperty(value = \u0026#34;用户密码\u0026#34;) private String userPwd; } From My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/06/swagger-usage-record/","tags":["web","springboot"],"title":"Swagger 使用记录"},{"categories":["Language"],"contents":"前言 下面将介绍3种方法：\nCMD添加别名的方法 PowerShell添加别名的方法 通过添加环境变量的方式设置别名 CMD添加别名的方法 设置临时的别名 可以通过doskey命令实现。\n1 doskey ls=echo ====== ^\u0026amp;^\u0026amp; dir /b $* ^\u0026amp;^\u0026amp; echo ====== $*表示还可能有其他命令参数，^\u0026amp;^\u0026amp;用于分开多条命令。\n单纯在一个cmd窗口中使用doskey设置别名，别名只能在该窗口中使用。\n设置永久的别名 可以通过将doskey命令写入bat脚本，再把脚本路径添加到注册表Autorun实现永久且所有cmd都可用的别名，具体步骤如下：\n编写脚本： 1 2 3 @echo off doskey ls=dir /b $* doskey lss=echo ====== ^\u0026amp;^\u0026amp; dir /b $* ^\u0026amp;^\u0026amp; echo ====== 添加路径到注册表 在HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Command Processor下的Autorun中，将数值设为doskey命令脚本所在的路径即可。这样所有用户都可以使用设置好的别名。\n也可在HKEY_CURRENT_USER下的对应位置设置，只针对当前用户设置别名。\n优缺点 通过doskey的方式，挺方便的，但是在命令非常多的情况下不是很方便，同时，设置的命令还不可以在powershell下运行。\nPowerShell添加别名的方法 为PowerShell设置临时的别名 1 2 3 PS C:\\Users\\akyna\u0026gt; set-alias escc esc PS C:\\Users\\akyna\u0026gt; escc ...... 如果带参数，则可以通过function进行：\n1 2 3 PS C:\\Users\\akyna\u0026gt; function func{nircmd emptybin} PS C:\\Users\\akyna\u0026gt; set-alias ctrash func PS C:\\Users\\akyna\u0026gt; ctrash 这样的别名只是在当前会话下有效，开启另一个shell就失效了。\n可以通过export-alias my-alias.txt导出当前会话下的alias，在其他shell中，通过import-alias my-alias.txt即可使用。\n删除PwerShell临时别名 1 2 3 4 PS C:\\Users\\akyna\u0026gt; remove-item alias:escc PS C:\\Users\\akyna\u0026gt; escc escc: The term \u0026#39;escc\u0026#39; is not recognized as a name of a cmdlet, function, script file, or executable program. ... 为PowerShell设置永久的命令别名 打开 PowerShell ，运行 echo $profile，会输出一个powershell配置文件的路径。 打开文件，按以下格式可以设置多条别名： 1 function 别名 { 需要替代的命令，可以包含空格 } e.g.\n一个升级vscode的命令：\n1 2 3 4 5 6 7 8 9 10 11 # 升级vscode function updatevs { taskkill /f /t /im code.exe move D:\\a\\VSCode* D:\\a\\vs.zip Bandizip.exe x -o:\u0026#34;D:\\tools3\\vscode\\Microsoft VS Code\u0026#34; -aoa \u0026#34;D:\\a\\vs.zip\u0026#34; del D:\\a\\vs.zip code pause } #其他别名 ... 以后，新的别名都可以继续添加在该文件中，非常方便。\n将ExecutionPolicy设为RemoteSigned。\n以管理员身份打开 PowerShell，执行 Set-ExecutionPolicy RemoteSigned。 重新启动 PowerShell ，完成。 优缺点 对于命令非常多的情况很方便，但是无法在cmd下运行别名。\n下面介绍一种同时适用于powershell和cmd的方式。\n通过添加环境变量的方式设置别名 操作方法 假如我想通过exesc这个命令运行一些操作命令：\n在路径my_path下新建exesc.bat文件，该文件包含了一系列操作命令； 将my_path加入环境变量； 命令行即可通过键入exesc命令执行exesc.bat。 以后添加任何命令都可以在这个路径中新建bat文件编写别名，非常方便。\n这样在powershell和cmd中都可以使用通过这个方法设置好的别名，但是注意，前提是这个脚本中的命令同时适用于powershell和cmd，比如，如果该脚本中存在一个ls命令，但是cmd没有这个命令，那么cmd就无法使用该别名，但是你可以先通过上面介绍的doskey方法设置好ls别名，这样就可以愉快使用了。\n优缺点 个人感觉是很不错的方法，但是一个别名对应一个文件，不是很方便，无法在一个文件中同时指定所有别名。\n如果想实现通用性，必须兼顾cmd和powershell都存在的命令。如果想使用powershell很多特有的命令，那么实现通用性是比较麻烦的。\n总结 如果你只使用powershell，那么只使用上面第二种方法就好了，这是最舒服的方法。\n如果你只是用cmd，那么就考虑用powershell吧，它可比cmd强大多啦，内置了许多linux命令别名以及一些强大的命令。如果实在不想换，那就用第一种老方法。\n第三种方法，可以视情况而定使用。\nFrom My Blog: akynazh\nover.\n","permalink":"/posts/2022/06/how-to-add-command-alias-in-window/","tags":["windows","powershell"],"title":"Window 添加命令别名的方法"},{"categories":["Web"],"contents":"一、导入依赖： 1 2 3 4 5 \u0026lt;!--发送邮件--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-mail\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 二、配置文件： QQ邮箱需要先开通好邮箱SMTP服务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 spring: # 邮件服务 mail: password: xxxxxx username: xxx@qq.com host: smtp.QQ.com properties: mail: smtp: auth: true starttls: enable: true required: true default-encoding: UTF-8 三、编写邮件服务 sendSimpleMailMessage()实现只含普通文本信息的邮件发送 sendMimeMessage()可以发送带附件的邮件 MailService.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @Service public class MailService { private final JavaMailSender mailSender; @Value(\u0026#34;${spring.mail.username}\u0026#34;) private String SENDER; public MailService(JavaMailSender mailSender) { this.mailSender = mailSender; } // 发送普通邮件 public void sendSimpleMailMessage(String to, String subject, String content) { SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(SENDER); message.setTo(to); message.setSubject(subject); message.setText(content); mailSender.send(message); } // 发送带附件的邮件 public void sendMimeMessage(String to, String subject, String content, String filePath) throws MessagingException { MimeMessage message = mailSender.createMimeMessage(); // true表示需要创建一个multipart message MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(SENDER); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource file = new FileSystemResource(new File(filePath)); String fileName = file.getFilename(); helper.addAttachment(fileName, file); mailSender.send(message); } } 四、编写验证码生成器 传入参数为验证码长度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class VerifyCodeGenerator { public static String make(int length) { if (length \u0026lt;= 0) { throw new RuntimeException(\u0026#34;验证码长度不能小于1\u0026#34;); } StringBuilder sb = new StringBuilder(); Random random = new Random(); for (int i = 0; i \u0026lt; length; i++) { sb.append(random.nextInt(10)); } return sb.toString(); } } 五、Controller编写 接受用户输入的邮箱，并向该邮箱发送一个验证码；\n检验用户输入的验证码，如果正确则放行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @RestController @RequestMapping(\u0026#34;/verify\u0026#34;) public class VerifyTest { private MailService mailService; @Autowired public void setMailService(MailService mailService) { this.mailService = mailService; } @PostMapping(\u0026#34;/login/{email}/{code}\u0026#34;) public String login(@PathVariable String email, @PathVariable String code, HttpSession session) { if (StringUtils.isEmpty(email) || StringUtils.isEmpty(code)) { return \u0026#34;false\u0026#34;; } String trueCode = (String)session.getAttribute(\u0026#34;code\u0026#34;); if (code.equals(trueCode)) { return \u0026#34;success\u0026#34;; } else { return \u0026#34;fail\u0026#34;; } } @PostMapping(\u0026#34;/{email}\u0026#34;) public String verify(@PathVariable String email, HttpSession session) { if (StringUtils.isEmpty(email)) { return \u0026#34;false\u0026#34;; } String code = VerifyCodeGenerator.make(6); session.setAttribute(\u0026#34;code\u0026#34;, code); mailService.sendSimpleMailMessage(email, \u0026#34;Email Verify\u0026#34;, \u0026#34;Your code: \u0026#34; + code); return email; } } From My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/06/springboot-mailbox-service/","tags":["springboot"],"title":"SpringBoot 邮箱服务"},{"categories":["Language"],"contents":"一、添加注解 主启动类添加@EnableScheduling注解；\n二、添加依赖： 1 2 3 4 5 \u0026lt;!--定时任务 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-quartz\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 三、创建任务 /TestTask1.java\n1 2 3 4 5 6 7 public class TestTask1 extends QuartzJobBean { @Override protected void executeInternal(JobExecutionContext context) { SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); System.out.println(\u0026#34;Test1---\u0026#34; + sdf.format(new Date())); } } /TestTask2.java\n1 2 3 4 5 6 7 public class TestTask2 extends QuartzJobBean { @Override protected void executeInternal(JobExecutionContext context) { SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); System.out.println(\u0026#34;Test2---\u0026#34; + sdf.format(new Date())); } } 四、配置任务 /QuartzConfig.java\n注意同组下同名任务不会重复执行。\nJobDetail：配置任务信息，生成任务 Trigger：配置触发器信息，设置时间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Configuration public class QuartzConfig { @Bean public JobDetail testJ1() { return JobBuilder.newJob(TestTask1.class).withIdentity(\u0026#34;job1\u0026#34;, \u0026#34;group\u0026#34;).storeDurably().build(); } @Bean public JobDetail testJ2() { return JobBuilder.newJob(TestTask2.class).withIdentity(\u0026#34;job2\u0026#34;, \u0026#34;group\u0026#34;).storeDurably().build(); } // \u0026#34;job2\u0026#34;如果为\u0026#34;job1\u0026#34;，则不会执行TestTask2而是执行TestTask1 @Bean public Trigger test1() { SimpleScheduleBuilder ssb = SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(59).repeatForever(); return TriggerBuilder.newTrigger().forJob(testJ1()) .withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;group\u0026#34;) .withSchedule(ssb) .build(); } @Bean public Trigger test2() { return TriggerBuilder.newTrigger().forJob(testJ2()) .withIdentity(\u0026#34;trigger2\u0026#34;, \u0026#34;group\u0026#34;) .withSchedule(CronScheduleBuilder.cronSchedule(\u0026#34;0/59 * * * * ?\u0026#34;)) .build(); } } From My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/06/quartz-implements-timed-tasks/","tags":["java"],"title":"Quartz 实现定时任务"},{"categories":["OS"],"contents":"一、理论分析 自旋锁，顾名思义，即自己不断旋转重复进行的锁，当多个线程访问同一资源时，为实现互斥访问，必须给目标资源加锁，此时只允许一个线程访问，此时其他线程无法访问，并且一直重复请求访问，直到该锁被释放。访问完资源的线程及时释放锁以供其他资源访问。\n自旋锁可以通过比较替换算法实现：设锁为1时被占用，为0时空闲。当一个线程请求锁时，即进入请求锁循环“spinlock”，设预期值为0，修改值为1，让锁值与预期值比较，若锁值等于预期值，则锁空闲，将锁值置为修改值，退出spinlock循环；若锁值不等于预期值，则证明锁被占用，继续spinlock循环。\n为验证是否成功实现自旋，开启一个释放锁线程，请求锁线程自旋一段时间后，释放锁线程进行锁的释放，即把锁值置为预期值0。此时，请求锁线程成功获得锁并退出spinlock循环。\n二、设计与实现 使用x86_64汇编实现自旋锁：\nIntel语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 尝试获取锁 void lock(long *p) { long a = 0, c = 1; printf(\u0026#34;try to get lock...\\n\u0026#34;); __asm__( \u0026#34;push rax \\n\\t\u0026#34; \u0026#34;push rcx \\n\\t\u0026#34; \u0026#34;spin_lock: \\n\\t\u0026#34; \u0026#34;mov rcx, %[c] \\n\\t\u0026#34; \u0026#34;mov rax, %[a] \\n\\t\u0026#34; // 比较并替换算法，若p==rax==0则获得锁并使p=rcx(==1)，若p(==1)!=rax则进入自旋。 \u0026#34;lock cmpxchg %[p], rcx \\n\\t\u0026#34; \u0026#34;jne spin_lock \\n\\t\u0026#34; \u0026#34;pop rcx \\n\\t\u0026#34; \u0026#34;pop rax \\n\\t\u0026#34; : [p]\u0026#34;+m\u0026#34;(*p) : [a]\u0026#34;r\u0026#34;(a), [c]\u0026#34;r\u0026#34;(c) : \u0026#34;rcx\u0026#34;, \u0026#34;rax\u0026#34; ); } // 释放锁 void unlock(long *p) { __asm__( \u0026#34;mov %[p], 0; \\n\\t\u0026#34; : [p]\u0026#34;+m\u0026#34;(*p) ); } AT\u0026amp;T语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void lock(long *p) { long a = 0, c = 1; printf(\u0026#34;try to get lock...\\n\u0026#34;); __asm__( \u0026#34;pushq %%rax \\n\\t\u0026#34; \u0026#34;pushq %%rcx \\n\\t\u0026#34; \u0026#34;spin_lock: \\n\\t\u0026#34; \u0026#34;movq %1, %%rcx \\n\\t\u0026#34; \u0026#34;movq %2, %%rax \\n\\t\u0026#34; \u0026#34;lock cmpxchg %%rcx, %0 \\n\\t\u0026#34; \u0026#34;jne spin_lock \\n\\t\u0026#34; \u0026#34;popq %%rcx \\n\\t\u0026#34; \u0026#34;popq %%rax \\n\\t\u0026#34; : \u0026#34;+m\u0026#34;(*p) : \u0026#34;r\u0026#34;(c), \u0026#34;r\u0026#34;(a) : \u0026#34;%rcx\u0026#34;, \u0026#34;%rax\u0026#34; ); } void unlock(long *p) { __asm__( \u0026#34;movq $0, %0; \\n\\t\u0026#34; : \u0026#34;+r\u0026#34;(*p) ); } 测试自旋锁 初始化锁值为1，主线程尝试获取锁，进入自旋，子线程在一段时间后释放锁，锁值置为0，接着，主线程获得锁并把锁置为1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // intel语法实现自旋锁 \u0026gt; gcc -pthread -masm=intel -o s spinlock.c // 尝试获取锁 void lock(long *p) { long a = 0, c = 1; printf(\u0026#34;try to get lock...\\n\u0026#34;); __asm__( \u0026#34;push rax \\n\\t\u0026#34; \u0026#34;push rcx \\n\\t\u0026#34; \u0026#34;spin_lock: \\n\\t\u0026#34; \u0026#34;mov rcx, %[c] \\n\\t\u0026#34; \u0026#34;mov rax, %[a] \\n\\t\u0026#34; // 比较并替换算法，若p==rax==0则获得锁并使p=rcx(==1)，若p(==1)!=rax则进入自旋。 \u0026#34;lock cmpxchg %[p], rcx \\n\\t\u0026#34; \u0026#34;jne spin_lock \\n\\t\u0026#34; \u0026#34;pop rcx \\n\\t\u0026#34; \u0026#34;pop rax \\n\\t\u0026#34; : [p]\u0026#34;+m\u0026#34;(*p) : [a]\u0026#34;r\u0026#34;(a), [c]\u0026#34;r\u0026#34;(c) : \u0026#34;rcx\u0026#34;, \u0026#34;rax\u0026#34; ); } // 释放锁 void unlock(long *p) { __asm__( \u0026#34;mov %[p], 0; \\n\\t\u0026#34; : [p]\u0026#34;+m\u0026#34;(*p) ); } // 释放锁线程 void *mythread(void* args) { long* p = (long*) args; // 推迟释放锁，此时自旋在进行中 sleep(2); // 释放锁 unlock(p); printf(\u0026#34;after unlock: %ld\\n\u0026#34;, *p); } int main() { long a = 1; // 设刚开始锁已被获取 long *p = \u0026amp;a; // 开启一个用于释放锁的线程 pthread_t t1; pthread_create(\u0026amp;t1, NULL, mythread, (void*)p); printf(\u0026#34;before lock: %ld\\n\u0026#34;, *p); // 主线程尝试获取 lock(p); pthread_join(t1, NULL); printf(\u0026#34;after lock: %ld\\n\u0026#34;, *p); return 0; } 这里采用intel语法编写的自旋锁进行测试，执行命令gcc -pthread -masm=intel -o s spinlock.c进行编译。\n若采用AT\u0026amp;T，执行命令gcc -pthread -o s spinlock.c进行编译，无需-masm=intel，因为gcc底层默认采用AT\u0026amp;T。\n三、运行结果 运行结果如下：\n1 2 3 4 before lock: 1 try to get lock... after unlock: 0 after lock: 1 一开始锁值为1，请求锁线程（即主线程）请求获得锁，进入自旋。2s后释放锁线程进行锁的释放，接着请求锁线程成功获得锁，锁值又被置为1，成功实现自旋与锁的释放。\nover.\n","permalink":"/posts/2022/06/use-x86-64-assemble-and-write-a-spin-lock/","tags":["assembly","os"],"title":"使用 x86_64 汇编写一个自旋锁"},{"categories":["Tool"],"contents":"使用Wireshark作为抓包工具，通过ftp文件上传过程分析tcp原理，主要分析过程包括三次握手建立连接的过程，文件传输的过程，四次挥手断开连接的过程。\n设备信息 主机：安装了ftp的window11（ip:172.23.224.1） 虚拟机：安装了vsftpd的wsl2（ubuntu18）(ip:172.23.234.65) 操作与分析过程 打开Wireshark进行捕获 选择**vEthernet(WSL)**连接进行捕获。 使用过滤表达式ip.addr==172.23.234.65\u0026amp;\u0026amp;tcp进行捕获。 通过ftp上传文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PS C:\\Users\\akyna\u0026gt; ftp 172.23.234.65 连接到 172.23.234.65。 220 (vsFTPd 3.0.3) 200 Always in UTF8 mode. 用户(172.23.234.65:(none)): akyna 331 Please specify the password. 密码: 230 Login successful. ftp\u0026gt; put a.txt 200 PORT command successful. Consider using PASV. 150 Ok to send data. 226 Transfer complete. ftp: 发送 42 字节，用时 0.00秒 42000.00千字节/秒。 可见已经传输成功。\n对捕获的数据进行分析 回到Wireshark，分析捕获的数据：\n上图已经包括了三次握手建立连接，登录验证，文件传输，四次挥手结束连接这几个主要的过程。\n下面通过生成流量图进行具体分析：\n（一）三次握手建立连接\n第一次握手：client通过6518端口向server发送连接请求，发送SYN和Seq，server在端口21进行监听并接收到请求。\n第二次握手：server监听到请求后发送SYN，ACK和Seq，client接收到回复。\n第三次握手：client接收到恢复后发送Seq（等于刚接收到的Ack的值）和Ack，server接收到并确认Seq正确，完成连接。\n（二）文件传输过程\n首先，还是三次握手在client端口6540和server端口20之间建立连接，这两个端口用于传输数据； 接着，server端口21回复\u0026quot;Response 150 Ok to send data\u0026quot;给client端口6518，含PSH标识，表明可以开始传输数据； 然后，client开始发送数据包，长为42，且含PSH，表示可以接收数据，server接收到后回传的Ack应该加上数据包长，即1+42； 接着，client发送了FIN标识，表明发送完毕，server发送了FIN标识，表明将停止接收，client发送ACK确定server可以停止接收； 最后，client端口6518回复\u0026quot;Response 226 Transfer complete\u0026quot;给server端口21，表明传输完毕。 （三）四次挥手结束连接\n第一次挥手：server发送了FIN标识，向client确认是否可以关闭连接；\n第二次挥手：client接收到FIN，发送ACK，确定server可以关闭连接，这时server确定ACK正确后将进入半关闭态，还可以接收client发送的数据；\n第三次挥手：这次由client发送FIN标识，让server真的关闭连接；\n第四次挥手：server关闭连接，发送ACK向client确认已关闭,，至此，ftp通信完毕。\nover.\n","permalink":"/posts/2022/06/analyze-tcp-principle-through-wireshark/","tags":["tcp"],"title":"通过 Wireshark 分析 TCP 原理"},{"categories":["Book"],"contents":"七个房间 ——黑乙一\n“我小的时候，常在老家旁边的小溪玩耍。”\n据她说那是一条连溪底的石头都看得到的清澈溪流。我听着她的话，想象着犹如梦幻世界一般的那条小溪。摇摇晃晃的水面反射着太阳光，细碎的光芒闪耀着，那是一个非常明亮的世界，头顶万里无云，晴空没有尽头，仿佛自己的身体违反了重力，不断地往上再往上被吸进去似的，无边无际。\n我好像开始习惯被关进的这个阴郁狭窄的水泥房间、从水沟中飘来的腐臭，以及被灯泡一照反而突显的黑暗。我开始忘记进来这里之前所待过的普通世界了。想起外面吹拂着风的世界，我不禁难过起来。\n我想看天空。之前我从未有过如此强烈的渴望，被关进来之前，为什么没有多花些时间好好地眺望云朵呢？\n走过地下走廊，我们看见了一道往上的楼梯。爬到楼梯顶就是阳光灿烂的外面世界了。我们终于逃离了那个昏暗忧郁、被寂寞支配的房间。\n我的眼泪掉个不停。我的脖子上挂着十字架项链，手拿着那本写着向父母道歉文章的记事本。我的手腕上挂着姐姐的遗物——那只手表。因为不是防水的表，大概在我躲进水里的时候坏掉了吧，指针恰好指着傍晚六点，停止了走动。\n向阳之诗 ——白乙一\n我呜咽着继续说道：“……我恨你。”\n为什么要把我制造出来呢？如果我不曾诞生到这个世界喜欢上任何事物，也就不会恐惧“死亡”所带来的别离了。\n虽然我已经几乎泣不成声，躺在工作台上，我还是挤出了这些话：\n“我……很喜欢你，但我却必须埋葬你的遗体，这太痛苦了。如果非得这么痛苦，那我宁可不要心这种东西。我恨你，我恨你在制造我的时候，帮我装了心……”\n窗外传来了鸟鸣。我闭上眼睛，想象着数只鸟儿飞翔在蓝天的画面。合上眼帘，一直在眼眶打转的泪水便落了下来。\n“但现在，我对你只有满满的感谢。如果不曾诞生到这个世界，我就无法看见小丘上辽阔的草原；如果当初你没有为我装上心，我就无法体会望向鸟巢时的愉悦，也不会因为咖啡的苦涩而皱眉了。能够这样一一地去碰触世界的光辉，是多么宝贵的事情啊！一想到这里，即使内心深处因为悲伤而淌着血，我都能够把那视为证明我活着的最最珍贵的证据……”\n同时抱着感谢和憎恨的感情，或许很奇怪吧？然而，我就是这么想的。我相信大家一定都是如此。在很久以前便灭绝的人类的孩子们，对自己的父母一定也是同样怀抱着类似的矛盾情绪活下去的，不是吗？\n我们都是一边学习着爱与死亡，往来于世界的向阳处与阴暗处活下去的，不是吗？\n于是孩子们逐渐成长。这次，将轮到自己背负在这个世界创造出新生命的宿命，不是吗？\n我会在那座小丘上伯父长眠地的旁边掘坑；我会让你睡在里面，像是替你盖上棉被一般为你覆上泥土；我会替你立上木制的十字架，将水井边盛开的花草种在墓前；每天早上我都会去跟你道早安，到了傍晚再去向你报告这一天发生了什么。\n长椅上，时间静静地流逝，正午将近。我耳中听着他体内的马达声逐渐减弱，终至再也听不见。好好安息吧。我在心中轻轻地对他说。\n","permalink":"/posts/2022/06/yi-short-excerpt/","tags":["excerpt"],"title":"乙一短篇摘录"},{"categories":["Book"],"contents":"九月 目击众神死亡的草原上野花一片\n远在远方的风比远方更远\n我的琴声呜咽 泪水全无\n我把这远方的远归还草原\n一个叫马头 一个叫马尾\n我的琴声呜咽 泪水全无 远方只有在死亡中凝聚野花一片\n明月如镜高悬草原映照千年岁月\n我的琴声呜咽 泪水全无\n只身打马过草原\n晨雨时光 小马在草坡上一跳一跳\n这青色麦地晚风吹拂\n在这个时刻 我没有想到\n五盏灯竟会同时亮起\n青麦地像马的仪态 随风吹拂\n五盏灯竟会一盏一盏地熄灭\n往后 雨会下到深夜 下到清晨\n天色微明\n山梁上定会空无一人\n不能携上路程\n当众人齐集河畔 空声歌唱生活\n我定会孤独返回空无一人的山峦\n西藏 西藏，一块孤独的石头坐满整个天空\n没有任何夜晚能使我沉睡\n没有任何黎明能使我醒来\n一块孤独的石头坐满整个天空\n他说：在这一千年里我只热爱我自己\n一块孤独的石头坐满整个天空\n没有任何泪水使我变成花朵\n没有任何国王使我变成王座\n面朝大海，春暖花开 从明天起，做一个幸福的人\n喂马，劈柴，周游世界\n从明天起，关心粮食和蔬菜\n我有一所房子，面朝大海，春暖花开\n从明天起，和每一个亲人通信\n告诉他们我的幸福\n那幸福的闪电告诉我的\n我将告诉每一个人 给每一条河每一座山取一个温暖的名字\n陌生人，我也为你祝福\n愿你有一个灿烂的前程\n愿你有情人终成眷属\n愿你在尘世获得幸福\n我只愿面朝大海，春暖花开\n","permalink":"/posts/2022/05/haizis-poems/","tags":["poem"],"title":"海子的诗"},{"categories":["Book"],"contents":"作者：乔治·奥威尔\n第6章 温斯顿把手垂到身边，缓慢地将肺部又吸满空气，他的大脑滑向一个双重思想的迷宫世界。知道又不知道；明白全部事实，却说着精心编造的谎言；\n同时拥有两种针锋相对的意见，一方面知道两者之间的矛盾，一方面又两者都相信；\n利用逻辑来反逻辑；\n一方面批判道德，一方面又自认为有道德；\n相信不可能有民主，另一方面又相信党是民主的保卫者；\n忘掉一切需要忘记的，然后随时在需要记起时再回想起来，接着马上再忘掉——最重要的是，对这个过程本身，也要照此处理。\n最奥妙之处在于：要清醒地诱导自己进入不清醒状态，然后再次意识不到刚刚对自己实行的催眠行为。\n甚至理解“双重思想”这个词，也要用到双重思想。\n第10章 除非他们觉醒，否则永远不会反抗；但除非他们反抗，否则不会觉醒。\n第12章 一定要捍卫显而易见、质朴和真实的一切，不言而喻的就是真实的，在这一点上不可动摇！\n实体世界是存在的，其定律不可改变。石头是硬的，水是湿的，缺少支撑的物体会向地心方向坠落。\n怀着这种感觉，他是在向奥布兰说话，同时也在提出一条重要的公理。\n他写道：自由就是说二加二等于四的自由。若此成立，其他同理。\n第19章 温斯顿在床上又待了几分钟。房间内正在变暗，他往光亮处挪了一点，盯着看那块玻璃镇纸。它让人百看不厌之处，不是珊瑚，而是玻璃内部。它很厚，但又几乎像空气一样透明。那块玻璃的表面像天空的穹顶，包容了一个小小的世界，各种特点无不具备。他感觉能够进入其中，而实际上他已经身处其中，跟那张红木床、折叠桌还有钢雕版画及镇纸本身一起都在其中。镇纸就是他所在的房间，珊瑚是茱莉娅和他自己的生命，被固定在清澈透明的玻璃中心，并成为一种永恒之物。\n第28章 “双重思想”意味着在一个人的脑子里，同时拥有两种相互矛盾的信念，而且两种都接受。党的知识分子明白他的记忆必须往哪个方向改变，因此他知道自己在玩弄现实，然而通过实行“双重思想”，也能让他心安理得地认为现实不曾被改变。\n这个过程一定要有意识地进行，否则过程中精确度就不够；而且它也一定要无意识地进行，否则会带来一种做伪的感觉，因而会有罪过感。\n“双重思想”是英社的核心，因为党最基本的行为，是进行有意识的欺骗，同时又保持目的的坚定性，那需要绝对诚实。讲着别有用心的谎言，同时又真心实意相信这些谎言；忘掉一切变得有碍的行为，然后一旦再次需要，又从遗忘中拣回来；否认客观现实的存在，同时又考虑到被否认的现实——这些都缺一不可。甚至在使用“双重思想”这个词时，也需要进行“双重思想”。因为使用这个词时，是承认在篡改现实，通过再来一次“双重思想”，就会清除这种认识，如此循环不已，谎言总跨在真实的前面。\n最终以“双重思想”为手段，党就能够——我们都明白，可能在几千年内仍然能够——左右历史进程。\n作为少数派，即使是一个人的少数派，也并不能说明你疯了。世界上存在着真理和非真理，如果你坚守的是真理，即使要跟整个世界对抗，你也不会是疯的。正在下沉的夕阳把一缕黄色光线从窗户斜射进来，照在枕头上。他闭上眼睛，照在脸上的阳光和挨着他的那个女孩的光滑躯体给了他一种强烈的、催人欲睡的、自信的感觉。他是安全的，一切正常。他嘴里咕哝着“理智不是个统计学概念”就睡着了，他觉得这句话蕴藏了深刻的智慧。\n第29章 每个人来说，天空都是同样的天空，无论在欧亚国或者东亚国或者这里。天空下的人们也几乎完全一样——在所有地方，包括全世界，有着上亿跟这里一样的人们，他们对彼此的存在一无所知，被仇恨和谎言之墙所隔，但仍然几乎完全一样。他们从未学会思考，但正是在他们的心里、肚子里和肌肉里，储备着某一天将推翻这个世界的力量。如果有希望，它就在群众身上！\n","permalink":"/posts/2022/05/1984-abstracts/","tags":["excerpt"],"title":"《1984》文摘"},{"categories":["Language"],"contents":"JDK JRE JVM 关系 为什么说 Java 语言“编译与解释并存”？ 高级编程语言按照程序的执行方式分为编译型和解释型两种。\n编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码，不能跨平台。\n解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行，一次编写，到处执行。\nJava 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤。\n由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须再经过 JVM，解释成操作系统能识别的机器码，在由操作系统执行。\n因此，我们可以认为 Java 语言编译与解释并存。\n重载（overload）和重写（override）的区别？ 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。\n重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；\n重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。\n方法重载的规则：\n方法名一致，参数列表中参数的顺序，类型，个数不同。 重载与方法的返回值无关，存在于父类和子类，同类中。 可以抛出不同的异常，可以有不同修饰符。 抽象类(abstract class)和接口(interface)有什么区别？ 接口的方法默认是public，所有方法在接口中不能有实现(Java8开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。\n接口中除了static、final变量，不能有其他变量，而抽象类中则不⼀定。\n⼀个类可以实现多个接口，但只能实现⼀个抽象类。接口自己本身可以通过extends关键字扩展多个接口。\n接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰）。\n从设计层面来说，抽象是对类的抽象，是⼀种模板设计，而接口是对行为的抽象，是⼀种行为的规范。\n注意jdk7~jdk9中接口的变化：\n在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。 jdk 8 的时候接口可以有默认方法和静态方法功能。 jdk 9 在接口中引⼊了私有方法和私有静态方法 try和finally中的return 若try中有return，而finally中无return，会先将值暂存，无论finally语句中对该值做什么处理，最终返回的都是try语句中的暂存值。另外，finally语句中执行的语句先于try的return之前执行。\n当try与finally语句中均有return语句，会忽略try中return，执行finally的return。注意如果try的return语句是return ++x，则++x是会执行的。\n验证如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class TryReturnTest { public int test1(int x) { try { x += 1; return ++x; } catch (Exception e) { e.printStackTrace(); } finally { x += 5; System.out.println(\u0026#34;finally\u0026#34;); } return x; } public int test2(int x) { try { x += 1; return ++x; } catch (Exception e) { e.printStackTrace(); } finally { x += 5; System.out.println(\u0026#34;finally\u0026#34;); return x; } } public static void main(String[] args) { TryReturnTest test = new TryReturnTest(); System.out.println(test.test1(0)); // finally 2 System.out.println(test.test2(0)); // finally 7 } } String 和 StringBuilder、StringBuffer 的区别？ String：String 的值被创建后不能修改，任何对 String 的修改都会引发新的 String 对象的生成。 StringBuffer：跟 String 类似，但是值可以被修改，使用 synchronized 来保证线程安全。 StringBuilder：StringBuffer 的非线程安全版本，性能上更高一些。 在Java8 时JDK 对“+”号拼接进行了优化，String间通过\u0026quot;+\u0026ldquo;来拼接的方式会被优化为基于 StringBuilder 的 append 方法进行处理。Java 会在编译期对“+”号进行处理。\n关于Integer 实例引入 1 2 3 4 5 6 7 8 9 10 11 public static void main(String[] args) { Integer a = 127; Integer b = 127; Integer b1 = new Integer(127); System.out.println(a == b); //true System.out.println(b == b1); //false Integer c = 128; Integer d = 128; System.out.println(c == d); //false } 解释如下：\nInteger a = 127 这种赋值，是用到了 Integer 自动装箱的机制。自动装箱的时候会去缓存池里取 Integer 对象，没有取到才会创建新的对象。\n如果整型字面量的值在-128 到 127 之间，那么自动装箱时不会 new 新的 Integer 对象，而是直接引用缓存池中的 Integer 对象，超过范围a1 == b1的结果是 false。\n理解Integer缓存 因为根据实践发现大部分的数据操作都集中在值比较小的范围，因此 Integer 搞了个缓存池，默认范围是 -128 到 127，可以根据通过设置JVM-XX:AutoBoxCacheMax=来修改缓存的最大值，最小值改不了。\n实现的原理是 int 在自动装箱的时候会调用Integer.valueOf，进而用到了IntegerCache。\nInteger.valueOf就是判断下值是否在缓存范围之内，如果是的话去 IntegerCache 中取，不是的话就创建一个新的 Integer 对象。\nIntegerCache 是一个静态内部类， 在静态块中会初始化好缓存值。\n1 2 3 4 5 6 7 8 9 private static class IntegerCache { …… static { //创建Integer对象存储 for(int k = 0; k \u0026lt; cache.length; k++) cache[k] = new Integer(j++); …… } } BIO、NIO、AIO BIO (blocking I/O): 就是传统的 IO，同步阻塞。\nNIO (non-blocking IO): 同步非阻塞，服务器端用一个线程处理多个连接，客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到连接有 IO 请求就进行处理。NIO 的数据是面向缓冲区Buffer的，必须从 Buffer 中读取或写入。\n每个 Channel 对应一个 Buffer。\nSelector 对应一个线程，一个线程对应多个 Channel。\nSelector 会根据不同的事件，在各个通道上切换。\nBuffer 是内存块，底层是数据。\nAIO：JDK 7 引入了 Asynchronous I/O，是异步不阻塞的 IO。在进行 I/O 编程中，常用到两种模式：Reactor 和 Proactor。Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得到通知，进行相应的处理，完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。 From My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/05/java-review-1/","tags":["java"],"title":"Java 复习记录（一）"},{"categories":["Book"],"contents":"\r“\r飞机一着陆，禁烟显示牌倏然消失，天花板扩音器中低声流出背景音乐，那是一个管弦乐队自鸣得意地演奏的甲壳虫乐队的《挪威的森林》。那旋律一如往日地使我难以自已，不，比往日还要强烈地摇撼着我的身心。\n《挪威的森林》—— Norwegian Wood “\r她一边这样说着，一边弹起《米歇尔》，弹得极其精彩。\r“好曲子，我，无比喜欢！”说完，玲子喝了一口葡萄酒，吸了口烟，“简直就像霏霏细雨轻轻洒在无边无际的草原。”\n《米歇尔》—— Michelle “\r接着，她弹了《没有归宿的人》，弹了《朱丽娅》。有时边弹边闭上眼摇着头，然后又呷口酒吸口烟。\n《没有归宿的人》—— Nowhere Man 《朱丽娅》—— Julia “\r店里的女孩说，如果肯弹甲壳虫乐队的《太阳从这里升起》，冷藏牛奶可算店里请客。玲子伸出拇指，做出OK的表示，随即边哼歌词边弹《太阳从这里升起》。音量并不大，而且大概由于过度吸烟的关系，嗓音有些沙哑，但很有厚度，娓娓动人。我喝着啤酒，望着远山，耳听她的歌声，恍惚觉得太阳会再次从那里探出脸来，那心境实在太温馨、太平和了。\n《太阳从这里升起》—— Here Comes The Sun “\r“我也喜爱，非常委婉感人。”她又轻轻弹了几小节《宝贝儿》的旋律，呷了口葡萄酒。“喝醉之前能弹上几首呢。嗯，这样的葬礼不凄凉，还可以吧？”\r玲子转向甲壳虫。弹了《挪威的森林》，弹了《昨日》，弹了《米歇尔》，弹了《有一件事》，边唱边弹了《太阳从这里升起》，弹了《山峰上的傻子》。我排出了七根火柴。\n《昨日》—— Yesterday 《有一件事》—— Something 《山峰上的傻子》—— The Fool On The Hill “\r“七首，”玲子说着，呷口酒，吸口烟。“这几个人对人生的伤感和温情确实深有体会啊。”\r这几个人当然是Ｊ．列农、Ｐ．麦卡特尼，加上Ｇ．哈里森。\r她换了口气，熄掉烟，又抱起吉他。弹了《细雨》，弹了《黑鸟》，弹了《朱莉娅》，弹了《年届六十四》，弹了《没有归宿的人》，弹了《而且我爱她》，弹了《喂，乔德》。\n《细雨》—— Penny Lane 《黑鸟》—— Black Bird 《年届六十四》—— When I\u0026rsquo;m Sixty Four 《而且我爱她》—— And I Love Her 《喂，乔德》—— Hey, Jude “\r我放上唱片，第一张听完便把唱针移到第二张。全部听完之后，又从头听起。唱片只有六张。第一张是《佩珀军士寂寞的心俱乐部乐队》，最后是比尔·埃文斯的《献给黛比的华尔兹》。窗外雨下个不停，时间缓缓流逝，直子一个人絮絮不止。\n《佩珀军士寂寞的心俱乐部乐队》—— Sgt. Pepper\u0026rsquo;s Lonely Hearts Club Band ","permalink":"/posts/2022/05/the-beatles-in-norwegian-forest/","tags":["music"],"title":"《挪威的森林》中的披头士"},{"categories":["Book"],"contents":"作者：哈珀·李\n第十一章 “勇敢就是，在你还没开始的时候就知道自己注定会输，但依然义无反顾地去做，并且不管发生什么都坚持到底。一个人很少能赢，但也总会有赢的时候。杜博斯太太赢了，全凭她那九十八磅重的身躯。用她的话来说，她死得无牵无挂，不亏欠任何人，也不依赖任何东西。她是我见过的最勇敢的人。”\n第二十章 “我们都知道，某些人灌输给我们的‘人人生而平等’，实际上是个谬论——事实上，有些人就是比别人聪明睿智，有些人就是比别人享有更多的机会，因为他们生来如此，有些男人比别的男人挣钱多，有些女士做的蛋糕比别的女士更胜一筹——总而言之，有些人天生就比大多数普通人具有更高的天赋和才华。”\n“但是，在这个国家里，从某种意义上来说，一切人是生来平等的——有一种人类社会机构，可以让乞丐和洛克菲勒家族的成员平起平坐，让愚人和爱因斯坦不分尊卑，让粗陋无知的人和大学校长分庭抗礼。先生们，这种机构，就是法庭——可以是美国联邦政府的最高法庭，可以是最基层的地方治安法庭，也可以是你们眼下服务的这个尊贵而神圣的法庭。我们的法庭也有缺陷，任何社会机构都不例外，但是，在这个国家里，我们的法庭是伟大的平等主义者。在我们的法庭里，人人生而平等。”\n第三十一章 我心想，如果是在日光下，从这儿能一眼望到邮局所在的街角。在明亮的日光下……夜晚被我的想象驱散了，现在是大白天，整个街区的人都在忙忙碌碌。斯蒂芬妮小姐正穿过街道，把最新消息告诉雷切尔小姐。莫迪小姐正弯着腰伺弄她心爱的杜鹃花。这是夏天，两个孩子在人行道上连蹦带跳，上前去迎接从远处走来的一个男人。那个男人挥了挥手，于是两个孩子你追我赶，互不相让，朝他一路跑去。\n时间依然是夏天，孩子们走近了。男孩踯躇不前，身后拖着一根鱼竿。男人两手叉腰，站在那里等他。\n还是在夏天，他的孩子们在前院里和朋友一起玩耍，自编自演着一出莫名其妙的小话剧。\n秋天，他的两个孩子在杜博斯太太家门前的人行道上打架。男孩把妹妹从地上扶起来，两人一起走回家去。\n那个秋天，他的两个孩子一路小跑，来来回回经过那个街角，一天的烦恼和欣喜都写在脸上。他们在一棵大橡树跟前停下脚步，脸上闪过惊喜，困惑，还有点儿惶恐不安。\n冬天，他的两个孩子在院门前冻得哆里哆嗦，一座房子在熊熊燃烧，火光映照出他们小小的侧影。\n依然是在冬天，那个男人走上街道，扔下自己的眼镜，开枪射死了一条疯狗。\n又是一个夏天，他眼看着孩子们心碎欲裂。\n又到了秋天，怪人的小伙伴需要他挺身相助。\n阿迪克斯说的没错。有一回他告诉我，你永远也不可能真正了解一个人，除非你穿上他的鞋子走来走去，站在他的角度考虑问题。对我来说，站在拉德利家的前廊上就足够了。\n","permalink":"/posts/2022/05/kill-a-mockingbird-digest-ii/","tags":["excerpt"],"title":"《杀死一只知更鸟》文摘二"},{"categories":["Book"],"contents":"作者：哈珀·李\n第九章 “杰克！看在老天的分上，当一个孩子问你问题的时候，你要正儿八经地回答，不要东拉西扯，顾左右而言他。虽说孩子毕竟只是孩子，但他们会比成人更敏锐地察觉到你在回避问题，回避只会让他们糊里糊涂。”\n父亲沉吟着说道，“今天下午你的回应是对的，但你的理由有偏差。说脏话是所有孩子都会经历的一个阶段，随着他们一天天长大，他们会发现满口脏话并不能让他们成为众人瞩目的明星，他们就会改掉这个毛病。但是脾气暴躁可不好改。斯库特必须学会保持冷静，接下来的几个月里她还会经历很多事情，所以她必须尽快学会冷静面对。当然，她也在成长。杰姆长大了，她现在也能跟着学学样子。她只是在某些时候需要有人推一把。”\n第十章 阿迪克斯送给我们两杆气枪之后，却不肯教我们如何射击。还是杰克叔叔教给了我们基本要领，他说阿迪克斯对枪压根儿就不感兴趣。有一天，阿迪克斯对杰姆说：“我宁愿让你们在后院射易拉罐，不过我知道，你们肯定会去打鸟。你们射多少冠蓝鸦都没关系，只要你们能打得着，但要记住一点，杀死一只知更鸟便是犯罪。”\n杰姆说：“我觉得，如果他想让我们知道，早就告诉我们了。如果他以此为豪，早就跟我们说了。”\n“也许他只是没想起来。”\n“不是，斯库特。这个你不懂。阿迪克斯确实老了，不过，即使他什么也做不来我也不在乎———他一件事儿都做不来我也不在乎。” 杰姆捡起一块石头朝车库扔去，一副喜不自胜的样子。他欢跳着追了过去，又回头冲我喊道：“阿迪克斯是个绅士，跟我一样！”\n第十一章 “哦，大多数人好像都认为他们是对的，你是错的……”\n“他们当然有权利那样想，他们的看法也有权得到充分的尊重，” 阿迪克斯说，“但是，我在接受他人之前，首先要接受自己。有一种东西不能遵循从众原则，那就是人的良心。”\n“斯库特，”阿迪克斯说，“‘同情黑鬼的人’只是一种毫无意义的称呼，跟‘鼻涕虫’一样。这很难解释清楚——有些愚昧无知的人认为有人关爱黑人胜过关爱他们，就用这个词来称呼。这个词不知不觉也成了和我们一样的普通人的日常用语，用来给人打上卑贱、丑陋的标签。”\n“那你并不真的是‘同情黑鬼的人’，对吗？”\n“我当然同情黑人。我尽自己所能去爱每一个人……有时候我也很为难——宝贝儿，如果别人把那当成一个侮辱性的字眼来骂你，并不能贬损你的人格。那只能让你看到，骂你的人有多可悲，他的谩骂并不能伤害到你。所以别让杜博斯太太影响你的情绪。她自己的麻烦事儿已经够多的了。”\n","permalink":"/posts/2022/05/kill-a-mockingbird-digest-1/","tags":["excerpt"],"title":"《杀死一只知更鸟》文摘一"},{"categories":["Book"],"contents":"作者：毛泽东\n战争问题中的唯心论和机械论的倾向，是一切错误观点的认识论上的根源。他们看问题的方法是主观的和片面的。或者是毫无根据地纯主观地说一顿；或者是只根据问题的一侧面、一时候的表现，也同样主观地把它夸大起来，当作全体看。\n革命战争是一种抗毒素，它不但将排除敌人的毒焰，也将清洗自己的污浊。凡属正义的革命的战争，其力量是很大的，它能改造很多事物，或为改造事物开辟道路。\n中日战争将改造中日两国；只要中国坚持抗战和坚持统一战线，就一定能把旧日本化为新日本，把旧中国化为新中国，中日两国的人和物都将在这次战争中和战争后获得改造。我们把抗战和建国联系起来看，是正当的。说日本也能获得改造，是说日本统治者的侵略战争将走到失败，有引起日本人民革命之可能。日本人民革命胜利之日，就是日本改造之时。这和中国的抗战密切地联系着，这一个前途是应该看到的。\n这就是所谓“唯武器论”，是战争问题中的机械论，是主观地和片面地看问题的意见。我们的意见与此相反，不但看到武器，而且看到人力。武器是战争的重要的因素，但不是决定的因素，决定的因素是人不是物。力量对比不但是军力和经济力的对比，而且是人力和人心的对比。军力和经济力是要人去掌握的。\n政治是不流血的战争，战争是流血的政治。\n错觉和不意，可以丧失优势和主动。因而有计划地造成敌人的错觉，给以不意的攻击，是造成优势和夺取主动的方法，而且是重要的方法。错觉是什么呢？ “八公山上，草木皆兵”，是错觉之一例。“声东击西”，是造成敌人错觉之一法。\n在优越的民众条件具备，足以封锁消息时，采用各种欺骗敌人的方法，常能有效地陷敌于判断错误和行动错误的苦境，因而丧失其优势和主动。“兵不厌诈”，就是指的这件事情。什么是不意？就是无准备。优势而无准备，不是真正的优势，也没有主动。懂得这一点，劣势而有准备之军，常可对敌举行不意的攻势，把优势者打败。\n我们说运动之敌好打，就是因为敌在不意即无准备中。这两件事——造成敌人的错觉和出以不意的攻击，即是以战争的不确实性给予敌人，而给自己以尽可能大的确实性，用以争取我之优势和主动，争取我之胜利。\n","permalink":"/posts/2022/04/abstract-of-on-protracted-war/","tags":["excerpt"],"title":"《论持久战》文摘"},{"categories":["Book"],"contents":"第十一章 在辗转反侧的不眠之夜，我想起直子的种种音容笑貌，不容我不想起。因为我心里关于直子的记忆堆积如山，只要稍稍开启一点缝隙，它们便争先恐后，鼓涌而出，而我根本无法遏止其突发的攻势。\n就是这样，直子的形象如同汹涌而来的潮水向我联翩袭来，将我的身体冲往奇妙的地带。在这奇妙地带里，我同死者共同生活。直子也在这里活着，同我交谈，同我拥抱。在这个地方，所谓死，并非是使生完结的决定性因素，而仅仅是构成生的众多因素之一。直子在这里仍在含有死的前提下继续生存，并且对我这样说：“不要紧，渡边君，那不过是一死罢了，别介意。”\n木月死时，我从他的死中学到一个道理，并将其作为大彻大悟的人生真谛铭刻或力图铭刻在心。那便是：“死并非生的对立面，死潜伏在我们的生之中。”\n实际也是如此。我们通过生而同时培育了死，但这仅仅是我们必须懂得的哲理的一小部分。而直子的死还使我明白：无论谙熟怎样的哲理，也无以消除所爱之人的死带来的悲哀。无论怎样的哲理，怎样的真诚，怎样的坚韧，怎样的柔情，也无以排遣这种悲哀。\n我们惟一能做到的，就是从这片悲哀中挣脱出来，并从中领悟某种哲理。而领悟后的任何哲理，在继之而来的意外悲哀面前，又是那样软弱无力——我形影相吊地倾听这暗夜的涛声和风鸣，日复一日地此冥思苦索。我喝光了几瓶威士忌，啃着面包，喝着水筒里的水，满头沙子，背负旅行背囊，踏着初秋的海岸不断西行、西行。\n这是初秋一个天朗气清的午后——同恰好一年前我去京都探望直子时一模一样。云如枯骨，细细白白，长空寥廓，似无任何遮拦。又是一个秋天，我想。风的气息，光的色调，草丛中点缀的小花，一个音节留下的回响，无不告知我秋天的到来。四季更迭，我与死者之间的距离亦随之渐渐拉开。木月照旧十七，直子依然二十一，永远地。\n“假如你对直子的死怀有一种类似创痛之感，那么就把这种创痛留给以后的人生，在整个后半生中去体会。如若可以学习到什么，那就要从中学习。不过绿子另当别论，你要和她去寻求幸福。你的创痛与绿子无关。如果你还要伤她的心，势必导致无可挽回的后果。因此，尽管你可能心里难受，也还是要坚强起来，要再成熟一些，成为大人。我就是为了对你说这番话，才特意从疗养院跑来这里——大老远地坐着那棺材样的电车。”\n我给绿子打去电话，告诉她：自己无论如何都想跟她说话，有满肚子话要说，有满肚子非说不可的话。整个世界上除了她别无他求。想见她想同她说话，两人一切从头开始。 绿子在电话的另一头久久默然不语，如同全世界所有的细雨落在全世界所有的草坪上一般的沉默在持续。这时间里，我一直合着双眼，把额头顶在电话亭玻璃上。\n良久，绿子用沉静的声音开口道：“你现在哪里？”\n我现在哪里？\n我拿着听筒扬起脸，飞快地环视电话亭四周。我现在哪里？我不知道这里是哪里，全然摸不着头脑。这里究竟是哪里？目力所及，无不是不知走去哪里的无数男男女女。我在哪里也不是的场所的正中央，不断地呼唤着绿子。\n","permalink":"/posts/2022/04/norwegian-forest-digest-4/","tags":["excerpt"],"title":"《挪威的森林》文摘四"},{"categories":["Language"],"contents":"进程相关 tasklist tasklist用于查看运行的进程 findstr相当于linux的grep 1 2 3 4 PS C:\\Users\\akyna\u0026gt; Tasklist | findstr Code Code.exe 19184 Console 1 94,012 K Code.exe 19300 Console 1 26,324 K ...... taskkill 使用该工具按照进程 ID (PID) 或映像名称终止任务。\n参数列表:\n/PID processid 指定要终止的进程的 PID。 /IM imagename 指定要终止的进程的映像名称。 /T 终止指定的进程和由它启用的子进程。 /F 指定强制终止进程。 /? 显示帮助消息。 e.g.\n1 2 3 TASKKILL /IM notepad.exe TASKKILL /PID 1230 /PID 1241 /PID 1253 /T TASKKILL /F /IM cmd.exe /T 网络相关 ipconfig 执行网卡相关操作\n1 2 3 4 5 $ ipconfig # 查看网卡信息，如ip地址 $ ipconfig /all # 查看mac地址 $ ipconfig /displaydns # 查看dns缓存内容 $ ipconfig /flushdns # 清除dns缓存 ping 测试本机与指定机器是否联通\n1 2 3 $ ping jingyan.baidu.com $ ping -t jingyan.baidu.com # ping 1000万次 $ ping -n 10 jingyan.baidu.com # ping 指定次数 netstat 该命令用于显示协议统计信息和当前 TCP/IP 网络连接。\n一般使用方式：\n1 netstat -ano 命令解释：\n1 2 3 4 -a 显示所有连接和侦听端口。 -n 以数字形式显示地址和端口号。 -o 显示拥有的与每个连接关联的进程 ID。 -r 显示路由表。 注意-t和-u并不是只列出tcp和udp的意思。\n1 2 -t 显示当前连接卸载状态。 没有-u命令。 ","permalink":"/posts/2022/04/process-and-network-control-of-window-practical-command-recording/","tags":["windows","powershell","cmd"],"title":"Window 实用命令记录之进程与网络控制"},{"categories":["Book"],"contents":"第十章 一九六九年这一年，总是令我想起进退两难的泥沼——每迈一步都几乎把整只鞋陷掉那般的滞重而深沉的泥沼。而我就在这片泥沼中气喘吁吁地挪动脚步，前方一无所见，后面渺无来者，只有昏暗的泥沼无边无际地延展开去。甚至时光都随着我的步调而流淌得十分吃力。身边的人早已经遥遥领先，惟独我和我的时间在泥沼中艰难地往来爬行。\n我四周的世界则面临一切沧桑巨变。约翰·科尔特兰死了，还有很多人死了。人们在呼喊变革，仿佛变革正在席卷每个角落。然而这些无一不是虚构的毫无意义的背景画面而已。我则几乎没有抬头，日复一日地打发时光。在我眼里，只有漫无边际的泥沼。往前落下右脚，拔起左脚，再拔起右脚。我判断不出我位于何处，也不具有自己是在朝正确方向前进的信心。我之所以一步步挪动步履，只是因为我必须挪动，而无论去哪里。\n下午过去，黄昏来临，继而隐隐泛青的夜色笼罩了院落。“海鸥”早已不见踪影。我又开始观看樱花。在我眼里，春夜里的樱花，宛如从开裂的皮肤中鼓胀出来的烂肉，整个院子都充满烂肉那甜腻而沉闷的腐臭气味。我转而想起直子的裸体。直子娇美的裸体横陈在夜色之中，无数植物的嫩芽从其肌肤中争相萌出，在天外来风的吹拂下，鲜绿的幼芽轻轻摇颤不止。我想，那般巧夺天工的肢体为什么非生病不可呢？他们为什么不肯放直子一条生路呢？\n“我倒想拿出精神来。”\n“你把人生当做饼干罐就可以了。”\n我摇了几下头，看着绿子的脸说：“可能是我脑筋迟钝的关系，有时捉摸不透你说的什么。”\n“饼干罐不是装有各种各样的饼干，喜欢的和不大喜欢的都在里面吗？如果先一个劲儿挑你喜欢的吃，那么剩下的就全是不大喜欢的。每次遇到麻烦我就总这样想：先把这个应付过去，往下就好办了。人生就是饼干罐。”\n“倒也是一种哲理。”\n对于只身独处的人来说，四月实在是不胜凄寂的时节。四月里，周围的人无不显得满面春风。人们脱去外套，在明媚的阳光下或聊天，或练习棒球，或卿卿我我。我却孑然一身，形影相吊。直子也好，绿子也好，永泽也好，所有的人都远远离我而去。现在的我，连问一声“早安”或“你好”的人都没有。甚至对敢死队我都有些怀念。我就这样在无可排遣的孤独中送走了四月。\n我爱过直子，如今仍同样爱她。但我同绿子之间存在的东西带有某种决定性，在她面前我感到一股难以抗拒的力量，并且恍惚觉得自己势必随波逐流，被迅速冲往遥远的前方。在直子身上，我感到的是娴静典雅而澄澈莹洁的爱，而绿子方面则载然相反——它是立体的，在行走在呼吸在跳动，在摇撼我的身心。\n就我个人感情而言，绿子倒像是个非常可贵的女孩。你为她倾心这点，从信上也看得一清二楚；而你对直子的一片痴情，我也了然于心。这并非什么罪过，只不过是大千世界里司空见惯之事。在风和日丽的天气里荡舟于美丽的湖面，我们会既觉得蓝天迷人，又深感湖水多娇——二者同一道理。不必那么苦恼。纵令听其自然，世事的长河也还是要流往其应流的方向，而即使再竭尽人力，该受伤害的人也无由幸免。所谓人生便是如此。这样说未免大言不惭——你也差不多到了学习这种人生方式的年龄。有时候你太急于将人生纳入自己的轨道。假如你不想进精神病院，就要心胸豁达地委身于生活的河流。就连我这样孱弱而不健全的女人，有时都觉得人生是多么美好。真的！所以，你也务必加倍追求幸福，为追求幸福而努力。\n","permalink":"/posts/2022/04/norwegian-forest-digest-iii/","tags":["excerpt"],"title":"《挪威的森林》文摘三"},{"categories":["Book"],"contents":"作者：太宰治\n第三章 心里没着没落，感觉好像无所凭依，似乎怎么也活不下去了——这就是所谓的不安心情吧。胸口仿佛一阵阵痛苦的浪潮在拍打、涌来，就好像黄昏时分骤雨初歇，而后天空匆匆掠过一片片白云似的，使我心脏忽而收紧，忽而松弛，脉搏失常无规律，呼吸也变得困难，眼前发黑，全身的力气仿佛从十指尖上溜掉了一样，毛线都打不下去。\n第四章 我在第一封信里曾经提到过我心中飘过的彩虹，这道彩虹并不像萤光或者星光那样高尚和美丽，假如是那样淡淡而幽远的话，我就不会这样痛苦，甚至能够逐渐将您忘掉了。我心中的彩虹是一座火焰之桥，我的思念几乎要将我的心都烧焦了。\n第五章 这人世仿佛与我所想象的人世完全不同，是一个不可言喻的奇怪世界，我似乎被人孤零零地弃之旷野，任凭我呐喊呼叫，四下却听不见任何回应。这就是所谓的失恋？\n","permalink":"/posts/2022/04/setting-sun-abstract/","tags":["excerpt"],"title":"《斜阳》文摘"},{"categories":["Book"],"contents":"作者：村上春树\n第七章 “见不到你固然是痛苦的，但倘若没有你，我在东京的生活将更不堪忍受。正因为一清早我就在床上想你，我才下决心拧紧发条，自强不息地生活下去。如同你在那边自强不息一样，我在这里也必须自强不息。”\n嘈杂的周日街头使我的心头舒展开来。我在通勤电车一般拥挤不堪的纪伊国屋书店里买了一本福克纳的《八月之光》，然后挑一家听起来声音开到尽可能大的爵士酒吧走进去，一边听奥内特·科尔曼和巴顿·帕维尔洛的唱片，一边喝又热又不好喝的咖啡，翻看刚买的书。五点半时，合上书，出门吃了简单的晚饭。我不由心想：这样的星期日以后将重复几十次、几百次吧？“安静的、平和的、孤独的星期日”——我出声说道。星期日我是不上发条的。\n第八章 打桌球时居然未想起木月，这使我感到似乎做了一件对不起他的事。当时我觉得自己巳将他彻底忘在脑后，然而夜里返回宿舍，我开始这样想道：那以后已经过去了两年半，而他依然十七岁。但这并不意味他在我的记忆中已渐趋淡薄，他的死带来的东西依然鲜明地留在我的脑海里，有的反而比当时还要鲜明。我即将满二十岁，我同木月在十六岁和十七岁那两年里所共有的东西的某部分早已消失得无影无踪，无论怎样长吁短叹，都已无法挽回——我无法表达得更为确切，但我觉得对于我的感受、我想要表达的，你是会充分理解的，而且能理解此事的恐怕也只有你一个人。\n我比以前任何时候都更仔细地思考你的问题。今天在下雨，下雨的星期天多少使我有些惶惶然。因为下雨不能洗衣服，自然也不能熨衣服。既不能散步，又不能在天台上东倒西歪。只好坐在桌前，一边用自动反复唱机周而复始地听《温柔的蓝》，一边百无聊赖地观望院子的雨中景致。以前我也写过，星期天我是不上发条的，因此信也就写得很长很长。不再写了，这就去食堂吃午饭。再见。\n第九章 “最最喜欢你，绿子。”\n“什么程度？”\n“像喜欢春天的熊一样。”\n“春天的熊？”绿子再次扬起脸，“什么春天的熊？”\n“春天的原野里，你一个人正走着，对面走来一只可爱的小熊，浑身的毛活像天鹅绒，眼睛圆鼓鼓的。它这么对你说道：‘你好，小姐，和我一块儿打滚玩好么？’接着，你就和小熊抱在一起，顺着长满三叶草的山坡咕噜咕噜滚下去，整整玩了一大天。你说棒不棒？”\n“太棒了。”\n“我就这么喜欢你。”\n","permalink":"/posts/2022/04/norwegian-forest-digest-ii/","tags":["excerpt"],"title":"《挪威的森林》文摘二"},{"categories":["Book"],"contents":"作者：高野和明\n第三章 调查 人在正义的名义下审判另一个人的时候，所谓的正义并不存在普遍的标准。\n犯罪所破坏的并不仅仅是眼睛看得到的东西，而是深深地侵入人们心中，破坏了人们心中最根本的东西。 而且，人们将被这个根本性的伤害长久地困扰。\n第四章 过去 但是，如果这个社会认可私刑，社会就会陷于无秩序状态。因此，必须由第三者，也就是国家机器行使刑罚权，来代替被害人亲属做他们想做的事。是人都有复仇心，所谓复仇心，就是对失去的人的爱。只要法律是为了人类而存在的，包括死刑在内的报应刑思想就应该被认可。\n第六章 处以被告人死刑 法律这个东西，常常有被权力一方恣意滥用的危险。\n","permalink":"/posts/2022/04/excerpt-from-the-lost-thirteen-steps/","tags":["excerpt"],"title":"《消失的十三级台阶》摘录"},{"categories":["Book"],"contents":"作者：村上春树\n第一章 即使在经历过十八度春秋的今天，我仍可真切地记起那片草地的风景。连日温馨的霏霏细雨，将夏日的尘埃冲洗无余。片片山坡叠青泻翠，抽穗的芒草在十月金风的吹拂下蜿蜒起伏，逶迤的薄云紧贴着仿佛冻僵的湛蓝的天穹。凝眸望去，长空寥廓，但觉双目隐隐作痛。清风抚过草地，微微拂动她满头秀发，旋即向杂木林吹去。树梢上的叶片簌簌低语，狗的吠声由远而近，若有若无，细微得如同从另一世界的入口处传来。此外便万籁俱寂了。耳畔不闻任何声响，身边没有任何人擦过。只见两只火团样的小鸟，受惊似的从草丛中腾起，朝杂木林方向飞去。\n当然，只要有时间，我总会忆起她的面容。那冷冰冰的小手，那流线型泻下的手感爽适的秀发，那圆圆的软软的耳垂以及紧靠其底端的小小黑痣，那冬日常穿的格调高雅的驼绒大衣，那总是定定地注视对方眼睛发问的惯常动作，那不时奇妙地发出的微微颤抖的语声（就像在强风中的山冈上说话一样）随着这些印象的叠涌，她的面庞突然而自然地浮现出来。最先现出的是她的侧脸。大概因为我总是同她并肩走路的缘故，最先想起来的每每是她的侧影。随之，她朝我转过脸，甜甜地一笑，微微地歪头，轻轻地启齿，定定地看着我的双眼，仿佛在一泓清澈的泉水里寻觅稍纵即逝的小鱼的行踪。\n第二章 到得东京，住进寄宿舍开始新生活时，我要做的仅有一件事，那就是对任何事物都不想得过于深刻，对任何事物都保持一定距离。什么敷有绿绒垫的桌球台呀，红色的N360车呀，课桌上的白花呀，我决定一古脑儿把它们丢到脑后。还有火葬场高大烟囱中腾起的烟，警察署询问室中呆头呆脑的镇纸，也统统一扫而光。起始几天，进行得似乎还算顺利。但不管我怎么努力忘却，仍有一团恍若薄雾状的东西残留不走，并且随着时间的推移，雾状的东西开始以清楚而简洁的轮廓呈现出来。那轮廓我可以诉诸语言，那就是： 死并非生的对立面，而作为生的一部分永存。\n第四章 我看看绿子的眼睛，绿子也看看我的眼睛。我搂过她的肩，吻住她的嘴。绿子只是肩头稍微抖动了一下，旋即软绵绵地闭上眼睛。约有五六秒，我们悄无声息地对着嘴唇，初秋的阳光把她的眼睫毛映在脸颊上，看上去在微微发颤。\n那是一个温柔而安稳的吻，一个不知其归宿的吻。假如我们不在午后的阳光中坐在晾衣台上喝着啤酒观看火灾的话，那天我恐怕不至于吻绿子，而这一心情恐怕绿子也是相同的。我们从晾衣台上久久地望着光闪闪的房脊、烟和红脑袋蜻蜓，心情不由变得温煦、亲密起来，在无意中想以某种形式将其存留下来，于是我们接了吻，就是这种类型的吻。当然，正像所有的接吻一样，我们的接吻也不是说不包含某种危险。\n第六章 之后，玲子弹了几支勃萨诺瓦舞曲。这时间里，我端详着直子。如她自己信上写的那样，她显得比以前健康，晒黑了不少，由于锻炼和野外作业，体型紧绷绷的。那湖水一般深邃澄澈的眸子和羞涩似的嗫嚅着的小嘴唇倒是和以前一样，但整个看来，她的娇美已开始带有成熟女性的风韵。往日她那娇美中时隐时现的某种锐气—— 使人为之颤栗的刀刃般的锐气—— 已经远远遁去，转而荡漾着一种给人以亲切抚慰之感的独特的娴静。我为这样的娇美而怦然心动，同时又有些感到惊愕：不过半年时间，一个女人居然会有如此明显的变化。直子这富有新意的娇美确实一如往日或甚于往日，使我为之倾心，为之痴迷。尽管如此，一想到她所失却的东西，我还是不无遗憾。那思春期少女所特有的，或者不妨称之为独往独来、我行我素的潇洒，在她身上已经一去不复返了。\n沐浴着柔和月光的直子身体，宛似刚刚降生不久的崭新肉体，柔光熠熠，令人不胜怜爱。每当她稍微动一下身子—— 虽然是瞬间微动 ——月光照射的部位便微妙地滑行开来，遍布身体的阴影亦随之变形。浑圆鼓起的乳房，小小的乳头，小坑般的肚脐，构成腰骨和阴毛的粗粒子阴影，这些都恰似静静的湖面上荡漾开来的水纹一样改变着形状。这是何等完美的肉体啊 ——我想。直子是何时开始拥有如此完美的肉体的呢？那个春夜我所拥抱的她的肉体何处去了呢？\n","permalink":"/posts/2022/04/norwegian-forest-digest-1/","tags":["excerpt"],"title":"《挪威的森林》文摘一"},{"categories":["Book"],"contents":"作者：三浦紫苑\n第四章. 纪录赛登场 “看了你这三个月来的表现，我越来越相信自己没看错人，”\n清濑接着说，“你很有天分，也很有潜力。所以呢，阿走，你一定要更相信自己，不要急着想一飞冲天。变强需要时间，也可以说它永远没有终点。长跑是值得一生投入的竞赛，有些人即使老了，仍然没有放弃慢跑或马拉松运动。”\n阿走体内那股跑步的热情，就像一团无以名状的强烈情绪，经常在他心中掀起纷扰的涟漪。但清濑的一席话，却无比炙热地烙进他朦胧幽暗、彷徨无措的内心世界，宛如曙光乍现，照亮阿走心中每一个角落。\n第九章. 奔向彼方 清濑曾经说过的“强”，或许就是这个意思。\n不论个人赛或驿传，跑步需要具备的强韧，在本质上是永远不会改变的。　那是再怎么痛苦也要向前进的一种力量，以及持续与自己战斗的勇气，也是不只着眼于眼睛看得到的纪录、更要一次又一次超越自我极限的毅力。\n第十章. 流星 就物理观点来看，大家都跑在同一条赛道上。\n然而，每个人到达的境界却各有不同，借由跑步找到属于自己的终点。\n跑者们总是不断在思考、迷惘、犯错，然后再重新来过。\n尾声 ——阿走，你喜欢跑步吗？　四年前春天的夜里，清濑这样问阿走。就像一脸纯真的孩子在问，人为什么要活在这世上。　——我很想知道，跑步的真谛究竟是什么。　我也是，灰二哥，我也想知道，虽然我一直在跑，但现在我还是不知道这个问题的答案。直到现在，我跑步时都仍会思考这个问题，今后也会不停问自己。　我真的很想知道。　所以，让我们一起跑吧，跑到天涯海角。　信念发出的光芒，永远存在我们心里。在黑暗中照亮延伸向前的道路，清楚地为我们指引方向。\n","permalink":"/posts/2022/04/strong-wind-blowing-abstract/","tags":["excerpt"],"title":"《强风吹拂》文摘"},{"categories":["Book"],"contents":"作者：东野圭吾\n第四章. 听着披头士默祷 人与人之间的关系往往不是因为某些具体的原因而断绝。 不，即使表面上有种原因，其实是因为彼此的心已经不在一起，事后才牵强附会地找这些借口。 因为，如果彼此的心没有分开，当发生可能会导致彼此关系断绝的事态时，某一方就会主动修复。 之所以没有人主动修复，就是因为彼此的心已经不在一起了。\n第五章. 来自天上的祈祷 你的地图是一张白纸，所以，即使想决定目的地，也不知道路在哪里。 地图是白纸当然很伤脑筋，任何人都会不知所措。 但是，不妨换一个角度思考，正因为是白纸，所以可以画任何地图，一切都掌握在你自己手上。你很自由，充满了无限可能。这是很棒的事。 我衷心祈祷你可以相信自己，无悔地燃烧自己的人生。 这可能是我最后一次针对烦恼谘商进行回答，谢谢你在最后提供了我这么出色的难题。\n","permalink":"/posts/2022/04/jieyou-grocery-store-abstract/","tags":["excerpt"],"title":"《解忧杂货店》文摘"},{"categories":["Life"],"contents":"山的记忆 每一座山都有独特的感觉，每一座山都有自己的故事。\n我和踏过的每一座山都有一段故事。\n我的山脉游览录，记录那些年那些山。\n南五台 南五台位于西安南长安区境内约30公里的秦岭北麓，海拔1688米，为秦岭终南山中段的一个支脉。\n因山上有清凉、文殊、舍身、灵应、观音五个台，也就是山上的五个小峰（即五个山峰），故名五台山；且与西安北部耀县的五台山（药王山）以南而得名。\n登山的体验感相当不错，较为轻松，当天也是蓝天白云，清风拂面，一切都很好。\n百二邱田 景区地处“生态公益林保护区”和“三坑水资源保护区”之间，背靠崎岭头，面对铁山峰，龙盘虎距，狮象朝拱，钟山鼓山对峙，巨石天然，石洞幽深；清泉涓涓，曲径幽幽，山松谷竹，桃红李素，四时山花烂漫，处处佳果硕累。\n依稀记得这是一个清晨时的山顶：\n景区内的藏莲寺历史悠久，创建于明朝隆庆4年（公元1571年），距今已有430多年，建有慈悲娘殿、三圣殿、地藏阁、珍秀阁、半天娘殿、南天门伯公庙等宗教建筑。\n白云密密麻麻的：\n华山 华山，古称“西岳”，雅称“太华山”，为五岳之一，位于陕西省渭南市华阴市，在省会西安以东120千米处。南接秦岭山脉，北瞰黄渭，自古以来就有“奇险天下第一山”的说法。\n悬崖绝壁，崎岖嶙峋。\n当时去的时候，天气不是很好，不是很好的登山时间。不过幸运的是我在山雨来临之前就下山了，赶上了一班缆车，之后不久缆车好像就停运了。\n对弈亭，颇具仙外境之感。\n铁山 铁山 ，又名铁尖山、铁嶂；清乾隆十年（公元1745年）《普宁县志》载：铁山，以崖石俱作铁色，故名”。\n铁山属孤立山脉，东、西、南三面是练江流域平原，北面绵延与广太镇大坪山紧接，方圆62平方公里，是广东省普宁市中部平原地区的一座小山脉。\n这是家乡的一座高山，记得当时好像在山上迷路了。\n翠华山 翠华山，位于陕西省西安市长安区太乙宫镇，系终南山的一个支峰，位于秦岭北麓，距西安市区20千米，主峰终南山海拔2604米，总面积32平方千米。\n因汉武帝曾在这里祭祀过太乙神，故又名太乙山。山腰有翠华庙，内供翠华姑娘塑像。民间传说翠华姑娘为争取自由婚姻，逃奔这里，后来成仙而去，此山便得名翠华山。\n寒假时前去游览，这也是我第一次爬雪山。\n一只孤独的鸟飞了过去。\n这是天池附近的山，优雅的池子和静谧的山。\n","permalink":"/posts/2022/03/mountain-tour-1/","tags":["life","journey"],"title":"山脉游览录（一）"},{"categories":["Tool"],"contents":"主机配置防火墙入站规则 主机如果没开启防火墙则可以跳过这一步。\n进入防火墙管理界面，新建入站规则放通目标虚拟机系统IP即可。\n选择桥接模式 默认好像是NAT模式，改为桥接模式，指定网卡为当前主机网络的网卡，我的是“Realtek PCIe.GBE Family Controller”。\n我的主机网络网关是 192.168.1.1，子网掩码为 255.255.255.0，IP为 192.168.1.126，我想配置虚拟机网络IP为 192.168.1.127 或者 192.168.1.128。\nUbuntu配置静态IP 通过netplan的方法进行，编辑 /etc/netplan/00-installer-config.yaml如下：\n1 2 3 4 5 6 7 8 9 10 network: ethernets: enp0s3: dhcp4: no optional: no nameservers: addresses: [114.114.114.114, 8.8.8.8] gateway4: 192.168.1.1 addresses: [192.168.1.128/24] version: 2 然后执行 sudo netplan apply即可。\nCentOS配置静态IP 找到当前网络下网卡名，然后编辑/etc/sysconfig/network-scripts下的ifcfg-{网卡名}文件如下：\n1 2 3 4 5 6 7 BOOTPROTO=\u0026#34;static\u0026#34; # 静态IP IPADDR=192.168.1.127 # IP NETMASK=255.255.255.0 # 子网掩码 GATEWAY=192.168.1.1 # 网关 DNS1=114.114.114.114 DNS2=8.8.8.8 ONBOOT=yes 之后再重启网络服务即可：\n1 systemctl restart network From my blog: akynazh.\nOver.\n","permalink":"/posts/2022/02/configure-the-network-to-realize-the-interworking-between-host-and-virtual-machine-system/","tags":["network","linux"],"title":"配置网络以实现主机和虚拟机系统互通"},{"categories":["Web"],"contents":"前言 开发web项目时，常常需要在前端展示一些交互性的数据，比如表单填写错误的提示，操作成功与否的提示等。\n本文主要讲述在使用Thymeleaf作为模板引擎开发前端时，即在前后端不分离的情况下，前后端进行交互性数据展示的实现方法。\n使用cookie传递数据：不推荐 一、步骤 后端通过addCookie方法设置值 前端在页面加载时读取cookie值并进行展示 前端删除该cookie值 二、缺陷 这个方法我使用过，但是效果并不好，原因如下：\n用户可能禁止cookie 后端如果有重定向操作将导致cookie添加失败 前端每次都要删除cookie，有时可能会失效 使用session传递数据：值得借鉴 一、步骤 后端往session中存入数据 前端通过${session}进行获取数据并展示 前端将该数据删除或修改为指定默认值 这里注意正常情况下js是无法操作或者访问session值的，我们可以通过thymeleaf内置脚本进行操作：\n1 2 3 \u0026lt;script th:inline=\u0026#34;javascript\u0026#34;\u0026gt; // 这里可以通过session访问值 \u0026lt;/script\u0026gt; 二、缺陷 这个方法不好的地方显而易见，我们每次都要删除session值，而且只能通过内置脚本的方式操作，很不方便。\n但是这种方法的思想值得借鉴，请看如下方法。\n通过RedirectAttributesModelMap传递数据 注意这里后端采用SpringMVC。\n一、步骤 通过RedirectAttributesModelMap往model中存值 返回视图对象，在视图对象中通过thymeleaf内置脚本进行数据展示 二、示例：提醒用户首先进行登录 1、后端代码： 1 2 3 4 5 @GetMapping(\u0026#34;/loginFirst\u0026#34;) public String loginFirst(RedirectAttributesModelMap model) { model.addFlashAttribute(\u0026#34;msg\u0026#34;, \u0026#34;请先进行登录\u0026#34;); return \u0026#34;redirect:/\u0026#34;; } RedirectAttributesModelMap可以确保redirect后保存在model中数据不丢失\naddFlashAttribute是把数据临时放在session中并在刷新页面后自动删除的方法，配合RedirectAttributesModelMap进行使用\n2、前端代码： 必须注意，这里外部js无法通过$(\u0026rsquo;#msg\u0026rsquo;).val()获取th:value设置的值的，所以必须通过thymeleaf提供的内联js代码操作交互的数据。\n1 2 3 4 5 6 \u0026lt;div class=\u0026#34;alert\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;input id=\u0026#34;msg\u0026#34; value=\u0026#34;\u0026#34; style=\u0026#34;display: none\u0026#34;/\u0026gt; \u0026lt;script th:inline=\u0026#34;javascript\u0026#34;\u0026gt; let msg = [[${msg}]]; document.getElementById(\u0026#34;msg\u0026#34;).setAttribute(\u0026#34;value\u0026#34;, msg.toString()); \u0026lt;/script\u0026gt; 这里可以在inline部分完成所有信息展示操作，但由于thymeleaf内联js无法调用jquery代码，所以我把msg存到隐藏域中，再通过jquery代码调用\n1 2 3 4 5 6 $(document).ready(function () { let msg = $(\u0026#39;#msg\u0026#39;).val(); if (msg !== \u0026#39;\u0026#39; \u0026amp;\u0026amp; msg != null) { $(\u0026#39;.alert\u0026#39;).html(msg).addClass(\u0026#39;alert-info\u0026#39;).show().delay(1500).fadeOut(); } }) 3、提示信息的css代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* 触发方式: $(\u0026#39;.alert\u0026#39;).html(\u0026#34;errorMsg\u0026#34;).addClass(\u0026#39;alert-info\u0026#39;).show().delay(1500).fadeOut();*/ .alert { display: none; position: fixed; top: 10%; left: 50%; min-width: 150px; margin-left: -100px; z-index: 99999; padding: 15px; border: 1px solid transparent; border-radius: 5px; } .alert-info { color: white; text-align: center; font-family: \u0026#34;Times New Roman\u0026#34;, SansSerif, sans-serif; background-color: black; background-image: linear-gradient(to bottom, gray, black); border-color: black; } 三、评价 这个方法原理同上一个方法，都是通过session进行数据访问，只不过springmvc为我们封装好了好用的操作方法而已。\n需要避过的坑有：\nRedirectAttributesModelMap必须与addFlashAttribute结合使用 无法通过外部js访问th:value设置的值，需要通过thymeleaf内联js进行操作或将数据保存到隐藏域中再进行外部js的操作 总结 本文主要介绍在前后端不分离的情况下进行交互性数据展示的实现方法，有点麻烦，容易出错，这也让我再次意识到前后端分离的必要性！\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2022/02/implementation-method-of-interactive-data-display-without-separation-of-front-and-back-ends/","tags":["springboot","web"],"title":"在前后端不分离的情况下进行交互性数据展示的实现方法"},{"categories":["Life"],"contents":"身处繁杂的社会生活 现代社会，是一个信息爆炸的时代，是一个充满无尽焦虑的时代，是一个繁杂的时代。\n在离不开网络的世界里，我们难以摆脱网络上各种信息的侵扰，参差不齐的信息爬满了我们的心房。\n在竞争相当激烈的当代社会，我们变得更加焦虑，思绪更加杂乱。\n在难以融入的群体中，我们常常迷失了方向而变得无所适从。\n想摆脱这一切，然而生活不给我们机会。\n想要生活下去，必须适应这一切。\n我想从这里面找到一种优美的平衡。\n我想要在复杂里面寻找简洁，在焦虑中寻求冷静，在内卷中寻求内心的平衡，在群体中找到自我的位置。\n我眼中的简洁美 事物的简洁不是简单的整洁，不等同于简单。\n简洁，是让丰富而复杂的东西妥协，一步步削减繁琐的次要的东西，经过仔细的权衡之后留下最为重要的东西。\n不能是单纯为了简洁而简化一个事物，而同时要为体验感负责，如果为了简洁削减了更重要的东西，那么就不能称得上是简洁，而是单纯沦为简单。\n简洁的事物是能够让自己长久地认同的，简洁是一种趋近于内心深处的东西。\n我热衷于寻求属于自己的简洁，在不断地追求这种简洁的过程中，我发现只有真正遵循于自己内心深处认同感的那种简洁，才会较为长久地留下。\n也就是说，必须努力让自己冷静地，真正沉下心去寻求自己的简洁。\n寻求自己的简洁 孤独 孤独的生活无需在意太多眼光与言语，尽可能地遵循自己内心的需求。\n孤独的感觉是自由的感觉，没有太多的约束感。\n孤独的时间让我们安静，让我们思考，而不是被无意义的言语和噪音淹没。\n而身处群体中，我们无法时刻保持孤独，人类始终是摆脱不了群体。\n所以，需要寻求平衡，在必须融入团体的时候应该自然地融入，去学习，去发挥作用。\n生活中，要懂得去探寻属于自己的独处时间，以寻求内心的安静，去反思生活，思考人生。\n合适 世界上不存在两片完全相同的叶子，每个人都是独一无二的。\n适合自己的，让内心的繁杂感减轻，让自己自然地接受那种节奏，简洁的味道就出现了。\n我们需要思考什么样的生活是适合自己的，什么样的生活节奏是自己可以自然地接受的。\n身处竞争激烈的大环境，我认为内卷不是必须的，但努力是必要的，把握好生活的节奏是很重要的。\n需要摆脱无尽的焦虑感，但也不是完全摆脱，需要保留一定的焦虑感以换取前进的动力。\n如果改变不了社会，就改变自己吧，但绝不是单纯地依旧社会的要求去要求自己。\n持续寻找与思考简洁 简洁的思想，启发我去寻找答案。\n所有让人觉得不舒服的地方，都可以算是不简洁的，因为没有从中剔除掉多余的东西并保留下对自己有价值的东西。\n我应该遵循自己的内心去面对这一切，在日常生活中寻求自己的简洁美。\n","permalink":"/posts/2022/02/the-beauty-of-simplicity/","tags":["thinking","life"],"title":"简洁之美"},{"categories":["Language"],"contents":"持续更新中。\nBufferedWriter 无法正确写出问题 这是一段客户端代码，向服务器端发送消息，然后接收服务器端的回复：\n1 2 3 4 5 6 7 8 9 10 11 12 13 try ( BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())) ) { String message; while((message = stdIn.readLine()) != null) { out.write(message); out.flush(); System.out.println(\u0026#34;Receive from server: \u0026#34; + in.readLine()); } } catch (Exception e) { System.out.println(e.getMessage()); } 这是服务端代码的一部分，接收客户端消息，并向客户端回复：\n1 2 3 4 5 6 7 8 9 10 11 12 13 try ( BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())) ) { String message; while((message = in.readLine()) != null) { System.out.println(Thread.currentThread().getName() + \u0026#34;: receive from port \u0026#34; + socket.getPort() + \u0026#34;: \u0026#34; + message); out.write(message); out.flush(); } } catch (Exception e) { System.out.println(e.getMessage()); } 这里两端都使用了 BufferedReader 和 BufferedWriter 作为消息的传输工具。\n经过测试发现，消息传输是失败的。\n问题出现在 out.write(message); 和 message = in.readLine() 这两个地方，因为 in.readLine() 读取的是一行数据，即数据必须要存在换行符，如果不存在的话将无法读完，一直处于阻塞状态。\n所以，解决方法就是将写出的数据通过 newLine 操作加上换行符：\n1 2 out.write(message); // 如果使用BufferedWriter，则需要添加换行符 out.newLine(); 另一种更好的方法是使用 PrintWriter，使用它的写出操作 println 进行消息的输出。\nFrom my blog: akynazh.\nOver.\n","permalink":"/posts/2022/01/record-of-bugs-encountered-in-java-development/","tags":["java","bug"],"title":"Java 开发中遇到的 bug 记录"},{"categories":["OS"],"contents":"添加用户 1 2 3 4 5 6 7 8 9 [root@VM-0-11-centos ~]# useradd jzh [root@VM-0-11-centos /]# id jzh uid=1000(jzh) gid=1000(jzh) groups=1000(jzh) [root@VM-0-11-centos /]# grep jzh /etc/passwd /etc/shadow /etc/group /etc/passwd:jzh:x:1000:1000::/home/jzh:/bin/bash /etc/shadow:jzh:!!:18980:0:99999:7::: /etc/group:jzh:x:1000: x指代密码，对应到shadow中，未设定即为“!!”\n设置密码 在进行useradd后密码还未设定。\n1 2 3 4 5 6 [root@VM-0-11-centos /]# passwd jzh Changing password for user jzh. New password: BAD PASSWORD: The password is shorter than 8 characters Retype new password: passwd: all authentication tokens updated successfully. 若要让用户第一次能通过默认密码登录得上，并提示用户必须修改密码：\n1 2 3 4 5 [root@VM-0-11-centos /]# useradd vbird [root@VM-0-11-centos /]# echo \u0026#34;658766\u0026#34; | passwd --stdin vbird Changing password for user vbird. passwd: all authentication tokens updated successfully. [root@VM-0-11-centos /]# chage -d 0 vbird # -d接最近一次需要修改密码的时间 使用vbird用户登录：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 vbird@101.34.217.138\u0026#39;s password: You are required to change your password immediately (root enforced) Last login: Mon Dec 20 00:04:51 2021 from 113.200.174.13 WARNING: Your password has expired. You must change your password now and login again! # 提示需要修改密码 # 修改密码 Changing password for user vbird. Changing password for vbird. (current) UNIX password: New password: Retype new password: passwd: all authentication tokens updated successfully. 添加群组与加入群组 1 2 3 4 5 6 7 8 9 [root@VM-0-11-centos ~]# groupadd testgroup [root@VM-0-11-centos ~]# gpasswd testgroup Changing the password for group testgroup New Password: Re-enter new password: [root@VM-0-11-centos ~]# gpasswd -A vbird testgroup [root@VM-0-11-centos ~]# grep testgroup /etc/group /etc/gshadow /etc/group:testgroup:x:1002: /etc/gshadow:testgroup:$1$9v24LYZE$V/yYwmmoaKNpe9.zCPK3U.:vbird: 可见vbird已经加入该群组\n通过ACL设置专有权限 团队开发时，由于原有权限无法满足需求，通常需要对某些成员设置专有权限。\nsetfacl\u0026amp;getfacl -m 设置后续acl参数给文件使用 -x 删除后续acl参数 -R 递归设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [root@VM-0-11-centos tmp]# touch acl # 针对用户 [root@VM-0-11-centos tmp]# setfacl -m u:jzh:rx acl # 为jzh用户设置专有权限 # 针对群组 [root@VM-0-11-centos tmp]# setfacl -m g:testgroup:rwx acl [root@VM-0-11-centos tmp]# getfacl acl # file: acl # owner: root # group: root user::rw- user:jzh:r-x group::r-- group:testgroup:rwx mask::rwx other::r-- 登录 1 2 su - # 使用root登录 su - jzh # 使用jzh登录 ","permalink":"/posts/2021/12/permission-management-of-linux-practical-operation/","tags":["linux"],"title":"Linux 实用操作之权限管理"},{"categories":["Web"],"contents":"事务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 127.0.0.1:6379\u0026gt; multi # 开启事务 OK 127.0.0.1:6379\u0026gt; set book java QUEUED 127.0.0.1:6379\u0026gt; get book QUEUED 127.0.0.1:6379\u0026gt; exec # 执行事务 1) OK 2) \u0026#34;java\u0026#34; 127.0.0.1:6379\u0026gt; get book \u0026#34;java\u0026#34; 127.0.0.1:6379\u0026gt; multi OK 127.0.0.1:6379\u0026gt; set name peter QUEUED 127.0.0.1:6379\u0026gt; discard # 取消事务 OK 127.0.0.1:6379\u0026gt; exec (error) ERR EXEC without MULTI 127.0.0.1:6379\u0026gt; get name (nil) 获取key 获取指定key 1 keys * # 获取所有key 1 keys pattern # 根据pattern获取key 1 2 3 4 - * 代表匹配任意字符 - ? 代表匹配一个字符 - [] 代表匹配部分字符，例如[1,3]代表匹配1和3，而[1-10]代表匹配1到10的任意数字。 - x 转移字符，例如要匹配星号，问号需要转义的字符 e.g.\n1 2 3 4 5 6 7 8 127.0.0.1:6379\u0026gt; keys * 1) \u0026#34;book\u0026#34; 2) \u0026#34;mkeys\u0026#34; 3) \u0026#34;zset\u0026#34; 4) \u0026#34;mkey\u0026#34; 127.0.0.1:6379\u0026gt; keys m* 1) \u0026#34;mkeys\u0026#34; 2) \u0026#34;mkey\u0026#34; 获取key信息 1 2 3 4 5 6 7 127.0.0.1:6379\u0026gt; keys * 1) \u0026#34;book\u0026#34; 2) \u0026#34;mkeys\u0026#34; 3) \u0026#34;zset\u0026#34; 4) \u0026#34;mkey\u0026#34; 127.0.0.1:6379\u0026gt; dbsize # 获取key数量 (integer) 4 删除key 1 2 3 4 127.0.0.1:6379\u0026gt; flushall # 删除所有数据库所有key OK 127.0.0.1:6379\u0026gt; keys * (empty list or set) 1 flushdb # 删除当前数据库所有key redis数据库数量是固定的：\n1 2 3 127.0.0.1:6379\u0026gt; config get databases 1) \u0026#34;databases\u0026#34; 2) \u0026#34;16\u0026#34; # 共16个数据库 发布和订阅 开启一个redis-cli:\n1 2 3 4 5 127.0.0.1:6379\u0026gt; subscribe news Reading messages... (press Ctrl-C to quit) 1) \u0026#34;subscribe\u0026#34; 2) \u0026#34;news\u0026#34; 3) (integer) 1 再开启一个redis-cli:\n1 2 3 4 5 PS C:\\Users\\akyna\u0026gt; redis-cli 127.0.0.1:6379\u0026gt; publish news \u0026#34;hello\u0026#34; (integer) 1 127.0.0.1:6379\u0026gt; publish news \u0026#34;world\u0026#34; (integer) 1 在第一个的redis-cli中接收到订阅的消息：\n1 2 3 4 5 6 7 8 9 10 11 127.0.0.1:6379\u0026gt; subscribe news Reading messages... (press Ctrl-C to quit) 1) \u0026#34;subscribe\u0026#34; 2) \u0026#34;news\u0026#34; 3) (integer) 1 1) \u0026#34;message\u0026#34; 2) \u0026#34;news\u0026#34; 3) \u0026#34;hello\u0026#34; 1) \u0026#34;message\u0026#34; 2) \u0026#34;news\u0026#34; 3) \u0026#34;world\u0026#34; ","permalink":"/posts/2021/12/redis-learning-record-ii/","tags":["redis","database"],"title":"Redis 学习记录二"},{"categories":["Web"],"contents":"Open, Connect And Config open redis: 1 redis-server connect to redis: 1 redis-cli disconnect: 1 redis-cli shutdown show chinese: 1 redis-cli --raw connect to remote redis: 1 redis-cli -h host -p port -a password get redis config: 1 config get {config_name} Data Type list:\n1 2 3 lpush clist redis lpush clist mysql lrange clist 0 100 key:\n1 2 3 4 5 6 7 8 127.0.0.1:6379\u0026gt; set mkey sos OK 127.0.0.1:6379\u0026gt; get mkey \u0026#34;sos\u0026#34; 127.0.0.1:6379\u0026gt; del mkey (integer) 1 127.0.0.1:6379\u0026gt; get mkey (nil) keys: 接偶数个参数，一一对应。\n1 2 3 4 127.0.0.1:6379\u0026gt; hmset mkeys A a B b C c OK 127.0.0.1:6379\u0026gt; hget mkeys B \u0026#34;b\u0026#34; set:\n1 2 3 4 5 6 127.0.0.1:6379\u0026gt; sadd mkey 123 (integer) 1 127.0.0.1:6379\u0026gt; sadd mkey 123 (integer) 0 127.0.0.1:6379\u0026gt; smembers mkey 1) \u0026#34;123\u0026#34; sorted_set: 根据分数和字典序进行排序，同分数下比较字典序，不同分数时，分数越低越靠前。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 127.0.0.1:6379\u0026gt; zadd zs 1 ak (integer) 1 127.0.0.1:6379\u0026gt; zadd zs 1 to (integer) 1 127.0.0.1:6379\u0026gt; zrangebyscore zs 0 100 1) \u0026#34;ak\u0026#34; 2) \u0026#34;to\u0026#34; 127.0.0.1:6379\u0026gt; zadd zs 1 redis (integer) 1 127.0.0.1:6379\u0026gt; zrangebyscore zs 0 100 1) \u0026#34;ak\u0026#34; 2) \u0026#34;redis\u0026#34; 3) \u0026#34;to\u0026#34; 127.0.0.1:6379\u0026gt; zadd zs 0 pp (integer) 1 127.0.0.1:6379\u0026gt; zrangebyscore zs 0 100 1) \u0026#34;pp\u0026#34; 2) \u0026#34;ak\u0026#34; 3) \u0026#34;redis\u0026#34; 4) \u0026#34;to\u0026#34; Password的设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 PS C:\\Users\\akyna\u0026gt; redis-cli 127.0.0.1:6379\u0026gt; config get requirepass 1) \u0026#34;requirepass\u0026#34; 2) \u0026#34;\u0026#34; 127.0.0.1:6379\u0026gt; config set requirepass 12345 OK 127.0.0.1:6379\u0026gt; config get requirepass (error) NOAUTH Authentication required. 127.0.0.1:6379\u0026gt; auth 12345 # 进行密码验证 OK 127.0.0.1:6379\u0026gt; config get requirepass 1) \u0026#34;requirepass\u0026#34; 2) \u0026#34;12345\u0026#34; # 发现已经有密码咯 127.0.0.1:6379\u0026gt; exit PS C:\\Users\\akyna\u0026gt; redis-cli 127.0.0.1:6379\u0026gt; auth 12345 OK 127.0.0.1:6379\u0026gt; config get requirepass 1) \u0026#34;requirepass\u0026#34; 2) \u0026#34;12345\u0026#34; 如果重启server密码会失效。\n一般在Linux下主机重启后需要重新配置一下密码。\n可以修改redis.conf文件，设置密码:\n1 requirepass ${password} 以后通过下面命令：\n1 redis-server redis.conf 进行服务重新启动时的配置，这样可以在服务开启时同时指定密码。\n","permalink":"/posts/2021/12/redis-learning-record-i/","tags":["redis","database"],"title":"Redis 学习记录一"},{"categories":["Tool"],"contents":"git初次拉取远程仓库 首先从github建立一个仓库，获取仓库地址url，然后进入项目所在文件夹，运行以下代码：\n1 2 3 4 5 6 7 8 9 \u0026gt; git init # 初始化仓库，生成.git文件 \u0026gt; git add . # 将项目文件的修改信息添加到.git内的一个暂存区（index） \u0026gt; git commit -m “init” # 将暂存区的修改信息提交到分支 \u0026gt; git remote add origin ${url} # 添加远程仓库 \u0026gt; git push origin master # 将本地分支推送到远程仓库 这里执行完 git commit -m \u0026quot;init\u0026quot; 后，我们查看一下本地分支信息：\n1 2 \u0026gt; git branch * master 可见git自动为我们本地创建了一个master分支。\n执行完 git push origin master 后，我们查看一下本地分支与远程分支的映射关系：\n1 2 3 4 5 6 \u0026gt; git branch -a * master remotes/origin/master \u0026gt; git branch -vv * master 3a31f4c init 可见并没有产生映射。\n所以如果直接使用 git push 提交代码会报错，因为 git 不知道你要提交到哪个远程分支。\ngit映射关系 建立映射关系的方法：\n1 2 3 git branch -u origin/dev_r 将当前分支 dev_r 与远程分支 origin 建立映射关系 git branch -vv 查看分支映射关系 如果建立了映射关系，那么以后在当前分支 git push 时默认 push 到与当前分支建立关系的那个远程分支。\n实际操作：\n运行以下指令：\n1 2 3 4 \u0026gt; git branch -u origin/master Branch \u0026#39;master\u0026#39; set up to track remote branch \u0026#39;master\u0026#39; from \u0026#39;origin\u0026#39;. \u0026gt; git branch -vv * master 3a31f4c [origin/master] init 即可看见产生了映射关系。\nFrom my blog: akynazh.\nOver.\n","permalink":"/posts/2021/12/git-quick-initialization-operation/","tags":["git"],"title":"Git 快速初始化操作"},{"categories":["Language"],"contents":"关于char[]与char*的区别 1 2 3 4 char s1[] = \u0026#34;abc\u0026#34;; cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; // abc s1[1] = \u0026#39;d\u0026#39;; // 改变值 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; // adc \u0026ldquo;abc\u0026quot;为字符串常量，s1为指针常量，即指针是一个常量，所以指向地址不能改变，指向地址的值可变\n1 2 3 4 const char* s2 = \u0026#34;abc\u0026#34;; // const是默认存在的 cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; // abc s2 = \u0026#34;dfs\u0026#34;; // 改变地址 cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; // dfs \u0026ldquo;abc\u0026quot;为字符串常量，s2为常量指针，指向地址可变，但指向的地址的值不能变\n以上两者皆可用于函数传值\n1 2 3 4 5 6 void print_str(const char * str) { printf(\u0026#34;%s\\n\u0026#34;, str); } print_str(s1); // adc print_str(s2); // dfs 关于string和char[],char*的关系 string是类，string是对一个字符串的引用值 1 2 3 4 5 6 7 const char* s1 = \u0026#34;abc\u0026#34;; string s = s1; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // abc s += \u0026#34;a\u0026#34;; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // abca cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; // abc 证明string只是引用了s1 string引用字符串示例 1 2 3 4 5 6 7 const char *s1 = \u0026#34;123\u0026#34;; string str1 = s1; // 若要这样赋值s1必须加const cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; // 123 char s2[] = \u0026#34;234\u0026#34;; string str2 = s2; cout \u0026lt;\u0026lt; str2 \u0026lt;\u0026lt; endl; // 234 string转char* 1 2 3 const char* s1_1 = str1.c_str(); // c_str 转 const char* cout \u0026lt;\u0026lt; s1_1 \u0026lt;\u0026lt; endl; // 123 char*,char[]与int的相互转换 1 2 3 4 5 6 7 8 9 int v1 = atoi(s1); cout \u0026lt;\u0026lt; v1 \u0026lt;\u0026lt; endl; // 123 v1 += 1; char str11[100]; itoa(v1, str11, 10); // 10代表十进制 cout \u0026lt;\u0026lt; str11 \u0026lt;\u0026lt; endl; // 124 // 下面的会失败 // const char* str111; // itoa(v1, str111, 10); // 失败 string与int的相互转换 1 2 3 4 5 6 int val = 223; string str3 = to_string(val); // C++11新特性 只适用于string (char[]和char*不可以) cout \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; // 223 val = stoi(str3, 0, 10); // 0为起始位置 10即十进制 cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; // 223 over.\n","permalink":"/posts/2021/12/understanding-of-char-char-string/","tags":["cpp"],"title":"关于 char*, char[], string 的理解"},{"categories":["OS"],"contents":"使用grep抓取期望的结果 在过去登录主机的人中截取登录信息含root的行信息\n1 last | grep \u0026#39;root\u0026#39; 比较重要，记忆：\ngrep [-acinv] [\u0026ndash;color=auto] \u0026lsquo;搜寻字串\u0026rsquo; filename\n选项与参数：\n-a ：将 binary 文件以 text 文件的方式搜寻数据\n-c ：计算找到 \u0026lsquo;搜寻字串\u0026rsquo; 的次数\n-i ：忽略大小写的不同，所以大小写视为相同\n-n ：顺便输出行号\n-v ：反向选择，亦即显示出没有 \u0026lsquo;搜寻字串\u0026rsquo; 内容的那一行\n\u0026ndash;color=auto ：可以将找到的关键字部分加上颜色的显示喔\nawk命令操作文本 格式化输出：以tab隔开打印前五行中每行的第一和第三个字符 awk \u0026lsquo;{[pattern] action}\u0026rsquo; {filenames}\n1 last -n 5 | awk \u0026#39;{print $1 \u0026#34;\\t\u0026#34; $3}\u0026#39; 注意必须是内双引号外单引号的形式。\n分隔字符 awk -F #-F指定所操作文件中的目标分割字符\n使用\u0026quot;,\u0026ldquo;分隔\n1 awk -F, \u0026#39;{print $1 \u0026#34; - \u0026#34; $2}\u0026#39; log.txt 设置变量 awk -v # 设置变量\n设置变量k等于1\n1 awk -vk=1 \u0026#39;{print $1, $1+k}\u0026#39; log.txt 使用awk脚本 awk -k {awk_script} {file}\n使用my.awk处理log.txt\n1 awk -k my.awk log.txt sed命令操作文本 打印删除了第二到第五行的文本 1 nl /etc/passwd | sed \u0026#39;2,5d\u0026#39; 注：nl可以额外输出行号\n\u0026lsquo;2,$d\u0026rsquo; 匹配删除了第2到最后一行的文本 \u0026lsquo;/root/d\u0026rsquo; 匹配删除了含root的行的文本 a: add\nc: commute\nd: delete\ni: insert\np: print\ns: s/old/new/g\n使用cut处理输出的结果 对以:隔开的结果，输出第三个到第五个\n1 echo $PATH | cut -d \u0026#39;:\u0026#39; -f 3,5 使用sort和uniq处理结果 使用 last 将帐号列出，仅取出帐号栏，进行排序后仅取出一位\n1 last | cut -d \u0026#39; \u0026#39; -f 1 | sort | uniq ","permalink":"/posts/2021/12/text-operation-of-linux-practical-operation/","tags":["linux"],"title":"Linux 实用操作之文本操作"},{"categories":["Language"],"contents":"提出问题 先看一个例子：\n当两个人年龄相同时，我们认为这两个对象相同：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Person { private int age; private String name; public Person(int age, String name) { this.age = age; this.name = name; } @Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;age=\u0026#34; + age + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age; } @Override public int hashCode() { return Objects.hash(age); } } 可以看到上述程序中不但重写了equals()方法，同时重写了hashcode()方法：\n1 2 3 4 @Override public int hashCode() { return Objects.hash(age); } 重写equals最好要重写hashcode()，对需要进行比较的部分字段进行hash()，也就是让值通过一个哈希函数获取到对应的哈希值\n但是为何？如果不重写也是可以顺利比较的。\n原因 其实这样是为了提高程序的效率:\n如果不重写hashcode()的话，可以试想一下，向一个元素个数为10000的集合中插入一个新的元素，就需要对之前的10000个元素进行比较。\n每次比较都要调用一次equals()比较每一个需要比较的字段，可以容易地想象出比较需要花费的时间复杂度是巨大的。\n如果插入元素时，先通过hashcode的寻找可以飞速地判断集合中是否存在一样的元素，在O(1)的时间内可以解决集合插入问题。\n同时重写hashcode()也保证了对象进行equals时，如果为true，其对应的hashcode也一定相等。\n虽然在不涉及集合操作时不重写hashcode()不影响比较，编译运行也不会报错，但是这会违反Java中对象的比较规则。\n总结： 若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值。\n说得简单点就是：如果两个对象相同，那么他们的hashcode应该相等。\n另外，值得注意的是，如果两个对象不相同，他们的hashcode可能相同。\n","permalink":"/posts/2021/11/why-should-java-rewrite-the-hashcode-method-when-rewriting-the-equals-method/","tags":["java"],"title":"Java 重写 equals 方法的同时为什么要重写 hashcode 方法"},{"categories":["Life"],"contents":"跑步的记忆，旧日的时光，思念的味道，生活的无常。\n一. 跑步的挚友 念起中学生活，就会想起那位挚友。\n一同骑行，跑步的挚友。\n相约跑步，无话不谈。\n欢快，笑颜，脚下轻快的风。\n渐渐习惯了跑步。\n我俩都喜欢跑步，也更喜欢骑行。\n休息日，相约骑行。\n去探索，去流汗，去呼吸，去感受脚下的风。\n二. 离开那个地方 结束了吗，那段日子，那段纯真，自在的日子。\n升学，分别，时间悄然流逝\u0026hellip;\u0026hellip;\n和他的联系，不知觉地，越来越少。\n跑步的日子，似乎渐渐离我而去。\n跑步，对我来说意味着什么？\n那段一去不返的时光，那段珍贵无比的岁月。\n人走，茶凉。\n三. 迷恋的感觉 高中，莫名迷上了跑步。\n跑步，带给我的是不一样的感觉。\n是解脱的感觉。\n是在焦虑，迷茫，孤独的生活中，跑步带给我的解脱感。\n跑步呵，跑步，这个孤独，奇妙的运动。\n那清爽的风，那轻快的步。\n那孤独的感觉，那平静的心。\n我在日记记录下了那种感觉。\n四. 跑步时的思考 跑步的时候，有时我也许什么都不想。\n在放空心绪的状态下，感受跑步，感受风的味道。\n也可能我会思考问题。\n孤独的时候，常常会思考一个又一个问题。\n人生，道理，题目，或是一些无意义的事情。\n跑步，这项本质孤独的运动，在我看来，是免不了思考的。\n思考，无疑给跑步带来了更多的乐趣。\n五. 大学的风 敲着键盘，想着往事。\n不知，旧日的朋友现在近况如何？\n大学，还是免不了跑步。\n跑步，又多了许多味道。\n是思念的味道，是怀旧的味道，是寂寞的味道。\n大学的风，来自西北的风，不同于南方的风，有点干燥。\n感觉，一切都变了呢。\n六. 伤痛的感觉 生活并不总是如你所愿。\n力所不能及之处，如果非要强求，可能将落下遗憾与后悔。\n山外有山，曾经有过的挑战也让我更加认清自己。\n什么是最适合自己的？\n自己是否努力到了足以对抗强敌的程度？\n血，酒精，痛觉\u0026hellip;\u0026hellip;\n一切都让我更加清醒与冷静。\n反省，沉静下去反省。\n愿伤痛带来的不只是伤痛。\n","permalink":"/posts/2021/11/running-memory/","tags":["life"],"title":"跑步记忆"},{"categories":["Tool"],"contents":"加入注册表界面 win+R\nregedit\n增加右键操作文件选项 以vscode作为编辑文件实例 注册表页面下进入：\n计算机\\HKEY_CLASSES_ROOT*\\shell\n新建项 Vscode\n右键Vscode并新建项command\n编辑command默认选项值为： ${vscodepath}\\Code.exe %1 %1是可选的参数，这里必须要加，表示作用于该文件。\n编辑Vscode值\n编辑右键显示名称：默认值改为Open with vscode （不编辑则为新建项的名称）\n编辑右键显示图标：新建字符串值icon 添加：${vscodepath}\\Code.exe (有些可以这样，但一般为ico文件)\n增加目录下右键打开选项 以window terminal作为实例 注册表页面下进入：\n计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell\n新建项 Terminal\n右键Terminal 新建项command\n编辑command默认选项值为：${terminalpath}\\wt.exe 编辑Terminal值\n编辑右键显示名称：默认值改为Open in terminal （不编辑则为新建项的名称）\n编辑右键显示图标：新建字符串值icon 添加：${terminalicon}\n编辑window terminal的json配置文件\n对应位置修改如下，\u0026quot;.\u0026ldquo;即表示当前目录。 1 2 3 4 5 6 7 8 \u0026#34;profiles\u0026#34;: { \u0026#34;defaults\u0026#34;: { \u0026#34;startingDirectory\u0026#34; : \u0026#34;.\u0026#34; }, ... } over\n","permalink":"/posts/2021/11/add-right-click-open-option-in-window/","tags":["windows"],"title":"Window 增加右键打开选项"},{"categories":["OS"],"contents":"在进行上传文件时，一般会先获取项目类路径：\n1 2 File relativePathFile = new File(URLDecoder.decode(ResourceUtils.getURL(\u0026#34;classpath:\u0026#34;).getPath(), \u0026#34;utf-8\u0026#34;)); String absolutePath = relativePathFile.getAbsoluteFile().getPath(); 首先取得相对路径，再进一步取得绝对路径，结果如下：\n如果单纯运行一个java项目： 获得路径为：\n${project}/target/classes\n如果是运行jar包，且是在Linux系统上，则获得路径大致为： .../${jar包名}!/BOOT-INF/classes! [centos7.9下]\n所以如果是jar包启动并上传文件，则无法正确放到类路径下。\n所以需指定新的上传路径。\n在如下路径中：\n1 2 [root@VM-0-11-centos app]# ls application.yaml LonersHub-0.0.1-SNAPSHOT.jar static 假设我要把文件上传到和jar包同一路径下的static内, 可以在jar包同一路径下新建并编辑application.yaml文件如下：\n1 2 3 4 5 spring: resources: static-locations: - classpath:static/ - file:/app/static/ 然后在文件上传是指定上传路径即可。\n这里编写一个工具类如下：\n关注getUploadPath方法，它用于获取上传路径。\n首先，为了方便后期维护和部署使用，我们先判断项目运行所在的操作系统，如果是生产环境linux则上传到上面指定的目录，而如果是本地测试项目，则将其上传到类路径下的默认位置即可。\n比如，要上传一个头像：\nlinux下： 返回/app/static/${uploadType}/${fileName}\ne.g. /app/static/avatar/test.jpg\nwindow下： 返回 ${project}/target/classes/static/${uploadType}/${fileName}\ne.g. ${project}/target/classes/static/avatar/test.jpg\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public class FileUtils { /** * @description: 获取上传路径 * @author Jiang Zhihang * @date 2022/1/2 23:32 * @param type 上传类型，如avatar，video * @param fileName 上传文件的名称 */ public static String getUploadPath(String type, String fileName) throws FileNotFoundException, UnsupportedEncodingException { String osName = System.getProperty(\u0026#34;os.name\u0026#34;); if (osName.equals(\u0026#34;Linux\u0026#34;)) { // 部署于Linux主机上时获取的上传路径 // 返回/app/static/${uploadType}/${fileName} // e.g. /app/static/avatar/test.jpg return File.separator + \u0026#34;app/static/\u0026#34; + type + \u0026#34;/\u0026#34; + fileName; } else { // 获取上传地址 File relativePathFile = new File(URLDecoder.decode(ResourceUtils.getURL(\u0026#34;classpath:\u0026#34;).getPath(), \u0026#34;utf-8\u0026#34;)); String absolutePath = relativePathFile.getAbsoluteFile().getPath(); // 获取得路径为： // ${project}/target/classes // 或 // /root/file:/root/${jar包名}!/BOOT-INF/classes! [centos7.9下] // 返回 ${project}/target/classes/static/${uploadType}/${fileName} // e.g. ${project}/target/classes/static/avatar/test.jpg return absolutePath + \u0026#34;/static/\u0026#34; + type + \u0026#34;/\u0026#34; + fileName; } } /** * @description: 获取文件后缀名 * @author Jiang Zhihang * @date 2022/1/2 23:37 */ public static String getFileType(MultipartFile file) { String type = file.getContentType(); String fileType; if (type == null) return null; else { // type -\u0026gt; img/jpg fileType = type.substring(type.indexOf(\u0026#39;/\u0026#39;) + 1); return fileType; } } } OVER.\n","permalink":"/posts/2021/11/file-upload-problem-after-deploying-jar-package-project-on-linux/","tags":["java","linux"],"title":"Linux 上部署 JAR 包项目后的文件上传问题"},{"categories":["OS"],"contents":"注：部署环境为centos7.9版本\n配置环境 配好mysql，redis，java开发环境。\n上传JAR包项目 1 2 mvn clean mvn package 即可把项目打包为JAR包，再通过WINSP上传到服务器。\n先新建一个app文件夹，放置项目所有内容：\n1 2 mkdir /app chmod 777 /app 新建并编辑application配置文件 由于主机上的mysql密码与本地mysql密码不同，所以在JAR包同一个文件目录下新建application配置文件并指定新的密码，允许JAR项目时该application配置文件优先级是更高的。这里我还指定了用于linux下文件读取上传的目录路径。\n1 2 3 4 5 6 7 spring: datasource: password: ...... resources: static-locations: - classpath:static/ - file:/app/static/ 1 2 3 [root@VM-0-11-centos app]# chmod -R 777 * [root@VM-0-11-centos app]# ls application.yaml LonersHub-0.0.1-SNAPSHOT.jar static 运行项目 首先确保防火墙配置正确，放通需要的端口。\n1 2 [root@VM-0-11-centos app]# nohup java -jar LonersHub-0.0.1-SNAPSHOT.jar \u0026amp; [1] 27108 更新项目 首先终止原本进程，删除原来的jar包并上传新的jar包，然后运行新的jar包：\n1 2 3 4 5 6 7 [root@VM-0-11-centos app]# ps -ef | grep java root 13415 1 1 00:02 ? 00:00:18 java -jar LonersHub-0.0.1-SNAPSHOT.jar root 16053 15504 0 00:21 pts/1 00:00:00 grep --color=auto java [root@VM-0-11-centos app]# kill -9 12415 [root@VM-0-11-centos app]# nohup java -jar LonersHub-0.0.1-SNAPSHOT.jar \u0026amp; 总结 通过记录项目的完整部署运行过程，方便以后参考。\nOVER.\n","permalink":"/posts/2021/11/the-whole-process-of-linux-host-deployment-springboot-project/","tags":["linux","springboot","java"],"title":"Linux 主机部署 springboot 项目全过程"},{"categories":["Book"],"contents":"作者：渡航\n卷十三 第八章. 祈祷至少不要再出错。 「我过得很愉快。这还是第一次。觉得跟别人一起度过的时间是自在舒适的，我很高兴……」\n她带着泫然欲泣的表情，看起来真的很幸福。我再也无法否定，制止她。\n我无力地放下手，雪之下道谢似地点一下头，接着说：\n「我从来没有像这样跟别人争执，吵架……在别人面前哭过。两个人一起出去的时候，也非常紧张。一堆事都不懂，从来没有体验过……连可以依赖别人都不知道。所以，才会在哪里搞错了……」\n我抬头看着天花板，倾听她用颤抖的声音自言自语。\n远方的夕阳刺痛双眼，即使如此，我依然无法闭上眼，只是忧郁地吐出一口气。\n「这种像赝品的关系是错误的。和你追求的事物肯定不一样。」\n卷十四 序章1 季节轮转，春日再临。\n即便重复着一成不变的日常，今日也总是崭新的。\n即便困于烦恼，难觅答案，重复着错误，也只能不厌其烦地重新问过——为了知晓新的答案。\n不付诸言语便无法传达，可就算说出口也仍不足够。\n无论何时得出的答案都是错误的，扭曲得几近无法挽回的关系，是令人无可奈何的伪物。\n———所以，至少，要在这个仿造品上留下足以毁坏的伤痕，变成那仅仅只有一个的真物。\n我故意犯错的青春，要让它结束掉———\n已然逝去的季节，与将要来临的崭新季节。\n持续着错误的故事结束……之后青春一定还将继续。\n第七章. 触碰到的温度，切实地传达着那份情感 在她走了几步之后，我跟了上去。\n看着远去的背影，我伸出了手，却又不由地犹豫起来。\n我明白，如果要继续谈话的话，只要叫住她就行了。\n即使继续像那样走下去，交谈也并不困难。\n再说了，根本不可能没有特别的理由就去触碰她的手。\n但是，理由确实存在。唯一的，不容退让的理由。\n「……放手了的话，就再也抓不住了啊」\n脱口而出的话语，就像是在说给自己听一样。\n不对，是为了说给自己听才会说出那样的话。接着，我伸出了手。\n单手推着自行车我的样子有些狼狈，而且手里还出了很多汗，也不清楚该用多大的力道。\n即便如此，我还是抓住了雪之下的袖口。\n把那纤细到令我惊讶的手腕紧紧地收入掌中。\n「…………」\n开始说话之后，由于强烈的自我厌恶手中的力气不断地减弱。\n说出这种话的自己简直恶心得令人作呕。\n抓着雪之下的手腕的手一点点下滑，松开，然后无力地垂落下去。\n但是，雪之下并没有逃走，而是停在了那里。\n在摸了摸袖口稍作整理的时候，用自己的手紧握住方才被我抓住的地方。\n虽然没有看向我这边，但是至少看上去有继续听下去的意思。\n对此感到安心之后，我不紧不慢地开口道。\n「可能你并不期望……但是我想把关系维持下去。不是义务，而是意愿的问题。……所以，给我扭曲你人生的权利」\n「我没有足以改变人生的影响力啊，大概，我和你也都会像其他人一样升学，不情愿地就职，就那样认真地活着。但是，互相关联之后，会莫名其妙地做出绕远路啊，原地踏步啊之类的各种各样的事情吧……所以，人生会稍微扭曲一些」\n「我也是这么想的，相遇，相谈，相知，相离……每次，都会感到扭曲」\n想必，太过别扭的我，太过直率的她，在他人眼中都是扭曲的形状吧。\n虽然完全没有相同之处，在扭曲这一点上恐怕是一样的。\n不知不觉间，每一次的相触，每次一次的碰撞，都在稍稍改变了我们的形状。\n这样的改变不断累积，已经到了无法还原的地步了。\n如果有让传达变得更简单的话语就好了。\n如果是更加单纯的感情就好了。\n如果只是恋慕、思慕的话一定不会这么向往。『再也抓不住』什么的，不会这么想。\n「应该不足以支付扭曲人生的代价吧，不过嘛，全都会去做的。不需要的话就扔掉吧。嫌麻烦的话忘掉也无所谓。是我这边擅自做出的决定你不用勉强自己回复」\n雪之下轻哼了一声，点了点头。\n「我要好好说了哦」\n然后，轻轻地把额头抵在我的肩口。\n「你的人生，请交给我吧」\n「……好沉重」\n不经意间，气息漏出了我的嘴角。仿佛是在抗议一般，雪之下的额头再一次轻轻地撞了过来。\n「真的不知道其他的说法了，所以这也是没办法的啊……」\n她像猫一样把额头靠了过来，仿佛小猫轻咬一般抓着我的胸膛。\n触碰到的温热，一定在确切地传达着用千言万语也说不清的心意。\n第八章. 那扇门再次打开。 我默默地把手递了过去。\n雪之下好像不明白那只手的意义，微微地歪头，紧接着露出了浅浅的苦笑。\n「我一个人也能站起来的……」\n「我知道」\n我知道她可以一个人站起来，也知道她会这么说。\n即便如此，我还是把手递了过去。\n大概，从今往后也是。\n即将沉没的夕阳绽放出更加耀眼的光辉，深色的影子向远处延伸。我和她的影子重叠在了一起，已经分不出是谁的影子。\n无论是我的脸，还是她的脸，抑或是所有的一切，都染成了朱红色。在朱红色的世界之中，她无奈地露出微笑，轻轻地握住了我的手。\n","permalink":"/posts/2021/06/spring-abstracts-iv/","tags":["excerpt"],"title":"春物文摘四"},{"categories":["Tool"],"contents":"下载并运行ubuntu镜像 1 2 [root@VM-0-11-centos ~]# docker run ubuntu:15.10 /bin/echo \u0026#34;crazy thursday\u0026#34; crazy thursday 运行ubuntu并开启bash交互 1 2 3 4 5 6 7 8 9 10 [root@VM-0-11-centos ~]# docker run -i -t ubuntu:15.10 /bin/bash root@fda3220ed59f:/# echo hello hello root@fda3220ed59f:/# cat /proc/version Linux version 3.10.0-1160.45.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) ) #1 SMP Wed Oct 13 17:20:51 UTC 2021 root@fda3220ed59f:/# ls bin dev home lib64 mnt proc run srv tmp var boot etc lib media opt root sbin sys usr root@fda3220ed59f:/# exit exit 运行进程并观察 1 2 3 4 5 [root@VM-0-11-centos ~]# docker run -d ubuntu:15.10 /bin/sh -c \u0026#34;while true; do echo hello; sleep 1; done\u0026#34; 6668bf16629c8466ecbc32d77978e993c34a0c1c6f51bab420dcc6b89dc85063 [root@VM-0-11-centos ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6668bf16629c ubuntu:15.10 \u0026#34;/bin/sh -c \u0026#39;while t…\u0026#34; 6 seconds ago Up 5 seconds charming_chaum 通过容器ID停止进程 1 2 3 4 [root@VM-0-11-centos ~]# docker stop 6668bf16629c [root@VM-0-11-centos ~]# docker ps # 查看正在运行的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 删除容器与镜像 删除指定容器：\n1 2 3 4 5 6 7 8 9 [root@localhost ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@localhost ~]# docker ps -l CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 24984c7ca679 redislabs/redismod:preview \u0026#34;docker-entrypoint.s…\u0026#34; 9 minutes ago Exited (0) 25 seconds ago redismod [root@localhost ~]# docker rm 24984c7ca679 24984c7ca679 [root@localhost ~]# docker ps -l CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 删除指定镜像：\n1 2 3 4 5 6 7 8 9 10 11 12 13 [root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE redislabs/redismod preview 551d3e6b4861 8 months ago 1.02GB [root@localhost ~]# docker rmi 551d3e6b4861 Untagged: redislabs/redismod:preview Untagged: redislabs/redismod@sha256:8e2ba4c6fa409f7f8dbde251f6528e5a3d4b6dc4308ac91549a2c3a3509a8ab1 Deleted: sha256:551d3e6b486153de5c5c76d9cc2aab61b7e14eefb4acd3ab52bb1a912f3c987f Deleted: sha256:d1906bf79a5be313e2884cdff4d4610986a5b7e7604a9c83fbd4e169cafa2c1c Deleted: sha256:1affefdd1a759c0b8662d8b8c00367c1beef0c029818f5af95048d75f6043bee Deleted: sha256:d852dbcbdeb989ef0dc20d56cbfc452d5f7876f3b2784d0a08c9933d35993107 ... [root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE 批量删除：\n1 2 3 docker system prune 命令可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling镜像(即无tag的镜像) docker system prune -a 命令清理得更加彻底，可以将没有容器使用Docker镜像都删掉 From My Blog: akynazh.\nOver.\n","permalink":"/posts/2021/05/docker-simple-use-process-record/","tags":["linux","docker"],"title":"Docker 简单使用记录"},{"categories":["Language"],"contents":"Synchronized方法 静态方法上的锁\n静态方法是属于“类”，不属于某个实例，是所有对象实例所共享的方法。也就是说如果在静态方法上加入synchronized，那么它获取的就是这个类的锁，锁住的就是这个类。\n普通方法上的锁\n实例方法并不是类所独有的，每个对象实例独立拥有它，它并不被对象实例所共享。在实例方法上加入synchronized，那么它获取的就是这个类的锁，锁住的就是这个对象实例。\nSynchronized代码块 synchronized(this){...} this关键字所代表的意思是该对象实例，这种用法synchronized锁住的是对象实例。\nsynchronized(Demo.class){...} 锁的是该类。\nsynchronized(obj){...} synchronized同步代码块对对象内部的实例加锁。\n假设demo1与demo2方法不相关，此时两个线程对同一个对象实例分别调用demo1与demo2，均能获取各自的锁。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Demo { private Object lock1 = new Object(); private Object lock2 = new Object(); public void demo1() { synchronized (lock1) { while (true) { //死循环目的是为了让线程一直持有该锁 System.out.println(Thread.currentThread()); } } } public void demo2() { synchronized (lock2) { while (true) { System.out.println(Thread.currentThread()); } } } } demo1方法中的同步代码块锁住的是lock1对象实例，demo2方法中的同步代码块锁住的是lock2对象实例。\n如果线程1执行demo1，线程2执行demo2，由于两个方法抢占的是不同的对象实例锁，也就是说两个线程均能获取到锁执行各自的方法。\n","permalink":"/posts/2021/05/who-the-hell-is-synchronized-locking/","tags":["java","language"],"title":"Synchronized 到底锁了谁"},{"categories":["Book"],"contents":"作者：渡航\n卷十 第七章. 不论何时，叶山隼人总是迎合众人期待 她满意地舒一口气，把脸抬起。我们之间的距离，瞬间拉近到脸颊快碰在一起。\n「……」\n两个人就这么僵住。\n雪之下的肌肤宛如冬天的白雪，乌黑的双眼仿佛在荡漾，每眨一下，修长的睫毛跟着轻柔摇曳。往底下走，是姣好尖挺的鼻梁，以及绽放笑容、呼出热气的嘴唇。\n她削瘦的的肩膀微微一颤，瀑布般的长发随之晃动。\n我赶紧往后仰，跟她拉开距离。结果不知动到什么地方，某处的伤口突然痛了一下。\n「嗯……谢谢你帮忙消毒。」\n「……没什么，不是什么大不了的事。」\n卷十二 第五章. 果然，一色彩羽是最强的后辈。 舞会上的雪之下\n倒不如说合身过头了。单色调的燕尾服，更彰显了雪之下白皙明净的肌肤之美；\n伸长的衣摆和长裤也令她修长俏丽的美腿更为凸显；\n举手投足间，她那扎为一束的秀发如波浪般律动，又为她添了几分虚幻朦胧之意；\n再与她纤瘦的身材相映成趣后，「薄幸的美少年」一词仿佛呼之欲出。\n光是她那工整标致的五官，便使她散发着一种倒错美的气息，我甚至感到了危险。\n舞会上的结衣\n近乎于白的淡粉、带着透明感的布料，此般色调搭配，又或者说是因为这种款式，给人一种分外的成熟感。\n衣襟张得很开，腰部那块也束了一圈，而这又更勾勒出她傲人的身体曲线。\n裙摆本身很长，不过因为开衩开的很深，所以看上去丝毫不笨重；倒不如说若是她转动身体，这礼服就好似随风起舞般的轻盈。\n她一向缠成团子头的头发，如今编的好似花冠，让我不禁想起某位王子大人提过的称呼。\n第七章. 就算，知道会后悔这个选择。 最终只剩下我们的事了。因为相互依赖，所有没有比我们更好理解的了。\n说来容易，正因被人依靠，我才能够弄清自己的存在价值。\n我自己也很容易地信服。\n然而，这并不是答案。相互依赖是形式，但非人的感情所在。即便可以用作借口，也无法成为理由。\n抽丝剥茧，尽心竭力，声嘶力竭，最终心里只剩下了恋恋不舍。\n可是，我唯独不想说出这话。因为这个理由太逊了。然而，不说出来，这位老师就不会让我前行。我很清楚，因为如此，她才对我道歉。\n所以，我疲惫地、重重地叹了一口气，迫不得已，小声地开口说道。\n「……因为我承诺过，总有一天会对她伸出援手。」\n因为她拜托过我，这理由十分平常而又极为理所当然，这话语不带感情而又毫无逻辑可言，这措辞实在无聊而又陈词滥调透顶，我对向她出手相助，真的是厌恶至极。\n","permalink":"/posts/2021/05/spring-article-excerpt-3/","tags":["excerpt"],"title":"春物文摘三"},{"categories":["Book"],"contents":"作者：渡航\n卷八 第一章. 不用说也知道，这正是比企谷小町的逆鳞所在 我们终将失去拥有的一切。此乃不变的真理。\n尽管如此——\n因为终将失去，才显现其美丽。\n因为有结束的一刻，才显得有意义。不论是停滞还是闭塞，乃至于一时的安宁，都绝非我们所能忽视或甘愿忍受的事。\n万物皆有失去的一刻。千万谨记这一点。\n在不经意间想起失去的事物，如同对待宝物般小心呵护，将回忆连同杯中的酒一起饮尽，想必也是一种幸福。\n第七章. 不用说也知道，这正是比企谷小町的温柔所在 谁也不会受到伤害的世界根本不存在。\n真正存在的，是大家平等受到伤害的世界。\n没有人受到伤害，这个世界便无法成立。如果明白这一点，依然不愿任何人受伤，那只好另外产生一个代罪羔羊。\n这个代罪羔羊不是从任何人之中推派，它只负责出来扛下所有的憎恨与伤害。\n第八章. 时机成熟，比企谷八幡终于开口 我真的不知道答案如何。\n雪之下的那句话依旧在耳边回荡。\n认为对方了解自己只是一种幻想，如同让人忘却自我的温柔乡，一旦深陷进去便难以脱身。抛下一切委身于其中，真不知道会有多舒服。\n「相互了解」是一种错觉，一场残酷的幻术。\n从幻术中回过神时，那股失落感想必相当强烈。\n任何一点微小的不自然感与疑心会成为荆棘与隔阂，在某个时刻将一切摧毁殆尽。\n我应该早一点有所察觉。\n我渴望的不是什么亲近的关系。\n我渴望的事物更加纯粹。\n无需话语即可心意相通，无需行为即可了解对方，无论发生什么都能永保完整——我真正渴望的是这种超脱现实，到达可笑地步的美丽幻想。\n这是我跟她一直在追求的事物。\n卷九 第五章. 平冢静祈祷着他们迎向的结局 雪之下摇摇头，肩上的包包无力地滑落。\n「在那之后，你便一直很在意……所以……」\n我好不容易听出气若游丝的话语，等待她的下一句话。她却转向别的话题。\n「其实，你不需要继续勉强自己。要是这样就被破坏，代表程度也不过如此……难道不是？」\n这次我真的说不出话。\n雪之下所说的，是我曾经相信过，却没有坚信到底的事物。\n毕业旅行之后，我便不再相信的事物，雪之下至今仍深信着。\n街灯将平冢老师的脸映照成橘红色，川流的车灯不时刷上白光。她带着略显落寞的神情，用温暖又柔和的声音低语：\n「可是啊，比企谷，这是不可能实现的。人类只要存在这个世界，便难免在不自觉中伤害到其他人。不只是活着，连死去以后，伤害都持续发生着。与人产生关系，伤害便连带出现；即使刻意避免产生关系，也难保对方不会受伤……」\n平冢老师抽出一根香烟，看着那根烟继续说：\n「说是这么说，假如对方一点都不重要，我们也不会注意到自己造成的伤害。重要的在于『自觉』。正是因为珍惜对方，我们才意识到伤害了对方。」\n老师总算把烟含入口中，用打火机点燃时，脸庞微微亮了一下。她闭着双眼，面容相当安详，「呼——」地吐出长长的烟雾，低语：\n「珍惜一个人，意味着做好伤害对方的觉悟。」\n她抬头看向夜空。\n第六章. 即使如此，比企谷八幡—— 我渴望的不是话语。但我的确渴望着什么。\n那肯定不是相互理解、好好相处、无话不谈、待在一起之类的愿望。我知道自己不被人理解，也不期望别人理解自己。\n我追求的是更苛刻、更残酷的事物。\n未知的事物是何等恐怖，所以我希望「了解」。我想了解、想知道，借此感到安心，得到心灵上的安适。\n「想要完全理解」这种愿望太过自私、太过独裁、太过傲慢，既肤浅又教人厌恶。一想到自己抱持这种愿望，便觉得浑身快要受不了。\n话虽如此，如果、如果彼此都能这么想——\n如果存在那么一个对象，能互相将丑陋的自我满足加在彼此身上，并且建立容忍彼此傲慢的关系——\n这种情况绝对不可能发生，我心里清楚得很；这样的愿望，只存在我无法企及之处。\n再怎么跳也够不到的葡萄，一定酸得要命。\n不过，我也不需要甜到失去实感的果实。虚假的认知和欺瞒的关系，不是我渴望的事物。\n我渴求的，其实是酸得要命的葡萄。\n哪怕那串葡萄再酸、再苦涩、再难吃、甚至有毒，或根本不存在、不可能得到、连「想要」的想法都不被允许——\n「即使如此……」\n等察觉时，话语已经脱口而出。我听得出自己的声音在颤抖。\n「我还是……」\n我用尽全力避免自己哽咽，牙根发出咯吱声响。尽管想把声音跟话语通通吞回去，它们却一而再地突破我的齿缝。\n「我还是，想得到『真物』。」\n第八章. 于是，雪之下雪乃—— 雪之下望着下方的景色，发出一阵轻叹。\n「比企谷同学。」\n「嗯？」\n我转过头，在照明下显得苍白的巨大城堡映入眼帘。\n出现在城堡之前的，是身披纯白大衣，带着泫然欲泣表情微笑的雪之下。\n那般高洁而脆弱的姿态，使我一时忘记呼吸。\n她放开扶手，握住我的袖口，两人的肌肤不经意地相触。这一瞬间，我的心脏仿佛被揪了一把。\n如同坠入无底幽谷的失重感终于袭来。\n「总有一天，要来拯救我喔。」\n雪之下的低语很快地被风吹散，让我来不及回应。\n说不定，这是雪之下雪乃初次说出口的愿望。\n","permalink":"/posts/2021/05/spring-abstracts-ii/","tags":["excerpt"],"title":"春物文摘二"},{"categories":["Language"],"contents":"先说结论：Java只有值传递，而C++既有值传递又有引用传递。\nJava的参数传递 先定义3个方法如下：\n1 2 3 4 5 6 7 8 9 10 11 public static void change1(String str, int num) { str = \u0026#34;world\u0026#34;; // 这里就相当与新new了一个对象! num = 100; } public static void change2(User user) { user.age = 1; user.name = \u0026#34;mary\u0026#34;; } public static void change3(User user) { user = new User(1, \u0026#34;mary\u0026#34;); } 进行测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static void main(String[] args) { String str = \u0026#34;hello\u0026#34;; int num = 1; System.out.println(str + \u0026#34; \u0026#34; + num); // hello 1 change1(str, num); System.out.println(str + \u0026#34; \u0026#34; + num); // hello 1 System.out.println(\u0026#34;------------------\u0026#34;); User user = new User(123, \u0026#34;peter\u0026#34;); System.out.println(user.name + \u0026#34; \u0026#34; + user.age); // peter 123 change2(user); System.out.println(user.name + \u0026#34; \u0026#34; + user.age); // mary 1 System.out.println(\u0026#34;------------------\u0026#34;); user = new User(123, \u0026#34;peter\u0026#34;); System.out.println(user.name + \u0026#34; \u0026#34; + user.age); // peter 123 change3(user); System.out.println(user.name + \u0026#34; \u0026#34; + user.age); // peter 123 } 由change2和3可知，对于引用类型，java是值传递，在函数中只能改变形参对应的实参所引用的对象，而无法改变实参本身，也就是说形参传递的是实参所引用的对象，而不是实参本身。\n由change1可知，对于基本数据类型，java是值传递。\n对于String类型，应作特殊理解：String本身属于引用类型，String底层由char数组维护，是final类型的，本身是不可改变，通过\u0026quot;=\u0026ldquo;赋值即相当于 通过new新创建了一个对象，本质就是change3的操作。\nC++的参数传递 解释了java的参数传递，可能会陷入困惑，到底什么才是引用传递呢？\n我们再来看看C++的参数传递：\n定义2个方法如下：\n1 2 3 4 5 6 7 void change1(User* user) { user-\u0026gt;age = 999; user-\u0026gt;name = \u0026#34;mary\u0026#34;; } void change2(User* user) { user = new User(999, \u0026#34;mary\u0026#34;); } 进行测试：\n1 2 3 4 5 6 7 8 9 User* user1 = new User(21, \u0026#34;peter\u0026#34;); cout \u0026lt;\u0026lt; user1-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; user1-\u0026gt;name \u0026lt;\u0026lt; endl; // 21 peter change2(user1); cout \u0026lt;\u0026lt; user1-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; user1-\u0026gt;name \u0026lt;\u0026lt; endl; // 999 mary User* user2 = new User(21, \u0026#34;peter\u0026#34;); cout \u0026lt;\u0026lt; user2-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; user2-\u0026gt;name \u0026lt;\u0026lt; endl; // 21 peter change3(user2); cout \u0026lt;\u0026lt; user2-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; user2-\u0026gt;name \u0026lt;\u0026lt; endl; // 21 peter 这样的效果和java测试中的change2和3是一致的，都是传递了实参引用的对象！\n下面看看如何实现引用传递吧：\n这里形参就传递了实参本身！\n1 2 3 void change3(User*\u0026amp; user) { user = new User(999, \u0026#34;mary\u0026#34;); } 测试如下：\n1 2 3 4 User* user3 = new User(21, \u0026#34;peter\u0026#34;); cout \u0026lt;\u0026lt; user3-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; user3-\u0026gt;name \u0026lt;\u0026lt; endl; // 21 peter change4(user3); cout \u0026lt;\u0026lt; user3-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; user3-\u0026gt;name \u0026lt;\u0026lt; endl; // 999 mary 可见在函数中实现了对形参所对应实参本身的修改！\n为什么Java取消了引用传递 应该是为了更简单，更安全的开发吧。\n函数调用无法修改实参，这样一定程度上避免了很多错误的发生，但同时限制了可以做的事情，可以说有利有弊。\n","permalink":"/posts/2021/05/value-passing-and-reference-passing-parsing-in-java-and-c/","tags":["java","cpp"],"title":"Java 与 C++ 中的值传递和引用传递解析"},{"categories":["Language"],"contents":"创建文件或文件夹 cmd下创建文件 1 type nul \u0026gt; test.jpg powershell下创建文件 1 new-item test.jpg 创建文件夹 1 mkdir test 重命名文件 注意不能指定到新的路径。\n1 PS D:\\a\\tmp\\test\u0026gt; ren test.txt my.txt 移动文件 该命令也可用于重命名。\n1 PS D:\\a\\tmp\\test\u0026gt; move test.jpg mydir 复制文件和文件夹 copy无法递归复制，而xcopy可以。\n1 PS D:\\a\\tmp\\test\\mydir\u0026gt; copy test.jpg test1.jpg 1 2 3 4 5 6 7 8 9 10 11 12 # mydir not empty PS D:\\a\\tmp\\test\u0026gt; copy mydir mydir1 PS D:\\a\\tmp\\test\u0026gt; ls mydir1 # empty PS D:\\a\\tmp\\test\u0026gt; xcopy mydir mydir2 目标 mydir2 是文件名 还是目录名 (F = 文件，D = 目录)? D mydir\\test.jpg mydir\\test1.jpg 复制了 2 个文件 删除文件或文件夹 del 删除文件。powershell可以使用rm。\nrd（rmdir） 删除空目录。\nrd -R递归删除非空目录。\n","permalink":"/posts/2021/04/file-operation-recorded-by-window-utility-command/","tags":["windows","cmd","powershell"],"title":"Window 实用命令记录之文件操作"},{"categories":["Book"],"contents":"作者：太宰治\n手记之二 新学年伊始，山樱树在强韧的褐色嫩叶烘托和蔚蓝的大海映衬下，绽放绚烂的花朵，待到落英缤纷时节，如飞雪般坠下的樱花飘飘洒洒散向大海，装点着海面，随波荡漾，被浪花复又拍打回岸边。\n真孤单……比起她冗长的身世来，仅就这一句叹息便足以唤起我的共鸣。我一直期待着，可是，我从未从这世上的女人口中听到过这句话，这使我感到奇怪和难以理解。不过，虽然她没有用语言说出“孤单”两字，但似乎她身上就散发着这般无言的孤寂，好似有股一寸来宽的气流带包裹着她，在她身旁，我好像也被那股气流包裹，与我特有的带刺的阴郁气流相互交融，犹如落入水底附着在岩石上的枯叶，使我得以从恐惧和不安中抽离。\n手记之三 他面容下潜藏着某种狡诈嗤笑的那一刻，令我永远难以忘怀。那东西似轻蔑，却又有所不同，倘若将人世间比作大海，在那千丈深的海底就漂摆曳动着那种诡异的面容，仿佛故意露出隙孔，让人一窥成年人生活的深层奥趣似的——就是那种笑。\n","permalink":"/posts/2021/04/human-disqualification-abstract/","tags":["excerpt"],"title":"《人间失格》文摘"},{"categories":["Book"],"contents":"作者：渡航\n卷二 第五章. 比企谷八幡再一次回归原来的道路 「才不是那样子……根本不是那样……」\n她说得很小声。由比滨总是那么温柔，所以直到最后仍旧温柔。\n如果说真相是残酷的，那么谎言想必很温柔。所以，温柔只是一种谎言。\n卷四 第五章. 雪之下雪乃独自仰望星空 每个人都会为过去所困，不论我们自以为已经往前走多远，只要在不经意间抬起头，往事便像星光一样缓缓降下。\n我们无法一笑置之，也无法把它们变不见。\n那些事情永远会待在我们心中的一角，与某个时刻突然苏醒。\n卷六 第十章. 他跟她终于找出正确的答案 「比企谷，帮助其他人不能当做伤害自己的理由。」\n鼻腔内是淡淡的香烟味，脸上是难以想像为同一个人的温柔指尖。她潮湿的双眼，有如看透我的内心。\n「不，这种程度不至于让我受伤……」\n「……就算你已经习惯那种痛也一样。过了这么久，你总该明白有些人看到你受伤，一样会觉得心痛。」\n卷七 第六章. 雪之下雪乃安静地走在夜晚的街道 但是，我没有见过这样的雪之下。\n她不断注意周遭，同时看着我的脚边，以免找不到回去的路。\n她难为情地垂下双眼，发现我走太快时，还伸出犹豫不决的手，想要我放慢速度，接着又惊觉似地把手缩回——我从来没见过这些举动。\n我被她生硬的举动感染，不知不觉间变得同手同脚，也因为如此，尽管旅馆离这里很近，我却觉得远得要命。\n我们两人始终若即若离，怎样都不会并肩走在一起。\n","permalink":"/posts/2021/04/spring-abstracts-i/","tags":["excerpt"],"title":"春物文摘一"},{"categories":["Tool"],"contents":"控制台中文乱码解决 菜单栏HELP-\u0026gt;Edit Custom VM OPtions中加 -Dfile.encoding=utf-8 重启idea IDEA开启RunDashboard 1 2 3 4 5 6 7 8 9 # .idea/workspace.xml \u0026lt;component name=\u0026#34;RunDashboard\u0026#34;\u0026gt; \u0026lt;option name=\u0026#34;configurationTypes\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;option value=\u0026#34;SpringBootApplicationConfigurationType\u0026#34; /\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/option\u0026gt; \u0026lt;/component\u0026gt; IDEA关闭拼写 1 Settings -\u0026gt; Editor -\u0026gt; Inspection -\u0026gt; Proofreading -\u0026gt; 关闭Typo IDEA配置快捷输入 1 editor -\u0026gt; live template IDEA常用快捷键 1 2 3 4 5 6 7 8 9 10 11 12 13 alt + ctrl + L : 格式化 ctrl + shift + r : 替换字符 ctrl + r : 在当前文件中替换字符 ctrl + shift + n : 搜索项目文件 ctrl + f : 在当前文件下搜索字符 ctrl + shift + t : 进行快捷抛异常 alt + 上下键 : 光标移到下或上一层 禁用 double shift 对于2021.2.2之前的版本，方法如下：\nCtrl+Shift+A (Mac下为 Comand+Shift+A) =\u0026gt; 输入 Registry =\u0026gt; 找到 \u0026quot;ide.suppress.double.click.handler\u0026quot; 并勾选，再 Apply 即可。\n对于2021.2.2及之后的版本，可以这么做：\n菜单栏依次点击 File =\u0026gt; Settings =\u0026gt; Advanced Settings =\u0026gt; User Interface =\u0026gt; 勾选 \u0026quot;Disable double modifier key shortcuts\u0026quot;，或者打开设置之后搜索 disable，可快速定位。\n忽略文件或目录 忽略文件或目录：\nEditor -\u0026gt; File Types -\u0026gt; Ignored Files And Folders\n忽略目录，并可以方便的显示和隐藏：\n隐藏：右键目录，Mark Directory As -\u0026gt; Excluded 显示：右键Projects左侧空白处，Tree Apperance -\u0026gt; Show Excluded Files 常用gitignore 1 2 3 4 .idea out # target *.iml From my blog: akynazh.\nOver.\n","permalink":"/posts/2021/01/idea-configuration-usage-record/","tags":["software"],"title":"IDEA 配置使用记录"},{"categories":["Tool"],"contents":"编辑 ~/.ssh/config 1 2 3 4 5 6 7 8 9 Host 输入代替名 HostName 输入IP Port 输入端口号 User 输入用户名 # ProxyCommand \u0026#34;C:\\Program Files\\Git\\mingw64\\bin\\connect.exe\u0026#34; -S 127.0.0.1:7890 -a none %h %p # 定时发送心跳确保不断开连接 ServerAliveInterval 30 # 每隔30秒发送一次 ServerAliveCountMax 60 # 连续60次服务端无响应断开连接 生成并发送密钥 1 ssh-keygen -t rsa 然后将公钥 ~/.ssh/id_rsa.pub 复制到目标主机 ~/.ssh/authorized_keys 文件中。\n可能出现的问题：密钥算法不匹配 如果出现以下错误：\nno matching key exchange method found. Their offer: diffie-hellman-group1-sha1\n则是本地密钥算法与远程主机密钥算法不匹配造成的！\n可以在ssh_config或config文件中添加密钥算法配置：\n1 2 3 4 5 Host 输入代替名 HostName 输入IP Port 输入端口号 User 输入用户 KexAlgorithms +diffie-hellman-group1-sha1 From my blog: akynazh.\nOver.\n","permalink":"/posts/2021/01/realize-ssh-ipfree-and-secret-free-login/","tags":["ssh"],"title":"实现 SSH 免 IP 免密登录"},{"categories":["OS"],"contents":"查看内网IP grep抓取inet行，sed删除inet字串和netmask.*字串\n1 alias myip=\u0026#34; ifconfig eth0 | grep \u0026#39;inet \u0026#39; | sed \u0026#39;s/inet//g\u0026#39; | sed \u0026#39;s/netmask.*$//g\u0026#39;\u0026#34; test:\n1 2 [root@VM-0-11-centos ~]# myip 172.17.0.11 查看外网IP 1 curl cip.cc show:\nIP : ${my_ip} 地址 : 中国 中国\n数据二 : 上海市 | 腾讯云\n数据三 : 中国北京北京 | 腾讯\nURL : http://www.cip.cc/${my_ip}\n查看IP端口状况 1 2 3 4 5 6 [root@VM-0-11-centos ~]# netstat -ntlp Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1089/sshd tcp6 0 0 :::3306 :::* LISTEN 14528/mysqld 参数说明：\nn：拒绝别名都用数字 t：即只接受TCP l：即只显示在listen中的 p：可显示相关程序名 另外一种方法：\n获取3306端口运行状况：\n1 2 3 [root@VM-0-11-centos ~]# lsof -i:3306 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME mysqld 14528 mysql 17u IPv6 779103 0t0 TCP *:mysql (LISTEN) 开启与关闭端口 这里实验环境为centos7.9，我采用firewall来实现需求。\n1 2 3 4 5 6 7 8 9 10 11 12 # 首先打开防火墙服务 [root@VM-0-11-centos ~]# systemctl start firewalld # 永久开启80端口 [root@VM-0-11-centos ~]# firewall-cmd --zone=public --add-port=8080/tcp --permanent # 使生效 [root@VM-0-11-centos ~]# firewall-cmd --reload # 查看已经开启的端口 [root@VM-0-11-centos ~]# firewall-cmd --zone=public --list-ports 8080/tcp 3306/tcp 80/tcp ","permalink":"/posts/2021/01/network-management-of-linux-practical-operation/","tags":["linux","network"],"title":"Linux 实用操作之网络管理"},{"categories":["Algorithm"],"contents":"二分图问题 能否只用2种颜色对一个图上色，并且使得共边顶点不同色？\n代码解决：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 vector\u0026lt;int\u0026gt; G[MAX_V]; int vertexes; int edges; int color[MAX_V]; //二分图，颜色为1或-1 bool dfs(int v, int c) { color[v] = c; for (int i = 0; i \u0026lt; G[v].size(); i++) { if (color[G[v][i]] == c) return false; if (color[G[v][i]] == 0 \u0026amp;\u0026amp; !dfs(G[v][i], -c)) return false; } return true; } void solve() { for (int i = 0; i \u0026lt; vertexes; i++) { if (color[i] == 0) { if (!dfs(i, 1)) { printf(\u0026#34;No\\n\u0026#34;); return; } } } printf(\u0026#34;Yes\\n\u0026#34;); } solve(); 二分图是着色问题的特殊情况，即图的最小着色数为2，接下来的问题是：\n图的最多着色方法数问题 对V个顶点，E条边的图，用小于num_color种颜色进行涂色，要求共边的两点颜色不相同，一共有多少种涂法？\n重要思想：回溯\n代码解决：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int G[MAX][MAX]; // init: 0 int color[MAX]; // init: 0 int V, E, num_color, ccount = 0; bool Judge_Color(int v, int col) { // 对v点用col继续涂色 for (int i = 1; i \u0026lt;= V; i++) if (G[i][v] == 1 \u0026amp;\u0026amp; color[i] == col) return false; return true; } void Solve(int v) { if (v \u0026gt; V) { // 涂色完毕 ccount++; for (int i = 1; i \u0026lt;= V; i++) cout \u0026lt;\u0026lt; color[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return; } for (int i = 1; i \u0026lt;= num_color; i++) { if (Judge_Color(v, i)) { // 如果可以涂色则进行涂色 color[v] = i; Solve(v + 1); color[v] = 0; // 回溯 } } } Solve(1); // 从第一个结点开始涂色 以上问题我们给定了最小的涂色数，求的是方法的个数，反过来呢？\n现在我们想要用最少的颜色达到目标，就是要求一幅图的最小着色数了：\n思路：从小到大增加着色数，判断以当前数量的颜色是否可以成功涂色，如果可以一一选取其中可以涂色的颜色进行涂色，如果不可以则新增颜色涂色\n最小着色数问题 基本思想：剪枝与回溯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int G[MAX][MAX]; // init: 0 int color[MAX]; // init: 0 int V, E, c_min = MAX + 1; bool Judge_Color(int v, int col) { // 判断v是否可以用col涂色 for (int i = 1; i \u0026lt;= V; i++) if (G[i][v] == 1 \u0026amp;\u0026amp; color[i] == col) return false; return true; } void Solve(int v, int num_color) { if (num_color \u0026gt;= c_min) return; //剪枝 if (v \u0026gt; V) { // 涂色完毕 c_min = min(c_min, num_color); return; } for (int i = 1; i \u0026lt;= num_color; i++) { if (Judge_Color(v, i)) { // 如果可以用这种颜色涂色 color[v] = i; Solve(v + 1, num_color); color[v] = 0; //回溯 } } // num_color种颜色不够用了 color[v] = num_color + 1; // 新增一种颜色 Solve(v + 1, num_color + 1); color[v] = 0; // 回溯 } Solve(1, 1); 下面是有关最小着色问题相应实际问题的解决：\n分考场问题 n个人参加某项特殊考试。 为了公平，要求任何两个认识的人不能分在同一个考场。 求是少需要分几个考场才能满足条件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int G[MAX][MAX]; // init 0 int room[MAX][MAX]; // 保存教室i中第j个学生的id, init: 0 int c_stu, c_relation, min_room = MAX + 1, count_room; void solve(int x, int count_room) { if (count_room \u0026gt;= min_room) return; // 剪枝 if (x \u0026gt; c_stu) { // 学生分配完毕 min_room = min(min_room, count_room); return; } for (int i = 1; i \u0026lt;= count_room; i++) { int flag = true, j = 0; while (room[i][j]) { //查找学生教室中是否有认识的人 if (G[x][room[i][j]]) { flag = false; break; } j++; } if (flag) { // 教室里没有认识的人 room[i][j] = x; solve(x + 1, count_room); // 继续用现有教室分配下一个学生 room[i][j] = 0; } } // 教室不够 新增一个教室并把学生放进教室 room[count_room + 1][0] = x; solve(x + 1, count_room + 1); room[count_room + 1][0] = 0; } solve(1, 1); // 最开始用一个教室分配学生 over.\n","permalink":"/posts/2020/12/summary-of-coloring-problems-of-graphs/","tags":["algorithm"],"title":"图的着色问题汇总"},{"categories":["Algorithm"],"contents":"求解无向图中是否存在环 无向图中是否存在环，可以通过DFS来实现。\n由于他是无向图，所以每次开始一次新的递归即进入一个新的连通子图，在该次dfs中可以通过判断新纳入的结点是否与所在连通子图中其他已经访问过的结点存在边，如果存在则证明存在环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int mat[maxn][maxn], vis[maxn]; int dfs(int v) { vis[v] = 1; for (int i = 0; i \u0026lt; num; i++) if (mat[v][i]) { if (vis[i] || dfs(i)) return 1; // 该连通子图新纳入的结点与原连通子图中的某一结点有边，即产生了环 } return 0; } memset(vis, 0, sizeof(vis)); int flag = 0; // 无环标志 for (int j = 0; j \u0026lt; num; j++) { if (!vis[j]) flag = dfs(j); // 因为是无向图，所以每开始一次新的递归即进入一个新的连通子图，一定不会访问到其他连通子图的结点 if (flag) break; // 如果在该连通子图中找到环则直接结束递归 } 求解有向图中是否存在环 这里我也尝试过使用如上DFS的解法，但似乎行不通。\n因为有向图的DFS，每开始一次新的递归未必进入一个新的连通子图！\n基于这一点，使用上述无向图的方法是行不通的，因为如果以后的递归中访问一个结点时，该结点可以指向其他连通子图访问过的结点，导致误判为出现了环，而实际上并没有。\n所以需要转换思路。\n转念一想，不是还有一个拓扑序的思想吗？！\n对一个有向图来说，如果存在拓扑序则该图一定不存在环。\n所以完全可以使用拓扑排序的算法来判断环的存在与否。\n由于存在拓扑序的一个充要条件是：\n算法进栈结点数等于总结点数\n所以比较进栈的结点数和总的结点数即可！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int topo() { stack\u0026lt;int\u0026gt; st; int ncount = 0; for (int i = 0; i \u0026lt; num; i++) if (!in_num[i]) st.push(i); // 找到第一个入度为0的结点 while(!st.empty()) { int k = st.top(); st.pop(); ncount++; for (int i = 0; i \u0026lt; num; i++) { if (mat[k][i]) if (--in_num[i] == 0) st.push(i); // 如果减去1后入度为0则属于拓扑序结点，进栈 } } return ncount; } memset(in_num, 0, sizeof(in_num)); for (int j = 0; j \u0026lt; num; j++) for (int k = 0; k \u0026lt; num; k++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;mat[j][k]); if (mat[j][k]) in_num[k]++; // 计算入度 } int ncount = topo(); // 如果拓扑序中进栈的结点小于总结点数则证明含有环 if (ncount \u0026lt; num) ans.push_back(1); // 1表示有环 else ans.push_back(0); } over\n","permalink":"/posts/2020/12/a-method-to-solve-whether-there-are-rings-in-directed-graphs-and-undirected-graphs/","tags":["algorithm"],"title":"求解有向图和无向图中是否存在环的方法"},{"categories":["Life"],"contents":"之前看完冰菓之后，内心有一丝莫名的伤感。最近终于也把春物小说读完了，同样的感觉又涌上心头，这是一种难以言说的情愫。\n也许是对一段故事谢幕的不舍。欣赏一部优秀的作品，走进另一个世界，见证一段故事。在故事尾声，我总希望剧情能不断延长下去。可就像一段青春时光，一段故事总要落幕。结束了的就只能成为回忆\u0026hellip;\u0026hellip;虚拟世界里的东西，往往是现实中难以企及的。\n也许是对二次元世界的那种向往。 二次元世界有着独特的美感，每一个画面都扣人心弦，那种干净的，美好的画面，都是现实中难以遇见的。尤其是京阿尼的冰菓，每一帧画面都是精品。所以在经历了一段时间的美感洗礼之后又回到现实，我也许因此莫名的迷惘，失落吧。\n也许是对故事中那种青春的向往。 想体验那种玫瑰色的青春，体验青春中真挚的，纯真的感情。随着时间流逝，我也许已经不再有机会。\n不管如何，二次元，再扩展到所有的文学艺术作品，与现实都是有一定的距离的。但就算是如此，我们一样可以在现实中找寻生活的美与希望。尽管我们难以企及故事中的那般美好，生活有时总是那么不如意，但是我觉得只要自然地生活下去，用心生活下去，总能在不经意间体会到现实生活中的，不一样的美，与快乐。\n另外，阅览一个故事，也可以算是经历了一段故事吧，尽管不是故事的主人公，但也已经在自己的人生中体验到了另一种生活的感觉，尽管那种体验不那么真实，但它也给你带来了一笔无比珍贵的宝物。\n每个人都会过完自己独特的一生吧，把握住当下，去做自己喜欢做的事，对，这一点就是我觉得的，很重要的东西。不要浮躁，不要回到曾经的那种焦虑与迷惘。切实地理解自己，品味生活，偶尔让身心慢下来，不要逼自己去做太多不必要的事情。“不必要的事情不管，必要的事情尽快完成”，这种节能思想我觉得还是很值得借鉴的。毕竟我觉得懂得偷闲的人，也许都过的更快乐一点吧。\n","permalink":"/posts/2020/11/two-dimensional-capriccio/","tags":["acgn","thinking"],"title":"二次元随想"},{"categories":["Language"],"contents":"equals方法与\u0026quot;==\u0026ldquo;的比较与分析 首先提出一个重要的点:\n== 比较时进行地址的比较\nequals 比较时进行值的比较\n1 2 3 4 5 6 7 8 9 String a = \u0026#34;123\u0026#34;; String b = \u0026#34;123\u0026#34;; System.out.println(a.equals(b)); // true System.out.println(a == b); // true String a1 = new String(\u0026#34;123\u0026#34;); String b1 = new String(\u0026#34;123\u0026#34;); System.out.println(a1.equals(b1)); // true System.out.println(a1 == b1); // false 好像没问题。\n然而阅读源码Object类，可以发现对象中默认equals方法进行的是地址的比较\n1 2 3 public boolean equals(Object obj) { return (this == obj); } 再阅读源码String类，可以发现String类中重写了equals方法，覆盖掉了Object的equals方法，所以String的equals是值比较！\n1 2 3 4 5 6 7 8 9 10 11 12 13 public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String aString = (String)anObject; if (coder() == aString.coder()) { return isLatin1() ? StringLatin1.equals(value, aString.value) : StringUTF16.equals(value, aString.value); } } return false; } 所以equals()不一定进行值的比较，在使用自己创建的类时，若想进行值的比较就必须重写equals()方法。\n如何重写equals方法 重写equals方法的目的： 重写equals是 在两个对象某些字段相等时就认定两个对象相等 的情况下进行的\n重写一个完美的equals()的步骤 1.显式参数命名为otherObject，稍后将它强制转换为另一个名为other的变量\n2.检测this与otherObject是否相等\n3.检测otherObject是否为null\n4.比较this与otherObject的类，如果equals的语义可以在子类中改变，就使用getclass检测\n如果所有的子类都有相同的相等性语义，就使用instanceof检测\n5.将otherObject强制转换为相应类类型的变量\n6.使用 == 比较基本类型字段 使用 Object.equals比较对象字段\nby 《core Java》\n注：\ninstanceof进行类型检查规则是:你属于该类or该类的派生类;\ngetClass获得类型信息采用==来进行检查是否相等的操作是严格的判断,只会判断本类.\nexample:\n当两个人年龄相同时，我们认为这两个对象相同：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Person { private int age; private String name; public Person(int age, String name) { this.age = age; this.name = name; } @Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;age=\u0026#34; + age + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age; } @Override public int hashCode() { return Objects.hash(age); } } test:\n1 2 3 4 Person p1 = new Person(15, \u0026#34;Mary\u0026#34;); Person p2 = new Person(15, \u0026#34;Mark\u0026#34;); System.out.println(p1.equals(p2)); // true System.out.println(p1 == p2); // false over\n","permalink":"/posts/2020/11/the-difference-between-the-equals-method-and-the---operator/","tags":["java"],"title":"equals 方法和 == 运算符的作用区别"},{"categories":["Language"],"contents":"写入文件 写入hello字符串（同时新建了a.txt） 1 echo hello \u0026gt; a.txt 追加写入hello字符串 1 echo hello \u0026gt;\u0026gt; a.txt 将a.txt内容追加写入b.txt 1 type a.txt \u0026gt;\u0026gt; b.txt 新建文件 新建空文件a.txt 1 type null \u0026gt; a.txt 换行（分号换行输出） 1 echo hello; echo peter 关于程序编译 test.cpp: 一个含cin输入的程序\n编译cpp\n1 g++ test.cpp -o test 以1.in作为标准输入，2.out作为标准输出执行test\n1 test \u0026lt; 1.in \u0026gt; 2.out test_err.cpp: 一个会导致编译错误的程序\n把编译后出现的错误输入log.txt，命令行不会报错\n1 g++ test_err.cpp -o terr 2\u0026gt; log.txt 打开并编辑文件 cmd下没有bash下好用的vim=_=\n使用记事本打开编辑 1.py\n1 notepad 1.py 记事本不好用呀，还是vscode香，如下~\n使用vscode打开编辑1.py，首先需配置环境变量\n(${vscodepath}\\bin)\n1 code 1.py over\n","permalink":"/posts/2020/11/cmd-some-important-and-practical-commands/","tags":["script","cmd"],"title":"Cmd 重要且实用的一些命令"},{"categories":["Algorithm"],"contents":"矩阵快速幂介绍 题目描述\n给定n×n的矩阵A，求 A^k。\n输入格式\n第一行两个整数 n,k 接下来n行，每行n个整数，第i行的第j个数表示Aij。\n输出格式\n输出 A^k\n共n行，每行n个数，第i行第j个数表示Aij, 每个元素对 10^9+7取模。\n1 \u0026lt;= n \u0026lt;= 100\n0 \u0026lt;= k \u0026lt;= 10 ^ 12\n|Aij| \u0026lt;= 1000\n分析：\n本质上就是快速幂运算，只是底数变成了一个矩阵。\n快速幂运算板子： 1 2 3 4 5 6 7 8 9 10 typedef long long ll; ll mod_pow(ll x, ll n, ll mod){ ll res = 1; while(n \u0026gt; 0){ if(n \u0026amp; 1 == 1) res = res * x % mod; // 如果指数是奇数则乘上底数 x = x * x % mod; // 底数平方 n \u0026gt;\u0026gt;= 1; // 指数除二 }\treturn res; } 由此易得：\n矩阵快速幂板子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Matrix Pow_Mod(Matrix m){//矩阵快速幂 Matrix M; for(int i = 1; i \u0026lt;= n; i++) for(int j = 1; j \u0026lt;= n; j++){ if(i == j) M.mat[i][j] = 1; else M.mat[i][j] = 0; }// 结果矩阵, 初始状态是一个单位阵 while(p){ if(p \u0026amp; 1)\tM = Mul(M, m); // 如果指数是奇数则乘上底数矩阵 m = Mul(m, m); // 底数矩阵平方 p \u0026gt;\u0026gt;= 1; // 指数除二 } return M; } 其中的Mul函数返回两个矩阵相乘的结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Matrix Mul(Matrix m1, Matrix m2){//方阵乘法\u0026amp;取模运算 Matrix M; for(int i = 1; i \u0026lt;= n; i++) for(int j = 1; j \u0026lt;= n; j++) M.mat[i][j] = 0; for(int i = 1; i \u0026lt;= n; i++) for(int j = 1; j \u0026lt;= n; j++){ for(int k = 1; k \u0026lt;= n; k++){ // 相加减取模的运算规律 M.mat[i][j] += ( (m1.mat[i][k] % e) * (m2.mat[k][j] % e) ); M.mat[i][j] %= e; } } return M; } 矩阵快速幂的应用 斐波那契： 题目描述：\nf(x) = 1 \u0026hellip;. (x=1,2)\nf(x) = f(x-1) + f(x-2) \u0026hellip;. (x\u0026gt;2)\n对于给定的整数 n 和 m，我们希望求出：f(1) + f(2) + \u0026hellip; + f(n) 的值。\n但这个数字很大，所以需要再对 p 求模。\n为什么要通过矩阵快速幂来运算斐波那契问题呢，这是因为斐波那契运算的每一项可以用矩阵幂的运算得到，而幂运算又有快速幂运算来快速解决。\n为什么可以用矩阵解决？请看下图：\n可见斐波那契数列每项都可以由一个矩阵的若干次方得到，而我们又知道可以通过快速幂运算解决开方运算，所以自然可以用矩阵轻松解决！\n这里的思想很巧妙：\n把一个问题转换为另一个问题，然后就可以通过新的问题特有的且优秀的方法来解决原来的问题。\n对于斐波那契数列还有一个重要性质，就是前n项和等于 f(n+2)-1，这个结论可以又递推法轻松得到。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 long long n, mod, sum = 0; struct Matrix{ long long mat[3][3]; }; Matrix Mul(Matrix m, Matrix m_f, int t) {//矩阵乘法 m*(m_f或m) Matrix M; for(int i = 1; i \u0026lt;= 2; i++) for(int j = 1; j \u0026lt;= 2; j++) M.mat[i][j] = 0; for(int i = 1; i \u0026lt;= 2; i++) for(int j = 1; j \u0026lt;= t; j++)//t==1时得m_f, t==2时得m for(int k = 1; k \u0026lt;= 2; k++) { M.mat[i][j] += (m.mat[i][k] % mod) * (m_f.mat[k][j] % mod); M.mat[i][j] %= mod; } return M; } long long Pow_Mod(long long num) {//矩阵快速幂 Matrix m, m_f; m.mat[1][1] = m.mat[1][2] = m.mat[2][1] = 1; m.mat[2][2] = 0; m_f.mat[1][1] = m_f.mat[2][1] = 1; // 结果矩阵 初始化为 [F2; F1] 求n次 -\u0026gt; [Fn+2; Fn+1] // 只需计算2个，降低复杂度 while(num) { if(num \u0026amp; 1)\tm_f = Mul(m, m_f, 1); m = Mul(m, m, 2); num \u0026gt;\u0026gt;= 1; } return m_f.mat[1][1]; } int main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;mod); sum = Pow_Mod(n) - 1; // f(1)+...+f(n) = f(n+2)-1 printf(\u0026#34;%lld\u0026#34;, sum % mod); return 0; } ","permalink":"/posts/2020/11/introduction-and-application-of-matrix-fast-power/","tags":["algorithm"],"title":"矩阵快速幂的介绍及其应用"},{"categories":["Algorithm"],"contents":"注意，这里为了方便描述算法，所以都用了最易理解的邻接矩阵来写，比赛中为了追求效率，一般将邻接矩阵改为链式前向星或者邻接表。\n迪杰斯特拉算法 O(V^2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 const int MAXN = 100; const int INF = 0x3f3f3f3f; // 有向无环图 DAG int V, E; // 顶点数和边数 int graph[MAXN][MAXN]; // DAG邻接矩阵，初始值为INF，不可达为INF，否则为cost值 int d[MAXN]; // 从某点s出发到其它任意结点的最短路径长度，初始值为INF int visited[MAXN]; // 某点是否访问过，访问过则为1否则为0 // 初始化图 void init() { memset(graph, 0x3f, sizeof(graph)); cin \u0026gt;\u0026gt; V \u0026gt;\u0026gt; E; int from, to, cost; for (int i = 0 ; i \u0026lt; E; i++) { cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to \u0026gt;\u0026gt; cost; graph[from][to] = cost; } } // 迪杰斯特拉算法求解最短路，针对点展开 void Dijkstra(int s) { memset(d, 0x3f, sizeof(d)); memset(visited, 0, sizeof(visited)); visited[s] = 1; for(int i = 0; i \u0026lt; V; i++) d[i] = graph[s][i]; d[s] = 0; int k, min_cost; // 无负边时最多更新n-1(其他结点数)次 for(int i = 0; i \u0026lt; V - 1; i++){ min_cost = INF; // 寻找最未被访问的且权值最小的路径，需要优化的地方 for(int j = 0; j \u0026lt; V; j++){ if(!visited[j] \u0026amp;\u0026amp; d[j] \u0026lt; min_cost){ k = j; min_cost = d[j]; } } visited[k] = 1; // 利用找到的结点更新最短路径 for(int j = 0; j \u0026lt; V; j++){ if(!visited[j] \u0026amp;\u0026amp; min_cost + graph[k][j] \u0026lt; d[j]){ d[j] = min_cost + graph[k][j]; } } } } 迪杰斯特拉算法的堆优化 O(ElogV) 不含负权就用它 ~ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 const int MAXN = 100; const int INF = 0x3f3f3f3f; // 有向无环图 DAG int V, E; // 顶点数和边数 int graph[MAXN][MAXN]; // DAG邻接矩阵，初始值为INF，不可达为INF，否则为cost值 int d[MAXN]; // 从某点s出发到其它任意结点的最短路径长度，初始值为INF int visited[MAXN]; // 某点是否访问过，访问过则为1否则为0 typedef pair\u0026lt;int, int\u0026gt; P; // first: 最短距离 second：通往的顶点编号 priority_queue\u0026lt;P, vector\u0026lt;P\u0026gt;, greater\u0026lt;P\u0026gt; \u0026gt; que; // greater\u0026lt;T\u0026gt; 从小到大取出 // 初始化图 void init() { memset(graph, 0x3f, sizeof(graph)); cin \u0026gt;\u0026gt; V \u0026gt;\u0026gt; E; int from, to, cost; for (int i = 0 ; i \u0026lt; E; i++) { cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to \u0026gt;\u0026gt; cost; graph[from][to] = cost; } } // 迪杰斯特拉算法堆优化求解最短路，针对点展开 void Dijkstra_optimise(int s) { memset(d, 0x3f, sizeof(d)); memset(visited, 0, sizeof(visited)); // for(int i = 0; i \u0026lt; V; i++) d[i] = graph[s][i]; // 开始min_cost为0，若加上这一步，0 + graph[k][i] == d[i] == graph[k][i]，导致无法更新队列 d[s] = 0; int k, min_cost; que.push(P(0, s)); while (!que.empty()) { P p = que.top(); que.pop(); // 通过堆优化直接获得了目标 min_cost = p.first; k = p.second; // 若已经有更短的路径则不更新 if (min_cost \u0026gt; d[k]) continue; visited[k] = 1; for (int i = 0; i \u0026lt; V; i++) { if (!visited[i] \u0026amp;\u0026amp; min_cost + graph[k][i] \u0026lt; d[i]) { d[i] = graph[k][i] + min_cost; que.push(P(d[i], i)); } } } } 贝尔曼福德算法 O(VE) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 using namespace std; const int MAXN = 100; const int MAXE = 100; const int INF = 0x3f3f3f3f; // 有向无环图 DAG struct Edge { int from, to, cost; }; int V, E; // 顶点数和边数 int d[MAXN]; // 从某点s出发到其它任意结点的最短路径长度，初始值为INF Edge edge[MAXE];\t// 边集 // 初始化图 void init() { cin \u0026gt;\u0026gt; V \u0026gt;\u0026gt; E; int from, to, cost; for (int i = 0 ; i \u0026lt; E; i++) cin \u0026gt;\u0026gt; edge[i].from \u0026gt;\u0026gt; edge[i].to \u0026gt;\u0026gt; edge[i].cost; } // 贝尔曼福德算法求解最短路，针对边展开 void Bellman_Ford(int s) { memset(d, 0x3f, sizeof(d)); d[s] = 0; while (1) { int flag = 0; // DAG下最少更新E次 for (int i = 0; i \u0026lt; E; i++) { Edge e = edge[i]; if (d[e.from] != INF \u0026amp;\u0026amp; d[e.to] \u0026gt; d[e.from] + e.cost) { d[e.to] = d[e.from] + e.cost; flag = 1; } } // 如果没出现更新则退出 if (!flag) break; } } 贝尔曼福德算法优化（SPFA + 优先队列）含负边就用它~ 虽然大家都说SPFA已死，但其实是说笑罢了，含负权边或者负环的题还真离不开这东西~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 const int MAXN = 100; const int INF = 0x3f3f3f3f; // 有向无环图 DAG int V, E; // 顶点数和边数 int graph[MAXN][MAXN]; // DAG邻接矩阵，初始值为INF，不可达为INF，否则为cost值 int d[MAXN]; // 从某点s出发到其它任意结点的最短路径长度，初始值为INF int vis[MAXN]; // 结点是否已入队 int push_count[MAXN]; // 结点入队次数，若大于等于V，则证明存在负环 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; que; // greater\u0026lt;T\u0026gt; 从小到大取出 // 初始化图 void init() { memset(graph, 0x3f, sizeof(graph)); cin \u0026gt;\u0026gt; V \u0026gt;\u0026gt; E; int from, to, cost; for (int i = 0 ; i \u0026lt; E; i++) { cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to \u0026gt;\u0026gt; cost; graph[from][to] = cost; } } // SPFA算法求解最短路 void SPFA(int s) { memset(d, 0x3f, sizeof(d)); memset(vis, 0, sizeof(vis)); memset(push_count, 0, sizeof(push_count)); d[s] = 0; que.push(s); vis[s] = 1; push_count[s]++; while (!que.empty()) { int flag = 0; // 负环判断 int v = que.top(); que.pop(); vis[v] = 0; for (int i = 0; i \u0026lt; V; i++) { if (d[v] + graph[v][i] \u0026lt; d[i]) { d[i] = d[v] + graph[v][i]; if (!vis[i]) { que.push(i); vis[i] = 1; push_count[i]++; if (push_count[i] \u0026gt;= V) { flag = 1; break; } } } } if (flag) { cout \u0026lt;\u0026lt; \u0026#34;有负环\u0026#34; \u0026lt;\u0026lt; endl; break; } } } 弗洛伊德算法 O(V^3) 多源问题可以考虑用它~ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const int MAXN = 100; const int INF = 0x3f3f3f3f; // 有向无环图 DAG int V, E; // 顶点数和边数 int graph[MAXN][MAXN]; // DAG邻接矩阵，初始值为INF，不可达为INF，否则为cost值 int d[MAXN][MAXN];\t// 从任意结点出发到其它任意结点的最短路径长度，初始值为INF // 初始化图 void init() { memset(graph, 0x3f, sizeof(graph)); cin \u0026gt;\u0026gt; V \u0026gt;\u0026gt; E; int from, to, cost; for (int i = 0 ; i \u0026lt; E; i++) { cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to \u0026gt;\u0026gt; cost; graph[from][to] = cost; } } // 弗洛伊德算法求解最短路 void Floyd() { // 初始化矩阵d memset(d, 0x3f, sizeof(d)); for(int i = 0; i \u0026lt; V; i++) for(int j = 0; j \u0026lt; V; j++) d[i][j] = graph[i][j]; for(int k = 0; k \u0026lt; V; k++){//以顶点k为中转 for(int i = 0; i \u0026lt; V; i++){//从顶点i到顶点j for(int j = 0; j \u0026lt; V; j++){ if (d[i][j] \u0026gt; d[i][k] + d[k][j]) d[i][j] = d[i][k] + d[k][j]; } } } } 附：\n链式前向星 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 const int MAXN = 100; struct Edge { int to; // 边的终点 int next; // 与该边同起点的下一条边的编号 int w; // 边的权值 }; Edge edge[MAXN]; // 所有边的集合 int head[MAXN]; // 所有起点的第一条边的编号，初始化为-1 int V, E; // 建立图 void build() { int from, to, w, cnt = 0; for (int i = 0; i \u0026lt; E; i++) { cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to \u0026gt;\u0026gt; w; edge[cnt].to = to; edge[cnt].w = w; edge[cnt].next = head[from]; // 因此可将head初始化为-1，当next为-1时代表以该点为起点的边访问结束 head[from] = cnt++; } } // 遍历整个图 void traverse() { for (int i = 0; i \u0026lt; V; i++) { for (int j = head[i]; j != -1; j = edge[j].next) { cout \u0026lt;\u0026lt; \u0026#34; from \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; to \u0026#34; \u0026lt;\u0026lt; edge[j].to \u0026lt;\u0026lt; \u0026#34; weight: \u0026#34; \u0026lt;\u0026lt; edge[j].w \u0026lt;\u0026lt; endl; } } } // 遍历某个结点的邻接点 void traverse_v(int v) { for (int i = head[v]; i != -1; i = edge[i].next) { cout \u0026lt;\u0026lt; \u0026#34; from \u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; to \u0026#34; \u0026lt;\u0026lt; edge[i].to \u0026lt;\u0026lt; \u0026#34; weight: \u0026#34; \u0026lt;\u0026lt; edge[i].w \u0026lt;\u0026lt; endl; } } over~\n","permalink":"/posts/2020/11/summary-of-shortest-path-problems/","tags":["algorithm"],"title":"最短路问题汇总"},{"categories":["Algorithm"],"contents":"gcd辗转相除法求最大公约数 思路：反复交换取余，直到小的数为0。\n1 2 3 4 int gcd(int a, int b){ if(b == 0) return a; return gcd(b, a % b); } exgcd扩展欧几里得算法 先介绍贝祖定理：\n若a,b为整数，则一定存在整数x,y，使得$ax + by = gcd(a,b)$。\n即若$ax + by = m$有解，则m一定为gcd(a,b)的若干倍。\n下面是一道题：\n有a, -a, b, -b四个整数，各用几次可以使得$ax + by = 1$?\n由上述思想则可知gcd(a,b)等于1，可编写一个返回值为gcd(a,b)同时递归计算x和y的函数。\n关于求出x和y推导过程：\n由$ax + by = gcd(a,b)$ (1)\n通过辗转相除法的思想得：$bx_1 + (a \\mod b) y_1 = gcd(a,b)$\n由$a \\mod b = a - (a \\div b) \\times b$带入得:\n$ay_1 + b \\times (x_1 -(a \\div b) \\times y_1) == gcd(a,b) $(2)\n由（1）（2）可得：\n$x = y_1$\n$y = (x_1 - (a \\div b) \\times y_1)$\n由等式可知上层的x,y可以由下层的x1,y1来求,则可以通过递归来实现。\n又由（1），当$b = 0, a \\times 1 + b \\times 0 = a = gcd(a,b)$\n则此时$x = 1, y = 0$, 一定会出现在递归末尾。\n1 2 3 4 5 6 7 8 9 10 11 12 int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { int d = a; if (b != 0) { d = exgcd(b, a%b, x, y); int temp = y; y = x - (a / b) * y; //上一层的y x = temp; //上一层的x } else { x = 1; y = 0; } return d; } From My Blog: akynazh.\nOver.\n","permalink":"/posts/2020/07/on-rolling-division-and-extended-euclidean-algorithm/","tags":["algorithm","math"],"title":"关于辗转相除法和扩展欧几里得算法"},{"categories":["Algorithm"],"contents":"埃氏筛法 问1000000000000以内有多少个素数？\n运用朴素算法必TLE，这时考虑埃氏筛法。\n算法思路：\n建立is_prime[]数组，初始化为true； 从2开始筛取，(注意从2开始很重要，因为2为素数，否则需要改变相应后续操作)，若为true，则继续判断是否为素数，若为素数，则将所有该素数的倍数置为false。 相应代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 bool is_prime[MAXN]; //返回n以内的素数个数 int sieve(int n) { int c = 0; for (int i = 2; i \u0026lt;= n; ++i) is_prime[i] = true; for (int i = 2; i \u0026lt;= n; ++i) if (is_prime[i]) { c++; for (int j = 2 * i; j \u0026lt;= n; j += i) is_prime[j] = false; } return c; } 区间筛法 问[21479862, 21499877)之间有多少个素数？\n这时若采用埃氏筛法，会浪费大量时间计算前面未涉及的区间，这时考虑区间筛法。\n算法思路：\n对$[a,b)$，由于b以内任意合数的最小质因数不大于$\\sqrt{b}$，则可对$[2, \\sqrt{b})$进行埃氏筛法，每次得到一个素数，就可以知道在a即a以后的该素数的倍数不为质数。\n相应代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef long long ll; bool is_prime[MAX1]; // [2, 根号b) bool is_prime_small[MAX2]; // [0, b-a] void sieve(ll a, ll b) { for(ll i = 0; i * i \u0026lt; b; i++) is_prime_small[i] = true; for(ll i = 0; i \u0026lt; b - a; i++) is_prime[i] = true; for(ll i = 2; i * i \u0026lt; b; i++) { if(is_prime_small[i]) { for(ll j = 2 * i; j * j \u0026lt; b; j += i) is_prime_small[j] = false; for(ll j = max(2ll, (a + i - 1) / i)) * i; j \u0026lt; b; j += i) is_prime[j - a] = false; } } } 注意点：\nmax(2ll, (a + i - 1) / i) * i ，得到a或a以后的第一个该素数的倍数，最小为2a，其中的2ll隐式地将max的参数类型转换为long long 型。\n为什么(a + i - 1) / i * i 可以得到的是a或a以后的第一个该素数（i）的倍数？ 证明如下：\n（1）当a为该素数（i）的倍数时，设倍为x，则a等于ix，可以推出如下结果：\n$$\\begin{aligned} (a+i-1)\\div i \\times i \u0026amp;= (ix + i - 1) \\div i \\times i \\\n\u0026amp;= [ix \\div i + (i - 1) / i] * i \\ \u0026amp;= ix \\end{aligned}$$\n（2）当a不为该素数（i）的倍数时，设$a=ix + t$, $t \u0026gt;= 1 且 t \u0026lt; x$，从而可以推出如下结果： $$\\begin{aligned} (ix + t + i - 1) / i \\times i \u0026amp;= [ix \\div i + (i - 1 + t) / i] * i \\ \u0026amp;= (x + 1) * i \\ \u0026amp;= ix + i \u0026gt; ix + t \\end{aligned}$$\n易知ix+i为i的倍数，证毕。\nFrom My Blog: akynazh.\nOver.\n","permalink":"/posts/2020/07/some-algorithms-about-prime-numbers/","tags":["algorithm","math"],"title":"有关素数的一些算法"},{"categories":["Web"],"contents":"注：该项目只适用于旧版花瓣，但其中的思路值得领会。对于新版花瓣编写的代码，逻辑差别不大。\n需要安装的库 urllib easygui selenium webdriver_manager 获取过程 进入面板内 复制当前面板url 启动该脚本按提示进行即可 代码编写流程 分析pin图特点 查看面板源码，可以在对应的script中找到面板中图片的json数据。\n在app.page[\u0026ldquo;board\u0026rdquo;]下可以找到\u0026quot;pins\u0026quot;:[{\u0026hellip;}]，主要图片ID(pin)位于这里面。\n获取到图片的ID(pin)之后可以对应访问点击图片后进入的地址http://huaban.com/pins/pinId/，并获取页面源码：\n显然可见主要图片的源码特征，书写对应正则表达式可以获取图片真实地址。\n分析滚动特点 通过滚动页面我们可以发现加载规律：\n原来的图片对应的代码：\n经过滚动，原来的代码逐渐被一些新的代码取代：\n而不难发现他们都有对应的data-id!而data-id就是图片地址中对应的pin。\n所以我们可以通过webdriver滚动加载页面，每滚动一次就进行一次data-id的读取，并利用集合进行去重即可。\n具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 # 花瓣用户任意面板图片爬取 import urllib.request import urllib.error import re import os import datetime import easygui import time from selenium import webdriver from selenium.webdriver.chrome.service import Service from selenium.webdriver.common import service from webdriver_manager import driver from webdriver_manager.chrome import ChromeDriverManager import winsound # 获取网页中所有图片对应的pin def get_pins(url_, num_): my_options = webdriver.ChromeOptions() my_options.add_argument(\u0026#34;start-maximized\u0026#34;) my_options.add_argument(\u0026#34;--ignore-certificate-errors\u0026#34;) my_options.add_argument(\u0026#34;--ignore-ssl-errors\u0026#34;) my_options.add_experimental_option(\u0026#34;excludeSwitches\u0026#34;, [\u0026#39;enable-automation\u0026#39;, \u0026#39;enable-logging\u0026#39;]) driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=my_options) # 如果当前chromedriver版本不对，会自动去官网下载对应的版本到~/.wdm/drivers/chromedriver里，且会有缓存，下次直接读取缓存 driver.get(url_) js = \u0026#34;window.scrollTo(0,document.body.scrollHeight);\u0026#34; # js脚本实现向下滑动 pattern = re.compile(r\u0026#39;data-id=?\u0026#34;(\\d*)\u0026#34;\u0026#39;) pins_ = set() # 可以使用大括号 { } 或者 set() 函数创建集合，但是注意如果创建一个空集合必须用 set() 而不是 { }，因为{}是用来表示空字典类型的。 num = int(num_) tries = num / 15 + 1; # 滑动次数，每次滑动大约可以获得15张图片的pin while True: tries -= 1 html_ = driver.page_source pins_1 = re.findall(pattern, html_) # 返回获取到的pin列表 pins_2 = set(pins_1) # pin列表转化为pin集合 pins_.update(pins_2) # 求交集，以免下载重复照片 driver.execute_script(js) time.sleep(1) # 给脚本运行留足时间 if tries \u0026lt; 0: break driver.close() return pins_ # 获取页面html def get_html_1(url_): try: page = urllib.request.urlopen(url_) except urllib.error.URLError: return \u0026#39;fail\u0026#39; html_ = page.read().decode(\u0026#39;utf-8\u0026#39;) return html_ # 下载图片 def get_image(path_, pin_list): success = 0 fail = 0 now = time.time() t_now = time.strftime(\u0026#34;%Y-%m-%d_%H-%M-%S_\u0026#34;, time.localtime(now)) for pinId in pin_list: # 获取跳转网页网址 url_str = r\u0026#39;http://huaban.com/pins/%s/\u0026#39; % pinId # 获取点击图片时弹出网页的源码 pinId_source = get_html_1(url_str) if pinId_source == \u0026#39;fail\u0026#39;: continue # 解析源码，获取原图片的网址 \u0026#39;\u0026#39;\u0026#39; \u0026lt;div class=\u0026#34;main-image\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;image-holder\u0026#34; id=\u0026#34;baidu_image_holder\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;//hbimg.huabanimg.com/64369267b9c8dc7a43da81457658c05b1a752f9329ec0-dSfdfl_fw658/format/webp\u0026#34; \u0026#39;\u0026#39;\u0026#39; img_url_re = re.compile(\u0026#39;main-image.*?src=\u0026#34;(.*?)\u0026#34;\u0026#39;, re.S) img_url_list = re.findall(img_url_re, pinId_source) img_url = \u0026#39;http:\u0026#39; + img_url_list[0] try: urllib.request.urlretrieve(img_url, path_ + \u0026#34;\\\\\u0026#34; + t_now + str(success) + \u0026#34;.jpg\u0026#34;) # urlretrieve()方法直接将远程数据下载到本地 except urllib.error.URLError: print(\u0026#34;获取失败！%s\u0026#34; % img_url) fail += 1 continue print(\u0026#34;获取成功！%s\u0026#34; % img_url) success += 1 print(\u0026#34;成功获取图片张数：%d\u0026#34; %success) print(\u0026#34;获取失败的图片张数：%d\u0026#34; %fail) winsound.Beep(frequency=250, duration=500) os.system(\u0026#34;pause\u0026#34;) # 创建文件夹路径 def createPath(): while True: path_ = easygui.diropenbox(title=\u0026#39;选择你要保存的路径\u0026#39;) filePath = path_ + \u0026#34;\\\\\u0026#34; + str(datetime.datetime.now().strftime(\u0026#39;%Y-%m-%d %H.%M.%S\u0026#39;)) isExists = os.path.exists(filePath) if not isExists: # 创建目录 os.makedirs(filePath) print(\u0026#39;%s创建成功！\u0026#39; % filePath) break else: print(\u0026#39;%s已存在重新输入！\u0026#39; % filePath) return filePath if __name__ == \u0026#39;__main__\u0026#39;: # 用户输入数据 values = easygui.multenterbox(\u0026#34;获取花瓣用户任意面板中的图片\u0026#34;, \u0026#34;welcome\u0026#34;, [\u0026#34;面板的地址\u0026#34;, \u0026#34;想下载的大概张数\u0026#34;]) url = values[0] num = values[1] path = createPath() # 获取图片的pin pins = get_pins(url, num) # 获取并下载图片 print(\u0026#39;即将为主人下载%d张照片~\u0026#39; %len(pins)) get_image(path, pins) From My Blog: akynazh.\nOver.\n","permalink":"/posts/2020/02/python-automatically-crawls-all-pictures-in-any-panel-of-petal-net/","tags":["python","web"],"title":"Python 自动爬取花瓣网任意面板中所有图片"},{"categories":["Language"],"contents":"基本语法方面 提取矩阵某行或某列 1 A(:, [2 3]) 返回第2和第3列 获取随机数 1 randi(100); % 1 到 100 之间的随机整数 初始化数组 1 zeros(1, 30); % 1行30列的全0数组 控制语句 1 2 3 4 5 6 7 8 9 10 for i = 0 : 100 for j = 1 : 10 if (...) ... else ... end end ... end 格式化输出 1 fprintf(\u0026#34;若选手选择改变，则成功次数为：%d, 成功率为：%f\\n\u0026#34;, count, count / SUM); 初等数学方面 求解方程组 注：solve已经改版，不可传入字符串\n实例：求解二元一次方程\n1 2 3 4 syms x y; s = x - 6 * y == 2; t = 5 * x + 4 * y == 3; result = solve(s, t); 求平均值，中值与标准差 1 2 3 4 5 A = [12 13 7 18 16 21 9 10 2 18]; A = sort(A); ave = mean(A); md = median(A); sigma = std(A); 解一阶导数方程 1 2 3 4 5 syms x y; y = -0.0283 * x^2 + 0.7387 * x + 8.9191; my_x = solve(diff(y)); % diff(A)用于求导数 my_y = subs(y, x, my_x); % 当x=my_x时求y的值 fprintf(\u0026#34;(%.2f, %.2f)\\n\u0026#34;, my_x, my_y); 基础绘图方面 绘制二维图 绘制二维图并设置x,y轴通过坐标原点\n1 2 3 4 5 6 7 x = [-2.5*pi:0.1:2.5*pi]; y = [-1:0.1:1]; y = cos(x); plot(x,y) ax = gca; ax.XAxisLocation = \u0026#39;origin\u0026#39;; ax.YAxisLocation = \u0026#39;origin\u0026#39;; 绘制三维图 使用mesh或surf，subplot进行分区\n1 2 3 4 5 6 [x, y] = meshgrid(-5:0.1:5, -3:0.1:3); z = x.^2 + y.^2; subplot(1,2,1) surf(x, y, z); subplot(1,2,2) mesh(x,y,z) 绘制等高线 1 2 3 4 5 6 7 [x, y] = meshgrid(-5:0.1:5, -3:0.1:3); z = x.^2 + y.^2;%z就是高度 contour(x,y,z)%绘制等高线 subplot(2,2,1) [C,h] = contour(x,y,z, \u0026#39;ShowText\u0026#39;, \u0026#39;on\u0026#39;); % [M,c] = contour(___) 返回等高线矩阵和等高线对象 c。 % 显示等高线图后，使用 c 设置属性。 高数和线代方面 泰勒级数第n项展开 1 T = taylor(f, x, \u0026#39;Order\u0026#39;, n); 求极大线性无关组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 A = 1 2 3 1 0 1 2 -2 2 1 0 8 \u0026gt;\u0026gt; [R j] = rref(A) R = 1 0 -1 5 0 1 2 -2 0 0 0 0 %主元所在列数 j = 1 2 % 即得到极大线性无关组 \u0026gt;\u0026gt; M = A(:,[1,2]) M = 1 2 0 1 2 1 求Ax = 0基础解系 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 A = 2 -2 1 3 9 -5 2 8 %求出最小有理数解 \u0026gt;\u0026gt; r = rank(A); \u0026gt;\u0026gt; X = null(A, \u0026#39;r\u0026#39;) X = 0.1250 -0.1250 0.6250 1.3750 1.0000 0 0 1.0000 %求出规范正交基 \u0026gt;\u0026gt; X = null(A) X = 0.1293 -0.1052 0.3860 0.7386 0.9041 -0.2092 -0.1302 0.6322 左除与右除 1 2 右除正斜杠： A / B -\u0026gt; A * inv(B) 左除反斜杠： A \\ B -\u0026gt; inv(A) * B 求Ax = b特解 1 2 3 A非方阵时，无法利用x = A^(-1) * b 应该使用x = A \\ b 计算特征多项式及特征值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026gt;\u0026gt; A = [1 2 3; 2 1 3; 3 3 6] A = 1 2 3 2 1 3 3 3 6 \u0026gt;\u0026gt; f = poly(A) f = 1.0000 -8.0000 -9.0000 -0.0000 \u0026gt;\u0026gt; lamda = roots(f) lamda = 9.0000 -1.0000 -0.0000 计算特征值的简易方法 1 2 3 4 5 6 7 \u0026gt;\u0026gt; eig(A) ans = -1.0000 -0.0000 9.0000 计算特征值及对应特征向量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026gt;\u0026gt; [Q, D] = eig(A) Q = 0.7071 0.5774 0.4082 -0.7071 0.5774 0.4082 0 -0.5774 0.8165 D = -1.0000 0 0 0 -0.0000 0 0 0 9.0000 使用命令eig把二次型标准化 1 同上，由D可得标准型，由Q可得正交变换法。 使用命令eig判断二次型的正定性 1 同上，观察D对角线元素正负性即可。 使用命令orth把向量组正交规范化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 A = 2 -2 1 3 9 -5 2 8 \u0026gt;\u0026gt; B = orth(A) B = -0.2982 0.9545 -0.9545 -0.2982 %满足B * B\u0026#39; == eye(rank(A)) \u0026gt;\u0026gt; B * B\u0026#39; ans = 1.0000 0.0000 0.0000 1.0000 ","permalink":"/posts/2020/02/basic-usage-sorting-of-matlab/","tags":["matlab","math"],"title":"Matlab 基本用法整理"},{"categories":null,"contents":"The name of this site comes from a song call Norwegian Wood, by The Beatles from their 1965 album Rubber Soul. The song\u0026rsquo;s special feeling attracts me and I love its subtle sense of sadness. By the way, Julia and And I love her are also my favorites.\nNorwegian Wood (ノルウェイの森) is also a 1987 novel by Haruki Murakami. I read this novel in 2020 and I also start to write blogs in 2020. And I can tell you that I really like 小林緑 in this novel. I write a blog about the music by The Beatles in this novel here.\nI am still a student and I love music and coding. And I want to play guitar now\u0026hellip; Have a good time here.\n","permalink":"/about/","tags":null,"title":"About"}]