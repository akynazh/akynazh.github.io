<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>design on Norwegian Wood</title>
    <link>/tags/design/</link>
    <description>Recent content in design on Norwegian Wood</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Jzh</copyright>
    <lastBuildDate>Fri, 26 Aug 2022 16:04:19 +0800</lastBuildDate><atom:link href="/tags/design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>策略模式</title>
      <link>/posts/2022/08/policy-mode/</link>
      <pubDate>Fri, 26 Aug 2022 16:04:19 +0800</pubDate>
      
      <guid>/posts/2022/08/policy-mode/</guid>
      <description>定义 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
比如对于鸭子而言，不同鸭子的叫声方式可能不一样也可能一样，我们可以定义一个叫声行为接口，然后通过创建不同的叫声行为实现这个接口，在实例化鸭子时设定叫声行为即可。
这样相比于直接继承抽象鸭子后重写叫声行为方法，好处是减少了重复代码，而坏处是增加了类的数量。
代码展示 下面就以鸭子为例进行说明。
从接口开始 定义一个叫声接口：（其它接口省略）
1 2 3 public interface QuackBehavior { public void quack(); } 实现叫声接口 1 2 3 4 5 public class MuteQuack implements QuackBehavior { public void quack() { System.out.println(&amp;#34;&amp;lt;&amp;lt; Silence &amp;gt;&amp;gt;&amp;#34;); } } 其它接口省略。
创建抽象鸭子 每只鸭子都有Fly和Quack这两种行为。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public abstract class Duck { FlyBehavior flyBehavior; QuackBehavior quackBehavior; public Duck() { } public void setFlyBehavior(FlyBehavior fb) { flyBehavior = fb; } public void setQuackBehavior(QuackBehavior qb) { quackBehavior = qb; } abstract void display(); public void performFly() { flyBehavior.</description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>/posts/2022/08/proxy-pattern/</link>
      <pubDate>Fri, 26 Aug 2022 10:41:19 +0800</pubDate>
      
      <guid>/posts/2022/08/proxy-pattern/</guid>
      <description>定义 代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。
我们对一个对象的使用或者一个对象中方法的调用，可以通过这个对象的代理人进行访问，这个代理人可以方便地控制这个对象，让对象的功能更为强大或更易于使用。
常见的代理有：远程代理，虚拟代理，动态代理。
远程代理 对于远程代理，其实就是本地调用远程的方法，本地堆（客户端）有一个Stub代理对象，这个对象负责完成RMI操作，也就是远程方法调用，而远程堆（服务端）有一个Skeleton代理对象，它接收客户端的RMI操作，并传递给真正的服务对象进行服务，之后再返回给客户端结果。
使用过程中需要注意调用的对象必须是可序列化的，无需序列化的对象可以添加transient关键字。通过rmiregistry &amp;amp;开启RMI，之后进行服务注册。服务端通过Naming.rebind()绑定服务地址，客户端通过Naming.lookup()调用远程方法。另外，远程传输对象需要继承于UnicastRemoteObject。
在Java5中，RMI和动态代理搭配使用，动态代理动态产生Stub，远程对象的Stub是Proxy实例，它是自动产生的，来处理所有把客户的本地调用变成远程调用的细节。
虚拟代理 对于虚拟代理，也就是说这个代理对象是虚拟的，由代理来扮演对象的替身。
比如对于从网络加载一副图像展现给用户，我们可能需要等待一定时间，这段时间内图像应该展现为用户友好的“等待中”字样，而在网络图像获取成功后进行网络图像的展现。
这个过程可以通过代理的方式方便地完成：虚拟代理对象扮演图像的替身，它通过创建一个线程加载网络图像，加载期间将图像动态地变为用户友好字样，完成加载后改为网络图像。
可以发现我们不是直接使用图像本身，而使用了代理对象作为图像，也就是说，代理扮演了图像这个角色。
下面是一个图像代理对象：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class ImageProxy implements Icon { volatile ImageIcon imageIcon; final URL imageURL; Thread retrievalThread; boolean retrieving = false; public ImageProxy(URL url) { imageURL = url; } public int getIconWidth() { .</description>
    </item>
    
    <item>
      <title>状态模式</title>
      <link>/posts/2022/08/status-mode/</link>
      <pubDate>Thu, 25 Aug 2022 22:54:26 +0800</pubDate>
      
      <guid>/posts/2022/08/status-mode/</guid>
      <description>定义 状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
比如某个机器有各种复杂的状态，每个状态都着共同的参数，而这些参数值有区别。用户通过某些操作会改变机器的状态，机器转变状态后，以当前状态的方法给用户反馈。
代码展示 以机器的例子说明。
从接口开始 编写状态接口：
1 2 3 4 5 6 7 8 9 public interface State { public void insertQuarter(); public void ejectQuarter(); public void turnCrank(); public void dispense(); public void refill(); } 创建机器类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 package headfirst.</description>
    </item>
    
    <item>
      <title>组合模式</title>
      <link>/posts/2022/08/combination-mode/</link>
      <pubDate>Thu, 25 Aug 2022 21:58:13 +0800</pubDate>
      
      <guid>/posts/2022/08/combination-mode/</guid>
      <description>定义 组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。
对于菜单内容而言，假如只有简单的菜品项，那么通过迭代器可以轻松地遍历，但是如果菜单内容中含有子菜单，那么就需要组合模式了。
代码展示 下面就以菜单为例子展示组合模式。
从抽象开始 创建菜单组件：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public abstract class MenuComponent { public void add(MenuComponent menuComponent) { throw new UnsupportedOperationException(); } public void remove(MenuComponent menuComponent) { throw new UnsupportedOperationException(); } public MenuComponent getChild(int i) { throw new UnsupportedOperationException(); } public String getName() { throw new UnsupportedOperationException(); } public String getDescription() { throw new UnsupportedOperationException(); } public double getPrice() { throw new UnsupportedOperationException(); } public boolean isVegetarian() { throw new UnsupportedOperationException(); } public void print() { throw new UnsupportedOperationException(); } } 创建菜单 菜单本身是一个菜单组件，菜单继承于菜单组件，实现父类方法。</description>
    </item>
    
    <item>
      <title>迭代器模式</title>
      <link>/posts/2022/08/iterators-mode/</link>
      <pubDate>Thu, 25 Aug 2022 11:26:17 +0800</pubDate>
      
      <guid>/posts/2022/08/iterators-mode/</guid>
      <description>定义 迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。
通过一个Iterator，可以方便地遍历各种类型，如HashMap，ArrayList等。
代码展示 下面通过菜单的例子进行说明。
分别用简单数组String[]和ArrayList&amp;lt;String&amp;gt;类创建菜单内容。
从接口开始 创建菜单接口：
1 2 3 public interface Menu { public Iterator&amp;lt;String&amp;gt; createIterator(); } 每个菜单都可以返回一个迭代器。
创建Diner菜单 该菜单用String[]创建内容，需要编写自己的迭代器。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class DinerMenu implements Menu { static final int MAX_ITEMS = 6; int numberOfItems = 0; String[] menuItems; public DinerMenu() { menuItems = new String[MAX_ITEMS]; addItem(&amp;#34;Vegetarian BLT&amp;#34;); addItem(&amp;#34;BLT&amp;#34;); addItem(&amp;#34;Soup of the day&amp;#34;); addItem(&amp;#34;Hotdog&amp;#34;); addItem(&amp;#34;Steamed Veggies and Brown Rice&amp;#34;); addItem(&amp;#34;Pasta&amp;#34;); } public void addItem(String name) { if (numberOfItems &amp;gt;= MAX_ITEMS) { System.</description>
    </item>
    
    <item>
      <title>模板方法模式</title>
      <link>/posts/2022/08/template-method-mode/</link>
      <pubDate>Wed, 24 Aug 2022 17:14:16 +0800</pubDate>
      
      <guid>/posts/2022/08/template-method-mode/</guid>
      <description>定义 模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
“好莱坞”原则 别调用我们，我们会调用你。
其实就是防止“依赖腐败”，也就是要避免高层组件和低层组件相互依赖。一般由高层组件依赖低层组件。
代码展示 泡茶和泡咖啡有着几乎相同的步骤，但在某些子步骤中有差别。通过模板方法可以很好地解决问题。
定义模板方法 子步骤brew()和addCondiments()为抽象方法，由子类具体实现。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public abstract class CaffeineBeverage { final void prepareRecipe() { boilWater(); brew(); pourInCup(); addCondiments(); } abstract void brew(); abstract void addCondiments(); void boilWater() { System.out.println(&amp;#34;Boiling water&amp;#34;); } void pourInCup() { System.out.println(&amp;#34;Pouring into cup&amp;#34;); } } 定义具体方法 继承CaffeineBeverage并实现抽象方法。
1 2 3 4 5 6 7 8 public class Coffee extends CaffeineBeverage { public void brew() { System.</description>
    </item>
    
    <item>
      <title>外观模式</title>
      <link>/posts/2022/08/appearance-mode/</link>
      <pubDate>Tue, 23 Aug 2022 16:20:06 +0800</pubDate>
      
      <guid>/posts/2022/08/appearance-mode/</guid>
      <description>外观模式 定义 外观模式提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。
“最少知识”原则 减少对象之间的交互，只和“密友”谈话，也就是减少一个类所交互的类的数量。
代码展示 执行一些复杂操作需要一步步执行许多小操作，那么可以将复杂操作封装为一个高层类中的方法，将所有复杂操作需要用到的类作为高层类的成员，在复杂操作的方法中可以方便的调用各个类执行各自的功能。
下面是一个家庭影院的例子：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 public class HomeTheaterFacade { Amplifier amp; Tuner tuner; StreamingPlayer player; CdPlayer cd; Projector projector; TheaterLights lights; Screen screen; PopcornPopper popper; public HomeTheaterFacade(Amplifier amp, Tuner tuner, StreamingPlayer player, Projector projector, Screen screen, TheaterLights lights, PopcornPopper popper) { this.</description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>/posts/2022/08/adapter-mode/</link>
      <pubDate>Tue, 23 Aug 2022 16:00:04 +0800</pubDate>
      
      <guid>/posts/2022/08/adapter-mode/</guid>
      <description>适配器模式 定义 适配器模式将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。
代码展示 鸭子和火鸡叫声不一样，通过编写适配器让火鸡适配鸭的方法。
从接口开始 1 2 3 4 public interface Duck { public void quack(); public void fly(); } 1 2 3 4 public interface Turkey { public void gobble(); public void fly(); } 编写适配器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class TurkeyAdapter implements Duck { Turkey turkey; public TurkeyAdapter(Turkey turkey) { this.turkey = turkey; } public void quack() { turkey.</description>
    </item>
    
    <item>
      <title>命令模式</title>
      <link>/posts/2022/08/command-mode/</link>
      <pubDate>Mon, 22 Aug 2022 11:41:33 +0800</pubDate>
      
      <guid>/posts/2022/08/command-mode/</guid>
      <description>定义 命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。
比如对于遥控器而已，我们会将操作封装为一个按钮（命令）对象，通过按下按钮执行操作。
代码展示 下面以遥控器作为例子：
从接口开始 命令接口：
1 2 3 public interface Command { public void execute(); } 定义操控对象 一个风扇对象：（其它对象省略了）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Light { String location = &amp;#34;&amp;#34;; public Light(String location) { this.location = location; } public void on() { System.out.println(location + &amp;#34; light is on&amp;#34;); } public void off() { System.out.println(location + &amp;#34; light is off&amp;#34;); } } 定义操控对象的命令 操作风扇的命令：</description>
    </item>
    
    <item>
      <title>单件模式</title>
      <link>/posts/2022/08/singleton-pattern/</link>
      <pubDate>Mon, 22 Aug 2022 11:14:23 +0800</pubDate>
      
      <guid>/posts/2022/08/singleton-pattern/</guid>
      <description>我的思考 单件模式，容易知道需要某个对象是独一无二的，那么它首先应该是静态的，不能在程序动态运行期间被再次创建。
当在多个线程中用到它时，在创建时需要考虑线程安全问题，可通过加锁等方式解决。
代码实现 传统的单件 定义一个私有实例化的对象，把单件对象作为一个私有的静态成员变量，通过静态方法Singleton.getInstance()获取，若获取为null则创建对象。
1 2 3 4 5 6 7 8 9 10 11 12 public class Singleton { private static Singleton uniqueInstance; private Singleton() {} public static Singleton getInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } } 线程安全的单件 传统的单件线程不安全，解决如下：
1 2 3 4 5 6 7 8 9 10 11 12 public class Singleton { private static Singleton uniqueInstance; private Singleton() {} public static synchronized Singleton getInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } } 改善多线程性能 如上线程安全的代码，getInstance()在多次调用的情况下性能太低，改善方法如下：</description>
    </item>
    
    <item>
      <title>工厂模式</title>
      <link>/posts/2022/08/factory-mode/</link>
      <pubDate>Sun, 21 Aug 2022 23:31:45 +0800</pubDate>
      
      <guid>/posts/2022/08/factory-mode/</guid>
      <description>我的思考 工厂模式，包括工厂方法模式和抽象工厂模式。
对于工厂方法模式，工厂是一个抽象类，提供了一些默认实现方法和一些抽象方法，具体工厂继承于它，实现对应抽象方法。
假设有多家比萨店，他们提供不同口味的比萨，而都有相同的订购比萨的方法，那么可以定义一个抽象类，提供订购比萨的具体方法和创建比萨的抽象方法。
对于抽象工厂模式，工厂是一个接口，提供了一些具体工厂会用到的方法，同时还需要定义这些方法可能用到的接口。具体工厂需要首先实现抽象工厂定义的方法可能用到的接口，然后实现抽象工厂的所有方法。
假设有多家生产比萨配料的工厂，他们都有自己的独特的配料（实现所有配料接口），那么可以定义一个抽象工厂（一个接口），提供所有配料创建方法，具体工厂各自实现所有创建方法即可。
总之，他们的具体区别如下：
工厂方法模式使用继承，把对象的创建委托给子类，子类实现工厂方法来创建对象。 抽象工厂模式使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中。 工厂方法模式代码 从抽象开始 比萨店抽象类：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 public abstract class PizzaStore { abstract Pizza createPizza(String item); public Pizza orderPizza(String type) { Pizza pizza = createPizza(type); System.out.println(&amp;#34;--- Making a &amp;#34; + pizza.getName() + &amp;#34; ---&amp;#34;); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; } } 具体的比萨店 芝加哥的比萨店：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ChicagoPizzaStore extends PizzaStore { Pizza createPizza(String item) { if (item.</description>
    </item>
    
    <item>
      <title>装饰者模式</title>
      <link>/posts/2022/08/decorator-mode/</link>
      <pubDate>Sun, 21 Aug 2022 23:17:27 +0800</pubDate>
      
      <guid>/posts/2022/08/decorator-mode/</guid>
      <description>我的思考 装饰，如其名，就是对一个对象进行加工，包装，修饰。
假设一杯“普通的咖啡，价格10”，我们可以选择添加自己喜欢的配料。
首先我们添加牛奶，那么就变成了一杯“含牛奶配料的咖啡，价格2 +（价格12）”；
我想再加点巧克力，那么再往上包装变成“含巧克力的含牛奶配料的咖啡，价格3 +【价格2+（价格12）】”。
这么一层层封装上去就是装饰模式。
我们要在每一个配料中定义一个可包装的对象，在包装后返回这个对象。具体代码如下文。
代码实现 定义抽象类 饮料抽象类：
1 2 3 4 5 6 7 8 9 public abstract class Beverage { String description = &amp;#34;Unknown Beverage&amp;#34;; public String getDescription() { return description; } public abstract double cost(); } 配料抽象类：
注意这里配料也继承了饮料类，这样Beverage在通过包装之后还是返回一个Beverage，具体见测试代码。
1 2 3 4 public abstract class CondimentDecorator extends Beverage { Beverage beverage; public abstract String getDescription(); } 定义具体类 牛奶配料：（其他配料省略）
1 2 3 4 5 6 7 8 9 10 11 12 13 public class Milk extends CondimentDecorator { public Milk(Beverage beverage) { this.</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>/posts/2022/08/observer-mode/</link>
      <pubDate>Sun, 21 Aug 2022 22:59:33 +0800</pubDate>
      
      <guid>/posts/2022/08/observer-mode/</guid>
      <description>我的思考 对于观察者模式，既然有观察者，那么就首先有被观察者。
观察者可以通过订阅，监听等方式实现“观察”，被观察者需要通过通知，发消息之类的方式通知观察者接收信息。
假设有一个气象观测站，天气数据对象作为被观察者，各个气象观测站作为观察者订阅天气数据，而天气数据记录各个订阅了自己的观测站，以便于通知。具体代码实现如下文。
代码实现 定义接口 被观察者：
1 2 3 4 5 public interface Subject { public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers(); } 观察者：
1 2 3 public interface Observer { public void update(float temp, float humidity, float pressure); } 定义对象实现接口 天气数据对象：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class WeatherData implements Subject { private List&amp;lt;Observer&amp;gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() { observers = new ArrayList&amp;lt;Observer&amp;gt;(); } public void registerObserver(Observer o) { observers.</description>
    </item>
    
  </channel>
</rss>
